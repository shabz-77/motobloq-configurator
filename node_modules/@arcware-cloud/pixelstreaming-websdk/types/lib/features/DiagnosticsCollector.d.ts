/**
 * DiagnosticsCollector.ts
 * Lightweight, privacy-aware client diagnostics for troubleshooting + analytics.
 * WebRTC collection intentionally omitted (to add later).
 *
 * Notes:
 * - Some fields are best-effort due to browser restrictions; they're nullable.
 * - Bandwidth probe requires a small binary served with:
 *     Content-Type: application/octet-stream
 *     Content-Encoding: identity
 *     Cache-Control: no-store
 *   Default location: /diag/probe.bin
 */
/**
 * These interfaces need to be copied manually from ITicket.ts for now if the interface changes there
 * The way how webpack, rollup and this whole mono repo is setup up, I cannot just import it......
 */
export interface IDiagnostics {
    device?: Device;
    network?: Network;
    powerHints?: PowerHints;
    runtime?: Runtime;
    timestamps?: Timestamps;
    webrtc?: Webrtc;
}
export interface Device {
    architecture?: null | string;
    bitness?: null | string;
    codecs?: Codecs;
    deviceMemory?: number | null;
    hardwareConcurrency?: number | null;
    model?: null | string;
    orientation?: Orientation | null;
    touchSupport?: boolean;
    type?: Type;
    vendor?: null | string;
    webgl?: boolean | null;
}
export interface Codecs {
    h264?: boolean;
    hevc?: boolean;
}
export declare enum Orientation {
    Landscape = "landscape",
    Portrait = "portrait"
}
export declare enum Type {
    Desktop = "desktop",
    Mobile = "mobile",
    Tablet = "tablet"
}
export interface Network {
    downlinkMbps?: number | null;
    effectiveType?: null | string;
    measuredDownlinkMbps?: number | null;
    rttMs?: number | null;
    type?: null | string;
}
export interface PowerHints {
    prefersReducedData?: boolean | null;
    prefersReducedMotion?: boolean | null;
    saveData?: boolean | null;
}
export interface Runtime {
    browser?: Browser;
    os?: OS;
}
export interface Browser {
    family?: string;
    version?: null | string;
}
export interface OS {
    family?: string;
    version?: null | string;
}
export interface Timestamps {
    collectedAt?: number;
}
export interface Webrtc {
    candidatePairId?: null | string;
    dtlsCipher?: null | string;
    localCandidateType?: null | string;
    networkType?: null | string;
    protocol?: null | string;
    remoteCandidateType?: null | string;
}
/**
 * Options that control how the DiagnosticsCollector behaves.
 *
 * You don’t *need* to set these for a basic Pixel Streaming website — the defaults
 * are good enough. But in production, these knobs let you control cost, UX impact,
 * and flexibility without changing the code.
 */
export interface DiagnosticsCollectorOptions {
    /**
     * Run a synthetic bandwidth probe? (default: true)
     *
     * - When true: the collector fetches a small binary file (see `probeUrl`)
     *   and measures download speed to estimate available bandwidth.
     * - Why it matters: gives you a ground-truth Mbps measurement that the
     *   browser doesn’t always expose.
     * - Downsides: adds one extra network request per session.
     * - When to disable: if you want *zero* extra traffic (e.g. privacy-sensitive
     *   deployments, embedded use cases).
     */
    enableBandwidthProbe?: boolean;
    /**
     * URL of the probe file used for bandwidth measurement. (default: "/diag/probe.bin")
     *
     * - Must be served as raw binary with headers:
     *     Content-Type: application/octet-stream
     *     Content-Encoding: identity
     *     Cache-Control: no-store
     * - Size: keep small (200–500 KB) for quick, accurate tests.
     * - Why you’d override: if you host assets on a CDN or want different probe
     *   files per region/environment.
     */
    probeUrl?: string;
    /**
     * Respect the user’s "Data Saver" mode? (default: true)
     *
     * - The browser exposes `navigator.connection.saveData`.
     * - When true: if saveData === true, the collector skips the bandwidth probe
     *   (to avoid wasting data).
     * - Why it matters: good UX and respectful to users on metered/limited data.
     * - When to disable: if accurate bandwidth numbers are critical even for
     *   Data Saver users (rare).
     */
    respectSaveData?: boolean;
    /**
     * Sampling rate for diagnostics collection. (range: 0.0–1.0, default: 1.0)
     *
     * - 1.0 (100%): collect diagnostics for every session (ideal in dev/beta).
     * - 0.1 (10%): collect for ~10% of sessions (reduces storage & processing costs).
     * - Why it matters: in production, detailed telemetry from *every* session
     *   may be too costly or noisy. Sampling still gives you trends.
     * - How it works: collector rolls a random number per session; only collects
     *   if value < sampleRate.
     */
    sampleRate?: number;
}
/**
 * DiagnosticsCollector
 */
export declare class DiagnosticsCollector {
    private opts;
    constructor(opts?: DiagnosticsCollectorOptions);
    /**
     * Collect the diagnostics payload.
     */
    collect(): Promise<IDiagnostics>;
    /**
     * Collect a safe subset of WebRTC stats once PC is connected.
     */
    collectWebRTC(pc: RTCPeerConnection): Promise<IDiagnostics["webrtc"]>;
    /**
     * Helper to embed diagnostics in a hello envelope.
     */
    buildHelloEnvelope(base: Record<string, any>, pc?: RTCPeerConnection): Promise<{
        ext: {
            diag: IDiagnostics;
        };
    }>;
    private shouldSample;
    private hasTouch;
    private getOrientation;
    private hasWebGL;
    /**
     * Heuristic device type: best-effort only.
     * Tries UA-CH, then UA fallback, then touch + screen size heuristics.
     */
    private inferDeviceType;
    private getPowerHints;
    private getNetworkInfo;
    private maybeMeasureBandwidth;
    private withCacheBuster;
    private getCodecSupport;
    private supportsCodec;
    private uaInfoCache;
    private getUAInfo;
}
