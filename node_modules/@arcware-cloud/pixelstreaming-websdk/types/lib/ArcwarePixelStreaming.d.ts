import { Messages } from "@arcware-cloud/shared-pixelstreaming-websdk";
import { PixelStreaming, PixelStreamingOverrides } from "@epicgames-ps/lib-pixelstreamingfrontend-ue5.5";
import { z } from "zod";
import { ArcwareConfig } from "./ArcwareConfig";
import { EventHandler } from "./domain/EventHandler";
import { Session } from "./domain/Session";
import { WebsocketState } from "./domain/ConnectionIdentifier";
type OutboundByKey<K extends keyof typeof Messages.Send> = z.input<(typeof Messages.Send)[K]> & {
    type: K;
};
export declare class ArcwarePixelStreaming extends PixelStreaming {
    /** Override default config with ArcwareConfig. */
    config: ArcwareConfig;
    streamInfo?: Messages.StreamInfo;
    loveLettersContainer: HTMLDivElement | undefined;
    private loveLettersList;
    private loveLettersQueue;
    private isProcessingQueue;
    private microphoneOverlay;
    private diagnosticsCollector;
    private outbox;
    private videoInitializedSent;
    private _boundTransport?;
    private _onWsOpen?;
    private _onWsClose?;
    private _transportWatchTimer?;
    private _rVFCsupported;
    private _rvfcHandle?;
    private _rVFCArmedForElement?;
    private _mo?;
    private _postInitSideEffectsDone;
    private resetInitGuardsAndHooks;
    reconnect(): void;
    private isRetryableClose;
    private bindTransportEvents;
    private get isWsOpen();
    /** Returns a list of WebSocketStates of all PixelStreaming Instances generated. */
    get WebsocketStates(): WebsocketState[];
    /** Counts all active PixelStreaming Instances generated. (CONNECTING & CONNECTED) */
    get ActiveInstances(): () => number;
    /** Returns this PixelStreaming Instances websocket state. */
    get websocketState(): WebsocketState;
    constructor(config: ArcwareConfig, overrides?: PixelStreamingOverrides);
    /** Getter for the session object. */
    get session(): Session;
    /**
     * * * * * * *
     *  Listen   *
     * * * * * * *
     */
    /** On version requested, the version of the WebSDK would be returned. */
    private onVersion;
    private isVideoRenderingNow;
    private waitForFirstFrameWithTimeout;
    private onRender;
    /** On ping the session creation timestamp will be updated. */
    private onPing;
    /** Handle incoming configurations. */
    private onStreamInfo;
    readonly queueHandler: EventHandler<{
        type?: "queue";
        queue?: {
            index?: number;
            queueLength?: number;
            waited?: number;
            estimatedWaitTime?: number;
            averageWaitTime?: number;
            valueType?: "milliseconds" | "seconds" | "minutes" | "hours" | "days";
        };
    }>;
    private onQueue;
    readonly errorHandler: EventHandler<{
        type?: "error";
        code?: number;
        reason?: string;
        verbosity?: number;
    }>;
    private onError;
    readonly loveLetterHandler: EventHandler<{
        type?: "letter";
        reason?: string;
        code?: number;
        verbosity?: number;
    }>;
    private onLoveLetter;
    readonly sessionIdHandler: EventHandler<string>;
    private onSessionId;
    private sendVideoInitializedOnce;
    /** VideoInitialized (native Epic event) */
    readonly videoInitializedHandler: EventHandler<never>;
    private runPostInitSideEffectsOnce;
    private onVideoInitialized;
    private attachFirstRenderedFrameOnce;
    private cancelFirstRenderedFrameHook;
    private watchVideoElementReplacement;
    readonly websocketOnCloseHandler: EventHandler<CloseEvent>;
    /** Adding a zod-safe handler. */
    private addMessageHandler;
    /**
     * * * * * *
     *  Send   *
     * * * * * *
     */
    private sendStats;
    send<K extends keyof typeof Messages.Send>(message: OutboundByKey<K>): void;
    send(type: string, payload?: Record<string, unknown>): void;
    send(message: {
        type: string;
    } & Record<string, unknown>): void;
    private _dispatchOrBuffer;
    private flushOutbox;
    private handleResolutionChange;
    private applyResolutionIfPlaying;
    removePlayer(): void;
    private startTransportWatcher;
    private stopTransportWatcher;
    private handleMouseLock;
    initLoveLettersContainer(): void;
    private pushLetter;
    private processLoveLetterQueue;
    private handleRemoveLoveLetters;
    toggleAudio(videoElement: HTMLVideoElement, enabled: boolean): void;
    private createMicrophoneOverlay;
    toggleMic(enable: boolean, isDefault: boolean): void;
    private wrapWebSocketOnCloseHandler;
    onStreamingStateChange(callback: (isStreaming: boolean) => void): void;
    private removeXRIconIfDisabled;
    private injectCustomUI;
}
export {};
