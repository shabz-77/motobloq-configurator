/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ 7099:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EventEmitter": () => (/* binding */ EventEmitter)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
// To match NodeJS' EventEmitter syntax without downstream code changes we need to use `any`.
// This means we need to disable linting `any` checks on this file.
//
/* eslint-disable @typescript-eslint/no-unsafe-argument */
class PixelStreamingEventListener {
    constructor(callback) {
        this._args = [];
        this._callback = callback;
    }
    handleEvent(_evt) {
        this._callback(...this._args);
        // Reset storage of args.
        this._args = [];
    }
    setArgs(...args) {
        this._args = args;
    }
}
/**
 * A feature-limited, but _mostly_ drop-in replacement for Node's EventEmitter type that is implemented using EventTarget.
 *
 * For those unfamiliar with Node's EventEmitter, here is some info from the official docs:
 *
 * [In NodeJS] all objects that emit events are instances of the `EventEmitter` class. These
 * objects expose an `eventEmitter.on()` function that allows one or more
 * functions to be attached to named events emitted by the object. Typically,
 * event names are camel-cased strings but any valid JavaScript property key
 * can be used.
 *
 * When the `EventEmitter` object emits an event, all of the functions attached
 * to that specific event are called _synchronously_. Any values returned by the
 * called listeners are _ignored_ and discarded.
 *
 * The following example shows a simple `EventEmitter` instance with a single
 * listener. The `eventEmitter.on()` method is used to register listeners, while
 * the `eventEmitter.emit()` method is used to trigger the event.
 *
 * ```js
 * import { EventEmitter } from 'node:events';
 *
 * class MyEmitter extends EventEmitter {}
 *
 * const myEmitter = new MyEmitter();
 * myEmitter.on('event', () => {
 *   console.log('an event occurred!');
 * });
 * myEmitter.emit('event');
 * ```
 */
class EventEmitter extends EventTarget {
    constructor() {
        super();
        this._eventListeners = new Map();
    }
    removeListenerInternal(eventName, listener) {
        if (this._eventListeners.has(eventName)) {
            const listeners = this._eventListeners.get(eventName);
            if (listeners === undefined) {
                return this;
            }
            for (let i = 0; i < listeners.length; ++i) {
                const eventPair = listeners[i];
                if (eventPair.callback === listener) {
                    // Remove from event target
                    super.removeEventListener(eventName, eventPair.eventListenerWrapper);
                    // Remove from our internal map
                    listeners.splice(i, 1);
                    break;
                }
            }
        }
        return this;
    }
    /**
     * Alias for `emitter.on(eventName, listener)`.
     */
    addListener(eventName, listener) {
        return this.on(eventName, listener);
    }
    /**
     * Adds the `listener` function to the end of the listeners array for the event
     * named `eventName`.
     *
     * ```js
     * server.on('connection', (stream) => {
     *   console.log('someone connected!');
     * });
     * ```
     *
     * Returns a reference to the `EventEmitter`, so that calls can be chained.
     *
     * @param eventName - The name of the event.
     * @param listener - The callback function
     */
    on(eventName, listener) {
        var _a;
        // Wrap our normal JS function in a event listener interface
        // so we can use it with event target.
        const eventListenerWrapper = new PixelStreamingEventListener(listener);
        super.addEventListener(eventName, eventListenerWrapper);
        // Store the event listener/function pair for later removal.
        if (!this._eventListeners.has(eventName)) {
            this._eventListeners.set(eventName, new Array());
        }
        (_a = this._eventListeners
            .get(eventName)) === null || _a === void 0 ? void 0 : _a.push({ callback: listener, eventListenerWrapper: eventListenerWrapper });
        return this;
    }
    /**
     * Adds a **one-time** `listener` function for the event named `eventName`. The
     * next time `eventName` is triggered, this listener is removed and then invoked.
     *
     * ```js
     * server.once('connection', (stream) => {
     *   console.log('Ah, we have our first user!');
     * });
     * ```
     *
     * Returns a reference to the `EventEmitter`, so that calls can be chained.
     * @param eventName - The name of the event.
     * @param listener - The callback function
     */
    once(eventName, listener) {
        var _a;
        // Pass options so this event callback is only called once
        const eventListenerOpts = { once: true };
        // Wrap our normal JS function in a event listener interface
        // so we can use it with event target and remove it from event target when this function completes.
        const eventListenerWrapper = new PixelStreamingEventListener((...args) => {
            listener(args);
            this.removeListenerInternal(eventName, listener);
        });
        super.addEventListener(eventName, eventListenerWrapper, eventListenerOpts);
        // Store the event listener/function pair for later removal.
        if (!this._eventListeners.has(eventName)) {
            this._eventListeners.set(eventName, new Array());
        }
        (_a = this._eventListeners
            .get(eventName)) === null || _a === void 0 ? void 0 : _a.push({ callback: listener, eventListenerWrapper: eventListenerWrapper });
        return this;
    }
    /**
     * Removes the specified `listener` from this EventEmitter.
     *
     * ```js
     * const callback = (stream) => {
     *   console.log('someone connected!');
     * };
     * server.on('connection', callback);
     * // ...
     * server.removeListener('connection', callback);
     * ```
     * Returns a reference to the `EventEmitter`, so that calls can be chained.
     */
    removeListener(eventName, listener) {
        this.removeListenerInternal(eventName, listener);
        return this;
    }
    /**
     * Alias for `emitter.removeListener()`.
     */
    off(eventName, listener) {
        return this.removeListener(eventName, listener);
    }
    /**
     * Removes all listeners, or those of the specified `eventName`.
     * Returns a reference to the `EventEmitter`, so that calls can be chained.
     */
    removeAllListeners(eventName) {
        if (this._eventListeners.has(eventName)) {
            const listeners = this._eventListeners.get(eventName);
            if (listeners === undefined) {
                return this;
            }
            // Remove each event listener from the event target
            for (const listenerPair of listeners) {
                this.removeEventListener(eventName, listenerPair.eventListenerWrapper);
            }
            // Remove all event listeners mapped to this event from our internal map
            this._eventListeners.delete(eventName);
        }
        return this;
    }
    /**
     * Synchronously calls each of the listeners registered for the event named `eventName`, in the order they were registered, passing the supplied arguments
     * to each.
     *
     * Returns `true` if the event had listeners, `false` otherwise.
     *
     * ```js
     * import { EventEmitter } from 'node:events';
     * const myEmitter = new EventEmitter();
     *
     * // First listener
     * myEmitter.on('event', function firstListener() {
     *   console.log('Helloooo! first listener');
     * });
     * // Second listener
     * myEmitter.on('event', function secondListener(arg1, arg2) {
     *   console.log(`event with parameters ${arg1}, ${arg2} in second listener`);
     * });
     * // Third listener
     * myEmitter.on('event', function thirdListener(...args) {
     *   const parameters = args.join(', ');
     *   console.log(`event with parameters ${parameters} in third listener`);
     * });
     *
     * console.log(myEmitter.listeners('event'));
     *
     * myEmitter.emit('event', 1, 2, 3, 4, 5);
     *
     * // Prints:
     * // [
     * //   [Function: firstListener],
     * //   [Function: secondListener],
     * //   [Function: thirdListener]
     * // ]
     * // Helloooo! first listener
     * // event with parameters 1, 2 in second listener
     * // event with parameters 1, 2, 3, 4, 5 in third listener
     * ```
     */
    emit(eventName, ...args) {
        if (this._eventListeners.has(eventName)) {
            const listeners = this._eventListeners.get(eventName);
            if (listeners === undefined) {
                return false;
            }
            // Ensure each of our listeners have the args the callback injected
            for (const listenerPair of listeners) {
                listenerPair.eventListenerWrapper.setArgs(...args);
            }
            // Fire off the actual event
            super.dispatchEvent(new Event(eventName));
            return true;
        }
        return false;
    }
}
//# sourceMappingURL=EventEmitter.js.map

/***/ }),

/***/ 7800:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LogLevel": () => (/* binding */ LogLevel),
/* harmony export */   "Logger": () => (/* binding */ Logger),
/* harmony export */   "LoggerContext": () => (/* binding */ LoggerContext),
/* harmony export */   "LoggerType": () => (/* binding */ LoggerType),
/* harmony export */   "overrideLogger": () => (/* binding */ overrideLogger)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
var LogLevel;
(function (LogLevel) {
    LogLevel[LogLevel["Disabled"] = 0] = "Disabled";
    LogLevel[LogLevel["Error"] = 1] = "Error";
    LogLevel[LogLevel["Warning"] = 2] = "Warning";
    LogLevel[LogLevel["Info"] = 3] = "Info";
    LogLevel[LogLevel["Debug"] = 4] = "Debug";
})(LogLevel || (LogLevel = {}));
/**
 * The global context for the logger configuration.
 * This cannot be stored statically in the Logger class because we sometimes have multiple execution
 * contexts, such as stats reporting. Instead we store the logger config context on the window object
 * to be shared with any Logger instances.
 */
class LoggerContext {
    constructor() {
        this.logLevel = LogLevel.Debug;
        this.includeStack = true;
    }
}
function overrideLogger(logger) {
    Logger = logger;
}
/**
 * A basic console logger utilized by the Pixel Streaming frontend to allow
 * logging to the browser console.
 */
class LoggerType {
    /**
     * Set the log verbosity level
     */
    InitLogging(logLevel, includeStack) {
        this.ValidateContext();
        this.context.logLevel = logLevel;
        this.context.includeStack = includeStack;
    }
    /**
     * Logging output for debugging
     * @param message - the message to be logged
     */
    Debug(message) {
        this.ValidateContext();
        if (this.context.logLevel >= LogLevel.Debug) {
            this.CommonLog('Debug', message);
        }
    }
    /**
     * Basic logging output for standard messages
     * @param message - the message to be logged
     */
    Info(message) {
        this.ValidateContext();
        if (this.context.logLevel >= LogLevel.Info) {
            this.CommonLog('Info', message);
        }
    }
    /**
     * Logging for warnings
     * @param message - the message to be logged
     */
    Warning(message) {
        this.ValidateContext();
        if (this.context.logLevel >= LogLevel.Warning) {
            this.CommonLog('Warning', message);
        }
    }
    /**
     * Error logging
     * @param message - the message to be logged
     */
    Error(message) {
        this.ValidateContext();
        if (this.context.logLevel >= LogLevel.Error) {
            this.CommonLog('Error', message);
        }
    }
    /**
     * The common log function that all other log functions call to.
     * @param level - the level of this log message.
     * @param stack - an optional stack trace string from where the log message was called.
     * @param message - the message to be logged.
     */
    CommonLog(level, message) {
        let logMessage = `[${level}] - ${message}`;
        if (this.context.includeStack) {
            logMessage += `\nStack: ${this.GetStackTrace()}`;
        }
        if (level === 'Error') {
            console.error(logMessage);
        }
        else if (level === 'Warning') {
            console.warn(logMessage);
        }
        else {
            console.log(logMessage);
        }
    }
    /**
     * Captures the stack and returns it
     * @returns the current stack
     */
    GetStackTrace() {
        const error = new Error();
        let formattedStack = 'No Stack Available for this browser';
        // format the error
        if (error.stack) {
            formattedStack = error.stack.toString().replace(/Error/g, '');
        }
        return formattedStack;
    }
    /**
     * Since there can be multiple execution contexts, (stats reporting and some webxr logging comes from
     * different execution contexts we can end up with multiple static Logger instances. Here we try to
     * work around it by storing the context on the window object.
     */
    ValidateContext() {
        if (!this.context) {
            if (typeof window == 'undefined' || !window) {
                // no window object so we can only store a local context.
                this.context = new LoggerContext();
            }
            else if (!window.loggerContext) {
                this.context = new LoggerContext();
                window.loggerContext = this.context;
            }
            else {
                this.context = window.loggerContext;
            }
        }
    }
}
let Logger = new LoggerType();
//# sourceMappingURL=Logger.js.map

/***/ }),

/***/ 3665:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createMessage": () => (/* binding */ createMessage),
/* harmony export */   "validateMessage": () => (/* binding */ validateMessage)
/* harmony export */ });
/* harmony import */ var _Logger_Logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7800);
/* harmony import */ var _message_registry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2366);


/**
 * A helper for creating signalling messages. Takes in optional given parameters and
 * includes them in a message object with the 'type' field set properly for the message
 * type supplied.
 * @param messageType - A message type from MessageRegistry that indicates the type of message to create.
 * @param params - An optional object whose fields are added to the newly created message.
 * @returns The resulting message object.
 */
function createMessage(messageType, params) {
    const message = messageType.create();
    message.type = messageType.typeName;
    if (params) {
        messageType.mergePartial(message, params);
    }
    return message;
}
/**
 * Tests that the supplied message is valid. That is contains all expected fields and
 * doesn't contain any unknown fields.
 * @param msg - The message object to test.
 * @returns The message type from MessageRegistry of the supplied message object if it's valid, or null if invalid.
 */
function validateMessage(msg) {
    let valid = true;
    if (!msg.type) {
        _Logger_Logger__WEBPACK_IMPORTED_MODULE_0__.Logger.Error(`Parsed message has no type. Rejected. ${JSON.stringify(msg)}`);
        return null;
    }
    const messageType = _message_registry__WEBPACK_IMPORTED_MODULE_1__.MessageRegistry[msg.type];
    if (!messageType) {
        _Logger_Logger__WEBPACK_IMPORTED_MODULE_0__.Logger.Error(`Message is of an unknown type: "${msg.type}". Rejected.`);
        return null;
    }
    if (messageType.fields) {
        for (const field of messageType.fields) {
            if (!field.opt) {
                if (!Object.prototype.hasOwnProperty.call(msg, field.name)) {
                    _Logger_Logger__WEBPACK_IMPORTED_MODULE_0__.Logger.Error(`Message "${msg.type}"" is missing required field "${field.name}". Rejected.`);
                    valid = false;
                }
            }
        }
    }
    for (const fieldName in msg) {
        const found = messageType.fields.find((field) => field.name === fieldName);
        if (!found) {
            _Logger_Logger__WEBPACK_IMPORTED_MODULE_0__.Logger.Error(`Message "${msg.type}" contains unknown field "${fieldName}". Rejected.`);
            valid = false;
        }
    }
    return valid ? messageType : null;
}
//# sourceMappingURL=message_helpers.js.map

/***/ }),

/***/ 2366:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MessageRegistry": () => (/* binding */ MessageRegistry)
/* harmony export */ });
/* harmony import */ var _signalling_messages__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7610);

/**
 * A map of all the supported signalling messages in the Pixel Streaming
 * signalling protocol. This allows mapping of signalling message names
 * to actual message types.
 */
const MessageRegistry = {
    answer: _signalling_messages__WEBPACK_IMPORTED_MODULE_0__.answer,
    config: _signalling_messages__WEBPACK_IMPORTED_MODULE_0__.config,
    disconnectPlayer: _signalling_messages__WEBPACK_IMPORTED_MODULE_0__.disconnectPlayer,
    endpointId: _signalling_messages__WEBPACK_IMPORTED_MODULE_0__.endpointId,
    endpointIdConfirm: _signalling_messages__WEBPACK_IMPORTED_MODULE_0__.endpointIdConfirm,
    iceCandidate: _signalling_messages__WEBPACK_IMPORTED_MODULE_0__.iceCandidate,
    identify: _signalling_messages__WEBPACK_IMPORTED_MODULE_0__.identify,
    listStreamers: _signalling_messages__WEBPACK_IMPORTED_MODULE_0__.listStreamers,
    offer: _signalling_messages__WEBPACK_IMPORTED_MODULE_0__.offer,
    ping: _signalling_messages__WEBPACK_IMPORTED_MODULE_0__.ping,
    playerConnected: _signalling_messages__WEBPACK_IMPORTED_MODULE_0__.playerConnected,
    playerCount: _signalling_messages__WEBPACK_IMPORTED_MODULE_0__.playerCount,
    playerDisconnected: _signalling_messages__WEBPACK_IMPORTED_MODULE_0__.playerDisconnected,
    pong: _signalling_messages__WEBPACK_IMPORTED_MODULE_0__.pong,
    stats: _signalling_messages__WEBPACK_IMPORTED_MODULE_0__.stats,
    streamerDisconnected: _signalling_messages__WEBPACK_IMPORTED_MODULE_0__.streamerDisconnected,
    streamerList: _signalling_messages__WEBPACK_IMPORTED_MODULE_0__.streamerList,
    subscribe: _signalling_messages__WEBPACK_IMPORTED_MODULE_0__.subscribe,
    unsubscribe: _signalling_messages__WEBPACK_IMPORTED_MODULE_0__.unsubscribe,
    layerPreference: _signalling_messages__WEBPACK_IMPORTED_MODULE_0__.layerPreference,
    dataChannelRequest: _signalling_messages__WEBPACK_IMPORTED_MODULE_0__.dataChannelRequest,
    peerDataChannels: _signalling_messages__WEBPACK_IMPORTED_MODULE_0__.peerDataChannels,
    peerDataChannelsReady: _signalling_messages__WEBPACK_IMPORTED_MODULE_0__.peerDataChannelsReady,
    streamerDataChannels: _signalling_messages__WEBPACK_IMPORTED_MODULE_0__.streamerDataChannels,
    startStreaming: _signalling_messages__WEBPACK_IMPORTED_MODULE_0__.startStreaming,
    stopStreaming: _signalling_messages__WEBPACK_IMPORTED_MODULE_0__.stopStreaming
};
//# sourceMappingURL=message_registry.js.map

/***/ }),

/***/ 7610:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "answer": () => (/* binding */ answer),
/* harmony export */   "base_message": () => (/* binding */ base_message),
/* harmony export */   "config": () => (/* binding */ config),
/* harmony export */   "dataChannelRequest": () => (/* binding */ dataChannelRequest),
/* harmony export */   "disconnectPlayer": () => (/* binding */ disconnectPlayer),
/* harmony export */   "endpointId": () => (/* binding */ endpointId),
/* harmony export */   "endpointIdConfirm": () => (/* binding */ endpointIdConfirm),
/* harmony export */   "iceCandidate": () => (/* binding */ iceCandidate),
/* harmony export */   "iceCandidateData": () => (/* binding */ iceCandidateData),
/* harmony export */   "identify": () => (/* binding */ identify),
/* harmony export */   "layerPreference": () => (/* binding */ layerPreference),
/* harmony export */   "listStreamers": () => (/* binding */ listStreamers),
/* harmony export */   "offer": () => (/* binding */ offer),
/* harmony export */   "peerConnectionOptions": () => (/* binding */ peerConnectionOptions),
/* harmony export */   "peerDataChannels": () => (/* binding */ peerDataChannels),
/* harmony export */   "peerDataChannelsReady": () => (/* binding */ peerDataChannelsReady),
/* harmony export */   "ping": () => (/* binding */ ping),
/* harmony export */   "playerConnected": () => (/* binding */ playerConnected),
/* harmony export */   "playerCount": () => (/* binding */ playerCount),
/* harmony export */   "playerDisconnected": () => (/* binding */ playerDisconnected),
/* harmony export */   "pong": () => (/* binding */ pong),
/* harmony export */   "startStreaming": () => (/* binding */ startStreaming),
/* harmony export */   "stats": () => (/* binding */ stats),
/* harmony export */   "stopStreaming": () => (/* binding */ stopStreaming),
/* harmony export */   "streamerDataChannels": () => (/* binding */ streamerDataChannels),
/* harmony export */   "streamerDisconnected": () => (/* binding */ streamerDisconnected),
/* harmony export */   "streamerIdChanged": () => (/* binding */ streamerIdChanged),
/* harmony export */   "streamerList": () => (/* binding */ streamerList),
/* harmony export */   "subscribe": () => (/* binding */ subscribe),
/* harmony export */   "subscribeFailed": () => (/* binding */ subscribeFailed),
/* harmony export */   "unsubscribe": () => (/* binding */ unsubscribe)
/* harmony export */ });
/* harmony import */ var _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(299);
/* harmony import */ var _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4548);
/* harmony import */ var _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(827);




// @generated message type with reflection information, may provide speed optimized methods
class base_message$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("base_message", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base_message
 */
const base_message = new base_message$Type();
// @generated message type with reflection information, may provide speed optimized methods
class peerConnectionOptions$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("peerConnectionOptions", []);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message peerConnectionOptions
 */
const peerConnectionOptions = new peerConnectionOptions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class config$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("config", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "peerConnectionOptions", kind: "message", T: () => peerConnectionOptions },
            { no: 3, name: "protocolVersion", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* peerConnectionOptions peerConnectionOptions */ 2:
                    message.peerConnectionOptions = peerConnectionOptions.internalBinaryRead(reader, reader.uint32(), options, message.peerConnectionOptions);
                    break;
                case /* optional string protocolVersion */ 3:
                    message.protocolVersion = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        /* peerConnectionOptions peerConnectionOptions = 2; */
        if (message.peerConnectionOptions)
            peerConnectionOptions.internalBinaryWrite(message.peerConnectionOptions, writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).fork(), options).join();
        /* optional string protocolVersion = 3; */
        if (message.protocolVersion !== undefined)
            writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.protocolVersion);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message config
 */
const config = new config$Type();
// @generated message type with reflection information, may provide speed optimized methods
class identify$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("identify", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message identify
 */
const identify = new identify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class endpointId$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("endpointId", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "protocolVersion", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        message.id = "";
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* string id */ 2:
                    message.id = reader.string();
                    break;
                case /* optional string protocolVersion */ 3:
                    message.protocolVersion = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        /* string id = 2; */
        if (message.id !== "")
            writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.id);
        /* optional string protocolVersion = 3; */
        if (message.protocolVersion !== undefined)
            writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.protocolVersion);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message endpointId
 */
const endpointId = new endpointId$Type();
// @generated message type with reflection information, may provide speed optimized methods
class endpointIdConfirm$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("endpointIdConfirm", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "committedId", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        message.committedId = "";
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* string committedId */ 2:
                    message.committedId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        /* string committedId = 2; */
        if (message.committedId !== "")
            writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.committedId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message endpointIdConfirm
 */
const endpointIdConfirm = new endpointIdConfirm$Type();
// @generated message type with reflection information, may provide speed optimized methods
class streamerIdChanged$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("streamerIdChanged", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "newID", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        message.newID = "";
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* string newID */ 2:
                    message.newID = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        /* string newID = 2; */
        if (message.newID !== "")
            writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.newID);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message streamerIdChanged
 */
const streamerIdChanged = new streamerIdChanged$Type();
// @generated message type with reflection information, may provide speed optimized methods
class listStreamers$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("listStreamers", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message listStreamers
 */
const listStreamers = new listStreamers$Type();
// @generated message type with reflection information, may provide speed optimized methods
class streamerList$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("streamerList", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        message.ids = [];
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* repeated string ids */ 2:
                    message.ids.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        /* repeated string ids = 2; */
        for (let i = 0; i < message.ids.length; i++)
            writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.ids[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message streamerList
 */
const streamerList = new streamerList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class subscribe$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("subscribe", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "streamerId", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        message.streamerId = "";
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* string streamerId */ 2:
                    message.streamerId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        /* string streamerId = 2; */
        if (message.streamerId !== "")
            writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.streamerId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message subscribe
 */
const subscribe = new subscribe$Type();
// @generated message type with reflection information, may provide speed optimized methods
class unsubscribe$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("unsubscribe", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message unsubscribe
 */
const unsubscribe = new unsubscribe$Type();
// @generated message type with reflection information, may provide speed optimized methods
class subscribeFailed$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("subscribeFailed", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        message.message = "";
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* string message */ 2:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        /* string message = 2; */
        if (message.message !== "")
            writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message subscribeFailed
 */
const subscribeFailed = new subscribeFailed$Type();
// @generated message type with reflection information, may provide speed optimized methods
class playerConnected$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("playerConnected", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "dataChannel", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "sfu", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "playerId", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        message.dataChannel = false;
        message.sfu = false;
        message.playerId = "";
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* bool dataChannel */ 2:
                    message.dataChannel = reader.bool();
                    break;
                case /* bool sfu */ 3:
                    message.sfu = reader.bool();
                    break;
                case /* string playerId */ 5:
                    message.playerId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        /* bool dataChannel = 2; */
        if (message.dataChannel !== false)
            writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.Varint).bool(message.dataChannel);
        /* bool sfu = 3; */
        if (message.sfu !== false)
            writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.Varint).bool(message.sfu);
        /* string playerId = 5; */
        if (message.playerId !== "")
            writer.tag(5, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.playerId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message playerConnected
 */
const playerConnected = new playerConnected$Type();
// @generated message type with reflection information, may provide speed optimized methods
class playerDisconnected$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("playerDisconnected", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "playerId", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        message.playerId = "";
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* string playerId */ 2:
                    message.playerId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        /* string playerId = 2; */
        if (message.playerId !== "")
            writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.playerId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message playerDisconnected
 */
const playerDisconnected = new playerDisconnected$Type();
// @generated message type with reflection information, may provide speed optimized methods
class offer$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("offer", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "sdp", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "playerId", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "sfu", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "multiplex", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "scalabilityMode", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        message.sdp = "";
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* string sdp */ 2:
                    message.sdp = reader.string();
                    break;
                case /* optional string playerId */ 3:
                    message.playerId = reader.string();
                    break;
                case /* optional bool sfu */ 4:
                    message.sfu = reader.bool();
                    break;
                case /* optional bool multiplex */ 5:
                    message.multiplex = reader.bool();
                    break;
                case /* optional string scalabilityMode */ 6:
                    message.scalabilityMode = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        /* string sdp = 2; */
        if (message.sdp !== "")
            writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.sdp);
        /* optional string playerId = 3; */
        if (message.playerId !== undefined)
            writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.playerId);
        /* optional bool sfu = 4; */
        if (message.sfu !== undefined)
            writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.Varint).bool(message.sfu);
        /* optional bool multiplex = 5; */
        if (message.multiplex !== undefined)
            writer.tag(5, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.Varint).bool(message.multiplex);
        /* optional string scalabilityMode = 6; */
        if (message.scalabilityMode !== undefined)
            writer.tag(6, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.scalabilityMode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message offer
 */
const offer = new offer$Type();
// @generated message type with reflection information, may provide speed optimized methods
class answer$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("answer", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "sdp", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "playerId", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "minBitrateBps", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "maxBitrateBps", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        message.sdp = "";
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* string sdp */ 2:
                    message.sdp = reader.string();
                    break;
                case /* optional string playerId */ 3:
                    message.playerId = reader.string();
                    break;
                case /* optional int32 minBitrateBps */ 4:
                    message.minBitrateBps = reader.int32();
                    break;
                case /* optional int32 maxBitrateBps */ 5:
                    message.maxBitrateBps = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        /* string sdp = 2; */
        if (message.sdp !== "")
            writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.sdp);
        /* optional string playerId = 3; */
        if (message.playerId !== undefined)
            writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.playerId);
        /* optional int32 minBitrateBps = 4; */
        if (message.minBitrateBps !== undefined)
            writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.Varint).int32(message.minBitrateBps);
        /* optional int32 maxBitrateBps = 5; */
        if (message.maxBitrateBps !== undefined)
            writer.tag(5, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.Varint).int32(message.maxBitrateBps);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message answer
 */
const answer = new answer$Type();
// @generated message type with reflection information, may provide speed optimized methods
class iceCandidateData$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("iceCandidateData", [
            { no: 1, name: "candidate", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "sdpMid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "sdpMLineIndex", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "usernameFragment", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.candidate = "";
        message.sdpMid = "";
        message.sdpMLineIndex = 0;
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string candidate */ 1:
                    message.candidate = reader.string();
                    break;
                case /* string sdpMid */ 2:
                    message.sdpMid = reader.string();
                    break;
                case /* int32 sdpMLineIndex */ 3:
                    message.sdpMLineIndex = reader.int32();
                    break;
                case /* optional string usernameFragment */ 4:
                    message.usernameFragment = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string candidate = 1; */
        if (message.candidate !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.candidate);
        /* string sdpMid = 2; */
        if (message.sdpMid !== "")
            writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.sdpMid);
        /* int32 sdpMLineIndex = 3; */
        if (message.sdpMLineIndex !== 0)
            writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.Varint).int32(message.sdpMLineIndex);
        /* optional string usernameFragment = 4; */
        if (message.usernameFragment !== undefined)
            writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.usernameFragment);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message iceCandidateData
 */
const iceCandidateData = new iceCandidateData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class iceCandidate$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("iceCandidate", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "candidate", kind: "message", T: () => iceCandidateData },
            { no: 3, name: "playerId", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* iceCandidateData candidate */ 2:
                    message.candidate = iceCandidateData.internalBinaryRead(reader, reader.uint32(), options, message.candidate);
                    break;
                case /* optional string playerId */ 3:
                    message.playerId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        /* iceCandidateData candidate = 2; */
        if (message.candidate)
            iceCandidateData.internalBinaryWrite(message.candidate, writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).fork(), options).join();
        /* optional string playerId = 3; */
        if (message.playerId !== undefined)
            writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.playerId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message iceCandidate
 */
const iceCandidate = new iceCandidate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class disconnectPlayer$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("disconnectPlayer", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "playerId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "reason", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        message.playerId = "";
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* string playerId */ 2:
                    message.playerId = reader.string();
                    break;
                case /* optional string reason */ 3:
                    message.reason = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        /* string playerId = 2; */
        if (message.playerId !== "")
            writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.playerId);
        /* optional string reason = 3; */
        if (message.reason !== undefined)
            writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.reason);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message disconnectPlayer
 */
const disconnectPlayer = new disconnectPlayer$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ping$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("ping", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "time", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        message.time = 0;
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* int32 time */ 2:
                    message.time = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        /* int32 time = 2; */
        if (message.time !== 0)
            writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.Varint).int32(message.time);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ping
 */
const ping = new ping$Type();
// @generated message type with reflection information, may provide speed optimized methods
class pong$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("pong", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "time", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        message.time = 0;
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* int32 time */ 2:
                    message.time = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        /* int32 time = 2; */
        if (message.time !== 0)
            writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.Varint).int32(message.time);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pong
 */
const pong = new pong$Type();
// @generated message type with reflection information, may provide speed optimized methods
class streamerDisconnected$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("streamerDisconnected", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message streamerDisconnected
 */
const streamerDisconnected = new streamerDisconnected$Type();
// @generated message type with reflection information, may provide speed optimized methods
class layerPreference$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("layerPreference", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "spatialLayer", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "temporalLayer", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "playerId", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        message.spatialLayer = 0;
        message.temporalLayer = 0;
        message.playerId = "";
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* int32 spatialLayer */ 2:
                    message.spatialLayer = reader.int32();
                    break;
                case /* int32 temporalLayer */ 3:
                    message.temporalLayer = reader.int32();
                    break;
                case /* string playerId */ 4:
                    message.playerId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        /* int32 spatialLayer = 2; */
        if (message.spatialLayer !== 0)
            writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.Varint).int32(message.spatialLayer);
        /* int32 temporalLayer = 3; */
        if (message.temporalLayer !== 0)
            writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.Varint).int32(message.temporalLayer);
        /* string playerId = 4; */
        if (message.playerId !== "")
            writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.playerId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message layerPreference
 */
const layerPreference = new layerPreference$Type();
// @generated message type with reflection information, may provide speed optimized methods
class dataChannelRequest$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("dataChannelRequest", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message dataChannelRequest
 */
const dataChannelRequest = new dataChannelRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class peerDataChannels$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("peerDataChannels", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "playerId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "sendStreamId", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "recvStreamId", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        message.playerId = "";
        message.sendStreamId = 0;
        message.recvStreamId = 0;
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* string playerId */ 2:
                    message.playerId = reader.string();
                    break;
                case /* int32 sendStreamId */ 3:
                    message.sendStreamId = reader.int32();
                    break;
                case /* int32 recvStreamId */ 4:
                    message.recvStreamId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        /* string playerId = 2; */
        if (message.playerId !== "")
            writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.playerId);
        /* int32 sendStreamId = 3; */
        if (message.sendStreamId !== 0)
            writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.Varint).int32(message.sendStreamId);
        /* int32 recvStreamId = 4; */
        if (message.recvStreamId !== 0)
            writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.Varint).int32(message.recvStreamId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message peerDataChannels
 */
const peerDataChannels = new peerDataChannels$Type();
// @generated message type with reflection information, may provide speed optimized methods
class peerDataChannelsReady$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("peerDataChannelsReady", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message peerDataChannelsReady
 */
const peerDataChannelsReady = new peerDataChannelsReady$Type();
// @generated message type with reflection information, may provide speed optimized methods
class streamerDataChannels$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("streamerDataChannels", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "sfuId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "sendStreamId", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "recvStreamId", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        message.sfuId = "";
        message.sendStreamId = 0;
        message.recvStreamId = 0;
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* string sfuId */ 2:
                    message.sfuId = reader.string();
                    break;
                case /* int32 sendStreamId */ 3:
                    message.sendStreamId = reader.int32();
                    break;
                case /* int32 recvStreamId */ 4:
                    message.recvStreamId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        /* string sfuId = 2; */
        if (message.sfuId !== "")
            writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.sfuId);
        /* int32 sendStreamId = 3; */
        if (message.sendStreamId !== 0)
            writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.Varint).int32(message.sendStreamId);
        /* int32 recvStreamId = 4; */
        if (message.recvStreamId !== 0)
            writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.Varint).int32(message.recvStreamId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message streamerDataChannels
 */
const streamerDataChannels = new streamerDataChannels$Type();
// @generated message type with reflection information, may provide speed optimized methods
class startStreaming$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("startStreaming", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message startStreaming
 */
const startStreaming = new startStreaming$Type();
// @generated message type with reflection information, may provide speed optimized methods
class stopStreaming$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("stopStreaming", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stopStreaming
 */
const stopStreaming = new stopStreaming$Type();
// @generated message type with reflection information, may provide speed optimized methods
class playerCount$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("playerCount", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "count", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        message.count = 0;
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* int32 count */ 2:
                    message.count = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        /* int32 count = 2; */
        if (message.count !== 0)
            writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.Varint).int32(message.count);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message playerCount
 */
const playerCount = new playerCount$Type();
// @generated message type with reflection information, may provide speed optimized methods
class stats$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_0__.MessageType {
    constructor() {
        super("stats", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "data", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        message.data = "";
        if (value !== undefined)
            (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_1__.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* string data */ 2:
                    message.data = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.type);
        /* string data = 2; */
        if (message.data !== "")
            writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).string(message.data);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stats
 */
const stats = new stats$Type();
//# sourceMappingURL=signalling_messages.js.map

/***/ }),

/***/ 6292:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "KeepaliveMonitor": () => (/* binding */ KeepaliveMonitor)
/* harmony export */ });
/* harmony import */ var _Messages_signalling_messages__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7610);
/* harmony import */ var _Messages_message_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3665);
// Copyright Epic Games, Inc. All Rights Reserved.


/**
 * Used to regularly ping a protocol connection to make sure the connection is still good and open.
 * When the pong doesn't come in response to a ping in time a callback is fired that can be handed
 * by the owner.
 */
class KeepaliveMonitor {
    /**
     * Gets the Round Trip Time of the current connection in milliseconds.
     */
    get RTT() {
        return this.rtt;
    }
    /**
     * Creates a new monitor and starts the ping timer. If a pong does not come back by the time we want
     * to send a second ping then the connection is considered dead and the onTimeout callback is fired.
     * @param protocol - The connection that we want to monitor.
     * @param timeout - The time in milliseconds between ping messages.
     */
    constructor(protocol, timeout) {
        this.alive = false;
        this.rtt = 0;
        this.protocol = protocol;
        this.timeout = timeout;
        this.onResponse = this.onHeartbeatResponse.bind(this);
        this.protocol.transport.on('close', this.stop.bind(this));
        this.start();
    }
    start() {
        this.alive = true;
        this.protocol.on('pong', this.onResponse);
        this.keepalive = setInterval(this.sendHeartbeat.bind(this), this.timeout);
    }
    stop() {
        clearInterval(this.keepalive);
        this.protocol.off('pong', this.onResponse);
    }
    sendHeartbeat() {
        var _a;
        // if we never got a response from the last heartbeat, assume the connection is dead and timeout
        if (this.alive === false) {
            (_a = this.onTimeout) === null || _a === void 0 ? void 0 : _a.call(this);
            return;
        }
        // mark the connection as temporarily dead until we get a response from the ping
        this.alive = false;
        this.protocol.sendMessage(_Messages_message_helpers__WEBPACK_IMPORTED_MODULE_0__.createMessage(_Messages_signalling_messages__WEBPACK_IMPORTED_MODULE_1__.ping, { time: new Date().getTime() }));
    }
    onHeartbeatResponse(pongMsg) {
        // we got a pong response from the other side, the connection is good.
        // we also store the round trip time if anyone is curious
        this.rtt = new Date().getTime() - pongMsg.time;
        this.alive = true;
    }
}
//# sourceMappingURL=KeepaliveMonitor.js.map

/***/ }),

/***/ 9761:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SignallingProtocol": () => (/* binding */ SignallingProtocol)
/* harmony export */ });
/* harmony import */ var _Event_EventEmitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7099);
/* harmony import */ var _Logger_Logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7800);
// Copyright Epic Games, Inc. All Rights Reserved.


/**
 * Signalling protocol for handling messages from the signalling server.
 *
 * Listen on this emitter for messages. Message type is the name of the event to listen for.
 * Example:
 *      signallingProtocol.on('config', (message: Messages.config) =\> console.log(`Got a config message: ${message}`)));
 *
 * The transport in this class will also emit on message events.
 *
 * Events emitted on transport:
 *   message:
 *      Emitted any time a message is received by the transport. Listen on this if
 *      you wish to capture all messages, rather than specific messages on
 *      'messageHandlers'.
 *
 *   out:
 *      Emitted when sending a message out on the transport. Similar to 'message' but
 *      only for when messages are sent from this endpoint. Useful for debugging.
 */
class SignallingProtocol extends _Event_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {
    static get SIGNALLING_VERSION() {
        return '1.3.0';
    }
    constructor(transport) {
        super();
        this.transport = transport;
        transport.onMessage = (msg) => {
            let parsedMessage;
            try {
                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                const parsedData = JSON.parse(msg);
                _Logger_Logger__WEBPACK_IMPORTED_MODULE_1__.Logger.Debug('Protocol received => \n' + JSON.stringify(parsedData, undefined, 4));
                parsedMessage = parsedData;
            }
            catch (e) {
                if (e instanceof Error) {
                    _Logger_Logger__WEBPACK_IMPORTED_MODULE_1__.Logger.Error(`Error parsing message string ${msg}.\n${e.message}`);
                }
                else {
                    _Logger_Logger__WEBPACK_IMPORTED_MODULE_1__.Logger.Error(`Unknown error while parsing message data in handleOnMessage`);
                }
                return;
            }
            // call the handlers
            transport.emit('message', parsedMessage); // emit this for listeners listening to any message
            if (!this.emit(parsedMessage.type, parsedMessage)) {
                // emit this for listeners listening for specific messages
                // no listeners
                this.emit('unhandled', parsedMessage);
            }
        };
    }
    /**
     * Asks the transport to connect to the given URL.
     * @param url - The url to connect to.
     * @returns True if the connection call succeeded.
     */
    connect(url) {
        return this.transport.connect(url);
    }
    /**
     * Asks the transport to disconnect from any connection it might have.
     * @param code - An optional disconnection code.
     * @param reason - An optional descriptive string for the disconnect reason.
     */
    disconnect(code, reason) {
        this.transport.disconnect(code, reason);
    }
    /**
     * Returns true if the transport is connected and ready to send/receive messages.
     * @returns True if the protocol is connected.
     */
    isConnected() {
        return this.transport.isConnected();
    }
    /**
     * Passes a message to the transport to send to the other end.
     * @param msg - The message to send.
     */
    sendMessage(msg) {
        this.transport.sendMessage(JSON.stringify(msg));
        this.transport.emit('out', msg); // emit this for listeners listening to outgoing messages
        _Logger_Logger__WEBPACK_IMPORTED_MODULE_1__.Logger.Debug('Protocol sent => \n' + JSON.stringify(msg, undefined, 4));
    }
}
//# sourceMappingURL=SignallingProtocol.js.map

/***/ }),

/***/ 3457:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "WebSocketTransport": () => (/* binding */ WebSocketTransport)
/* harmony export */ });
/* harmony import */ var _Logger_Logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7800);
/* harmony import */ var _Event_EventEmitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7099);
// Copyright Epic Games, Inc. All Rights Reserved.


/**
 * The controller for the WebSocket and all associated methods
 */
class WebSocketTransport extends _Event_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {
    /**
     * Constructs a new WebSocketTransport for browser contexts.
     * @param protocols - An optional string or list of strings to pass to the new websocket protocols param
     */
    constructor(protocols) {
        super();
        this.WS_OPEN_STATE = 1;
        this.protocols = protocols;
    }
    /**
     * Sends a message over the websocket.
     * @param msg - The message to send.
     */
    sendMessage(msg) {
        if (this.webSocket) {
            this.webSocket.send(msg);
        }
    }
    /**
     * Connect to the signaling server
     * @param connectionURL - The Address of the signaling server
     * @returns If there is a connection
     */
    connect(connectionURL) {
        _Logger_Logger__WEBPACK_IMPORTED_MODULE_1__.Logger.Info(connectionURL);
        try {
            this.webSocket = new WebSocket(connectionURL, this.protocols);
            this.webSocket.onopen = (_) => this.handleOnOpen();
            this.webSocket.onerror = (_) => this.handleOnError();
            this.webSocket.onclose = (event) => this.handleOnClose(event);
            this.webSocket.onmessage = (event) => this.handleOnMessage(event);
            this.webSocket.onmessagebinary = (event) => this.handleOnMessageBinary(event);
            return true;
        }
        catch (error) {
            _Logger_Logger__WEBPACK_IMPORTED_MODULE_1__.Logger.Error(error);
            return false;
        }
    }
    /**
     * Disconnect this transport.
     * @param code - An optional disconnect code.
     * @param reason - A descriptive string for the disconnect reason.
     */
    disconnect(code, reason) {
        if (this.webSocket) {
            this.webSocket.close(code, reason);
        }
    }
    /**
     * Should return true when the transport is connected and ready to send/receive messages.
     * @returns True if the transport is connected.
     */
    isConnected() {
        return !!this.webSocket && this.webSocket.readyState != WebSocket.CLOSED;
    }
    /**
     * Handles what happens when a message is received in binary form
     * @param event - Message Received
     */
    handleOnMessageBinary(event) {
        // if the event is empty return
        if (!event || !event.data) {
            return;
        }
        // handle the binary and then handle the message
        event.data
            .text()
            .then((messageString) => {
            // build a new message
            const constructedMessage = new MessageEvent('messageFromBinary', {
                data: messageString
            });
            // send the new stringified event back into `onmessage`
            this.handleOnMessage(constructedMessage);
        })
            .catch((error) => {
            _Logger_Logger__WEBPACK_IMPORTED_MODULE_1__.Logger.Error(`Failed to parse binary blob from websocket, reason: ${error.message}`);
        });
    }
    /**
     * Handles what happens when a message is received
     * @param event - Message Received
     */
    handleOnMessage(event) {
        // Check if websocket message is binary, if so, stringify it.
        if (event.data && event.data instanceof Blob) {
            this.handleOnMessageBinary(event);
            return;
        }
        if (this.onMessage) {
            this.onMessage(event.data);
        }
    }
    /**
     * Handles when the Websocket is opened
     */
    handleOnOpen() {
        _Logger_Logger__WEBPACK_IMPORTED_MODULE_1__.Logger.Info('Connected to the signalling server via WebSocket');
        this.emit('open');
    }
    /**
     * Handles when there is an error on the websocket
     */
    handleOnError() {
        //Logger.Error(Logger.GetStackTrace(), 'WebSocket error');
        this.emit('error');
    }
    /**
     * Handles when the Websocket is closed
     * @param event - Close Event
     */
    handleOnClose(event) {
        _Logger_Logger__WEBPACK_IMPORTED_MODULE_1__.Logger.Info('Disconnected to the signalling server via WebSocket: ' +
            JSON.stringify(event.code) +
            ' - ' +
            event.reason);
        this.emit('close', event);
    }
}
//# sourceMappingURL=WebSocketTransport.js.map

/***/ }),

/***/ 3125:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "WebSocketTransportNJS": () => (/* binding */ WebSocketTransportNJS)
/* harmony export */ });
/* harmony import */ var _Event_EventEmitter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7099);
/* harmony import */ var ws__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7026);
/* harmony import */ var ws__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(ws__WEBPACK_IMPORTED_MODULE_0__);
// Copyright Epic Games, Inc. All Rights Reserved.


/**
 * An implementation of WebSocketTransport from pixelstreamingcommon that supports node.js websockets
 * This is needed because of the slight differences between the 'ws' node.js package and the websockets
 * supported in the browsers.
 * Do not use this code in a browser use 'WebSocketTransport' instead.
 */
class WebSocketTransportNJS extends _Event_EventEmitter__WEBPACK_IMPORTED_MODULE_1__.EventEmitter {
    constructor(argument) {
        super();
        this.WS_OPEN_STATE = 1;
        if (argument instanceof (ws__WEBPACK_IMPORTED_MODULE_0___default())) {
            this.webSocket = argument;
            this.setupSocketHandlers();
            this.emit('open');
        }
        else if (argument) {
            this.protocols = argument;
        }
    }
    /**
     * Sends a message over the websocket.
     * @param msg - The message to send.
     */
    sendMessage(msg) {
        if (this.webSocket) {
            this.webSocket.send(msg);
        }
    }
    /**
     * Connect to the signaling server
     * @param connectionURL - The Address of the signaling server
     * @param protocols - An optional string or list of strings to pass to the new websocket protocols param
     * @returns If there is a connection
     */
    connect(connectionURL) {
        this.webSocket = new (ws__WEBPACK_IMPORTED_MODULE_0___default())(connectionURL, this.protocols);
        this.setupSocketHandlers();
        return true;
    }
    /**
     * Disconnect this transport.
     * @param code - An optional disconnect code.
     * @param reason - A descriptive string for the disconnect reason.
     */
    disconnect(code, reason) {
        if (this.webSocket) {
            this.webSocket.close(code, reason);
        }
    }
    /**
     * Should return true when the transport is connected and ready to send/receive messages.
     * @returns True if the transport is connected.
     */
    isConnected() {
        return !!this.webSocket && this.webSocket.readyState != (ws__WEBPACK_IMPORTED_MODULE_0___default().CLOSED);
    }
    /**
     * Handles what happens when a message is received
     * @param event - Message Received
     */
    handleOnMessage(event) {
        if (this.onMessage) {
            this.onMessage(event.data);
        }
    }
    /**
     * Handles when the Websocket is opened
     * @param event - Not Used
     */
    handleOnOpen(event) {
        this.emit('open', event);
    }
    /**
     * Handles when there is an error on the websocket
     * @param event - Error Payload
     */
    handleOnError(event) {
        this.emit('error', event);
    }
    /**
     * Handles when the Websocket is closed
     * @param event - Close Event
     */
    handleOnClose(event) {
        this.emit('close', event);
    }
    /**
     * Closes the Websocket connection
     */
    close() {
        var _a;
        (_a = this.webSocket) === null || _a === void 0 ? void 0 : _a.close();
    }
    setupSocketHandlers() {
        if (this.webSocket) {
            this.webSocket.addEventListener('open', this.handleOnOpen.bind(this));
            this.webSocket.addEventListener('error', this.handleOnError.bind(this));
            this.webSocket.addEventListener('close', this.handleOnClose.bind(this));
            this.webSocket.addEventListener('message', this.handleOnMessage.bind(this));
        }
    }
}
//# sourceMappingURL=WebSocketTransportNJS.js.map

/***/ }),

/***/ 4250:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SDPUtils": () => (/* binding */ SDPUtils)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
class SDPUtils {
    static addVideoHeaderExtensionToSdp(sdp, uri) {
        // Find the highest used header extension id by sorting the extension ids used,
        // eliminating duplicates and adding one.
        // Todo: Update this when WebRTC in Chrome supports the header extension API.
        const usedIds = sdp
            .split('\n')
            .filter((line) => line.startsWith('a=extmap:'))
            .map((line) => parseInt(line.split(' ')[0].substring(9), 10))
            .sort((a, b) => a - b)
            .filter((item, index, array) => array.indexOf(item) === index);
        const nextId = usedIds[usedIds.length - 1] + 1;
        const extmapLine = 'a=extmap:' + nextId + ' ' + uri + '\r\n';
        const sections = sdp.split('\nm=').map((part, index) => {
            return (index > 0 ? 'm=' + part : part).trim() + '\r\n';
        });
        const sessionPart = sections.shift();
        // Only add extension to m=video media section
        return (sessionPart +
            sections
                .map((mediaSection) => mediaSection.startsWith('m=video') ? mediaSection + extmapLine : mediaSection)
                .join(''));
    }
}
//# sourceMappingURL=SdpUtils.js.map

/***/ }),

/***/ 2050:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EventEmitter": () => (/* reexport safe */ _Event_EventEmitter__WEBPACK_IMPORTED_MODULE_4__.EventEmitter),
/* harmony export */   "KeepaliveMonitor": () => (/* reexport safe */ _Protocol_KeepaliveMonitor__WEBPACK_IMPORTED_MODULE_8__.KeepaliveMonitor),
/* harmony export */   "LogLevel": () => (/* reexport safe */ _Logger_Logger__WEBPACK_IMPORTED_MODULE_0__.LogLevel),
/* harmony export */   "Logger": () => (/* reexport safe */ _Logger_Logger__WEBPACK_IMPORTED_MODULE_0__.Logger),
/* harmony export */   "MessageHelpers": () => (/* reexport module object */ _Messages_message_helpers__WEBPACK_IMPORTED_MODULE_7__),
/* harmony export */   "MessageRegistry": () => (/* reexport safe */ _Messages_message_registry__WEBPACK_IMPORTED_MODULE_5__.MessageRegistry),
/* harmony export */   "Messages": () => (/* reexport module object */ _Messages_signalling_messages__WEBPACK_IMPORTED_MODULE_6__),
/* harmony export */   "SDPUtils": () => (/* reexport safe */ _Util_SdpUtils__WEBPACK_IMPORTED_MODULE_9__.SDPUtils),
/* harmony export */   "SignallingProtocol": () => (/* reexport safe */ _Protocol_SignallingProtocol__WEBPACK_IMPORTED_MODULE_3__.SignallingProtocol),
/* harmony export */   "WebSocketTransport": () => (/* reexport safe */ _Transport_WebSocketTransport__WEBPACK_IMPORTED_MODULE_1__.WebSocketTransport),
/* harmony export */   "WebSocketTransportNJS": () => (/* reexport safe */ _Transport_WebSocketTransportNJS__WEBPACK_IMPORTED_MODULE_2__.WebSocketTransportNJS),
/* harmony export */   "overrideLogger": () => (/* reexport safe */ _Logger_Logger__WEBPACK_IMPORTED_MODULE_0__.overrideLogger)
/* harmony export */ });
/* harmony import */ var _Logger_Logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7800);
/* harmony import */ var _Transport_WebSocketTransport__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3457);
/* harmony import */ var _Transport_WebSocketTransportNJS__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3125);
/* harmony import */ var _Protocol_SignallingProtocol__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(9761);
/* harmony import */ var _Event_EventEmitter__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(7099);
/* harmony import */ var _Messages_message_registry__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(2366);
/* harmony import */ var _Messages_signalling_messages__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(7610);
/* harmony import */ var _Messages_message_helpers__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(3665);
/* harmony import */ var _Protocol_KeepaliveMonitor__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(6292);
/* harmony import */ var _Util_SdpUtils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(4250);
// Copyright Epic Games, Inc. All Rights Reserved.












//# sourceMappingURL=pixelstreamingcommon.js.map

/***/ }),

/***/ 295:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AFKController": () => (/* binding */ AFKController)
/* harmony export */ });
/* harmony import */ var _Config_Config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7463);
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7800);
/* harmony import */ var _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5391);
// Copyright Epic Games, Inc. All Rights Reserved.



class AFKController {
    constructor(config, pixelStreaming, onDismissAfk) {
        // time out logic details
        this.active = false;
        this.countdownActive = false;
        this.warnTimer = undefined;
        this.countDown = 0;
        this.countDownTimer = undefined;
        this.config = config;
        this.pixelStreaming = pixelStreaming;
        this.onDismissAfk = onDismissAfk;
        this.onAFKTimedOutCallback = () => {
            console.log('AFK timed out, did you want to override this callback?');
        };
    }
    /**
     * The methods that occur when an afk event listener is clicked
     */
    onAfkClick() {
        clearInterval(this.countDownTimer);
        if (this.active || this.countdownActive) {
            this.startAfkWarningTimer();
            this.pixelStreaming.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.AfkWarningDeactivateEvent());
        }
    }
    /**
     * Start the warning timer if a timeout is set greater that 0 seconds
     */
    startAfkWarningTimer() {
        if (this.config.getNumericSettingValue(_Config_Config__WEBPACK_IMPORTED_MODULE_1__.NumericParameters.AFKTimeoutSecs) > 0 &&
            this.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_1__.Flags.AFKDetection)) {
            this.active = true;
        }
        else {
            this.active = false;
        }
        this.resetAfkWarningTimer();
    }
    /**
     * Stop the afk warning timer
     */
    stopAfkWarningTimer() {
        this.active = false;
        this.countdownActive = false;
        clearTimeout(this.warnTimer);
        clearInterval(this.countDownTimer);
    }
    /**
     * Pause the timer which when elapsed will warn the user they are inactive.
     */
    pauseAfkWarningTimer() {
        this.active = false;
    }
    /**
     * If the user interacts then reset the warning timer.
     */
    resetAfkWarningTimer() {
        if (this.active && this.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_1__.Flags.AFKDetection)) {
            clearTimeout(this.warnTimer);
            this.warnTimer = setTimeout(() => this.activateAfkEvent(), this.config.getNumericSettingValue(_Config_Config__WEBPACK_IMPORTED_MODULE_1__.NumericParameters.AFKTimeoutSecs) * 1000);
        }
    }
    /**
     * Show the AFK overlay and begin the countDown
     */
    activateAfkEvent() {
        // Pause the timer while the user is looking at the inactivity warning overlay
        this.pauseAfkWarningTimer();
        // instantiate a new overlay
        this.pixelStreaming.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.AfkWarningActivateEvent({
            countDown: this.countDown,
            dismissAfk: this.onDismissAfk
        }));
        // update our countDown timer and overlay contents
        this.countDown = this.config.getNumericSettingValue(_Config_Config__WEBPACK_IMPORTED_MODULE_1__.NumericParameters.AFKCountdownSecs);
        this.countdownActive = true;
        this.pixelStreaming.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.AfkWarningUpdateEvent({ countDown: this.countDown }));
        // if we are in locked mouse exit pointerlock
        if (!this.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_1__.Flags.HoveringMouseMode)) {
            // minor hack to alleviate ios not supporting pointerlock
            if (document.exitPointerLock) {
                document.exitPointerLock();
            }
        }
        // reset our countDown interval accordingly
        this.countDownTimer = setInterval(() => {
            this.countDown--;
            if (this.countDown == 0) {
                // The user failed to click so hide the overlay and disconnect them.
                this.pixelStreaming.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.AfkTimedOutEvent());
                this.onAFKTimedOutCallback();
                _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_2__.Logger.Info('You have been disconnected due to inactivity');
                // switch off the afk feature as stream has closed
                this.stopAfkWarningTimer();
            }
            else {
                this.pixelStreaming.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.AfkWarningUpdateEvent({ countDown: this.countDown }));
            }
        }, 1000);
    }
}
//# sourceMappingURL=AFKController.js.map

/***/ }),

/***/ 7463:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Config": () => (/* binding */ Config),
/* harmony export */   "ControlSchemeType": () => (/* binding */ ControlSchemeType),
/* harmony export */   "Flags": () => (/* binding */ Flags),
/* harmony export */   "NumericParameters": () => (/* binding */ NumericParameters),
/* harmony export */   "OptionParameters": () => (/* binding */ OptionParameters),
/* harmony export */   "TextParameters": () => (/* binding */ TextParameters),
/* harmony export */   "isFlagId": () => (/* binding */ isFlagId),
/* harmony export */   "isNumericId": () => (/* binding */ isNumericId),
/* harmony export */   "isOptionId": () => (/* binding */ isOptionId),
/* harmony export */   "isTextId": () => (/* binding */ isTextId)
/* harmony export */ });
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(7800);
/* harmony import */ var _SettingFlag__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(4506);
/* harmony import */ var _SettingNumber__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(6915);
/* harmony import */ var _SettingText__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9689);
/* harmony import */ var _SettingOption__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4138);
/* harmony import */ var _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(5391);
/* harmony import */ var _Util_BrowserUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7617);
// Copyright Epic Games, Inc. All Rights Reserved.







/**
 * A collection of flags that can be toggled and are core to all Pixel Streaming experiences.
 * These are used in the `Config.Flags` map.
 */
class Flags {
}
Flags.AutoConnect = 'AutoConnect';
Flags.AutoPlayVideo = 'AutoPlayVideo';
Flags.AFKDetection = 'TimeoutIfIdle';
Flags.HoveringMouseMode = 'HoveringMouse';
Flags.ForceMonoAudio = 'ForceMonoAudio';
Flags.ForceTURN = 'ForceTURN';
Flags.FakeMouseWithTouches = 'FakeMouseWithTouches';
Flags.IsQualityController = 'ControlsQuality';
Flags.MatchViewportResolution = 'MatchViewportRes';
Flags.StartVideoMuted = 'StartVideoMuted';
Flags.SuppressBrowserKeys = 'SuppressBrowserKeys';
Flags.UseMic = 'UseMic';
Flags.UseModalForTextInput = 'UseModalForTextInput';
Flags.UseCamera = 'UseCamera';
Flags.KeyboardInput = 'KeyboardInput';
Flags.MouseInput = 'MouseInput';
Flags.TouchInput = 'TouchInput';
Flags.GamepadInput = 'GamepadInput';
Flags.XRControllerInput = 'XRControllerInput';
Flags.WaitForStreamer = 'WaitForStreamer';
Flags.HideUI = 'HideUI';
Flags.EnableCaptureTimeExt = 'EnableCaptureTimeExt';
const isFlagId = (id) => Object.getOwnPropertyNames(Flags).some((name) => Flags[name] === id);
/**
 * A collection of numeric parameters that are core to all Pixel Streaming experiences.
 *
 */
class NumericParameters {
}
NumericParameters.AFKTimeoutSecs = 'AFKTimeout';
NumericParameters.AFKCountdownSecs = 'AFKCountdown';
NumericParameters.MinQP = 'MinQP';
NumericParameters.MaxQP = 'MaxQP';
NumericParameters.MinQuality = 'MinQuality';
NumericParameters.MaxQuality = 'MaxQuality';
NumericParameters.CompatQualityMin = 'CompatQualityMin';
NumericParameters.CompatQualityMax = 'CompatQualityMax';
NumericParameters.WebRTCFPS = 'WebRTCFPS';
NumericParameters.WebRTCMinBitrate = 'WebRTCMinBitrate';
NumericParameters.WebRTCMaxBitrate = 'WebRTCMaxBitrate';
NumericParameters.MaxReconnectAttempts = 'MaxReconnectAttempts';
NumericParameters.StreamerAutoJoinInterval = 'StreamerAutoJoinInterval';
NumericParameters.KeepaliveDelay = 'KeepaliveDelay';
const isNumericId = (id) => Object.getOwnPropertyNames(NumericParameters).some((name) => NumericParameters[name] === id);
/**
 * A collection of textual parameters that are core to all Pixel Streaming experiences.
 *
 */
class TextParameters {
}
TextParameters.SignallingServerUrl = 'ss';
const isTextId = (id) => Object.getOwnPropertyNames(TextParameters).some((name) => TextParameters[name] === id);
/**
 * A collection of enum based parameters that are core to all Pixel Streaming experiences.
 *
 */
class OptionParameters {
}
OptionParameters.PreferredCodec = 'PreferredCodec';
OptionParameters.StreamerId = 'StreamerId';
OptionParameters.PreferredQuality = 'PreferredQuality';
const isOptionId = (id) => Object.getOwnPropertyNames(OptionParameters).some((name) => OptionParameters[name] === id);
class Config {
    // ------------ Settings -----------------
    constructor(config = {}) {
        /* A map of flags that can be toggled - options that can be set in the application - e.g. Use Mic? */
        this.flags = new Map();
        /* A map of numerical settings - options that can be in the application - e.g. MinBitrate */
        this.numericParameters = new Map();
        /* A map of text settings - e.g. signalling server url */
        this.textParameters = new Map();
        /* A map of enum based settings - e.g. preferred codec */
        this.optionParameters = new Map();
        const { initialSettings, useUrlParams, webSocketProtocols } = config;
        this._useUrlParams = !!useUrlParams;
        this._webSocketProtocols = webSocketProtocols;
        this.populateDefaultSettings(this._useUrlParams, initialSettings);
    }
    /**
     * True if reading configuration initial values from URL parameters, and
     * persisting changes in URL when changed.
     */
    get useUrlParams() {
        return this._useUrlParams;
    }
    /**
     * Gets a protocol or list of protocols to pass to the websocket if set.
     */
    get webSocketProtocols() {
        return this._webSocketProtocols;
    }
    /**
     * Populate the default settings for a Pixel Streaming application
     */
    populateDefaultSettings(useUrlParams, settings) {
        /**
         * Text Parameters
         */
        this.textParameters.set(TextParameters.SignallingServerUrl, new _SettingText__WEBPACK_IMPORTED_MODULE_0__.SettingText(TextParameters.SignallingServerUrl, 'Signalling url', 'Url of the signalling server', settings && Object.prototype.hasOwnProperty.call(settings, TextParameters.SignallingServerUrl)
            ? settings[TextParameters.SignallingServerUrl]
            : (location.protocol === 'https:' ? 'wss://' : 'ws://') +
                window.location.hostname +
                // for readability, we omit the port if it's 80
                (window.location.port === '80' || window.location.port === ''
                    ? ''
                    : `:${window.location.port}`), useUrlParams));
        this.optionParameters.set(OptionParameters.StreamerId, new _SettingOption__WEBPACK_IMPORTED_MODULE_1__.SettingOption(OptionParameters.StreamerId, 'Streamer ID', 'The ID of the streamer to stream.', settings && Object.prototype.hasOwnProperty.call(settings, OptionParameters.StreamerId)
            ? settings[OptionParameters.StreamerId]
            : '', settings && Object.prototype.hasOwnProperty.call(settings, OptionParameters.StreamerId)
            ? [settings[OptionParameters.StreamerId]]
            : undefined, useUrlParams));
        const getDefaultVideoCodec = function () {
            const videoCodecs = _Util_BrowserUtils__WEBPACK_IMPORTED_MODULE_2__.BrowserUtils.getSupportedVideoCodecs();
            // If only one option, then select that.
            if (videoCodecs.length == 1) {
                return videoCodecs[0];
            }
            else if (videoCodecs.length > 0) {
                const defaultCodec = videoCodecs[0];
                for (const codec of videoCodecs) {
                    if (codec.startsWith('H264')) {
                        return codec;
                    }
                }
                return defaultCodec;
            }
            _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_3__.Logger.Error('Could not find any reasonable video codec to assign as a default.');
            return '';
        };
        const matchSpecifiedCodecToClosestSupported = function (specifiedCodec) {
            const browserSupportedCodecs = _Util_BrowserUtils__WEBPACK_IMPORTED_MODULE_2__.BrowserUtils.getSupportedVideoCodecs();
            // Codec supplied in url param is an exact match for the browser codec.
            // (e.g. H264 level-asymmetry-allowed=1;packetization-mode=1;profile-level-id=42e01f)
            if (browserSupportedCodecs.includes(specifiedCodec)) {
                return specifiedCodec;
            }
            // Try to match the start of whatever is passed into the url parameter with what the browser supports
            for (const browserCodec of browserSupportedCodecs) {
                if (browserCodec.startsWith(specifiedCodec)) {
                    return browserCodec;
                }
            }
            // If we weren't able to match, just return the codec as from the URL as-is.
            return specifiedCodec;
        };
        /**
         * Enum Parameters
         */
        this.optionParameters.set(OptionParameters.PreferredCodec, new _SettingOption__WEBPACK_IMPORTED_MODULE_1__.SettingOption(OptionParameters.PreferredCodec, 'Preferred Codec', 'The preferred codec to be used during codec negotiation', settings && Object.prototype.hasOwnProperty.call(settings, OptionParameters.PreferredCodec)
            ? matchSpecifiedCodecToClosestSupported(settings[OptionParameters.PreferredCodec])
            : getDefaultVideoCodec(), _Util_BrowserUtils__WEBPACK_IMPORTED_MODULE_2__.BrowserUtils.getSupportedVideoCodecs(), useUrlParams, matchSpecifiedCodecToClosestSupported));
        this.optionParameters.set(OptionParameters.PreferredQuality, new _SettingOption__WEBPACK_IMPORTED_MODULE_1__.SettingOption(OptionParameters.PreferredQuality, 'Preferred Quality', 'The preferred quality of the stream (only applicable when using the SFU)', settings && Object.prototype.hasOwnProperty.call(settings, OptionParameters.PreferredQuality)
            ? settings[OptionParameters.PreferredQuality]
            : 'Default', ['Default'], useUrlParams));
        /**
         * Boolean parameters
         */
        this.flags.set(Flags.AutoConnect, new _SettingFlag__WEBPACK_IMPORTED_MODULE_4__.SettingFlag(Flags.AutoConnect, 'Auto connect to stream', 'Whether we should attempt to auto connect to the signalling server or show a click to start prompt.', settings && Object.prototype.hasOwnProperty.call(settings, Flags.AutoConnect)
            ? settings[Flags.AutoConnect]
            : false, useUrlParams));
        this.flags.set(Flags.AutoPlayVideo, new _SettingFlag__WEBPACK_IMPORTED_MODULE_4__.SettingFlag(Flags.AutoPlayVideo, 'Auto play video', 'When video is ready automatically start playing it as opposed to showing a play button.', settings && Object.prototype.hasOwnProperty.call(settings, Flags.AutoPlayVideo)
            ? settings[Flags.AutoPlayVideo]
            : true, useUrlParams));
        this.flags.set(Flags.UseMic, new _SettingFlag__WEBPACK_IMPORTED_MODULE_4__.SettingFlag(Flags.UseMic, 'Use microphone', 'Make browser request microphone access and open an input audio track.', settings && Object.prototype.hasOwnProperty.call(settings, Flags.UseMic)
            ? settings[Flags.UseMic]
            : false, useUrlParams));
        this.flags.set(Flags.UseModalForTextInput, new _SettingFlag__WEBPACK_IMPORTED_MODULE_4__.SettingFlag(Flags.UseModalForTextInput, 'Use modal for text input', 'When entering input into a streamed UE text widget, use an input modal.', settings && Object.prototype.hasOwnProperty.call(settings, Flags.UseModalForTextInput)
            ? settings[Flags.UseModalForTextInput]
            : true, useUrlParams));
        this.flags.set(Flags.UseCamera, new _SettingFlag__WEBPACK_IMPORTED_MODULE_4__.SettingFlag(Flags.UseCamera, 'Use webcam', 'Make browser request webcam access and open a input video track.', settings && Object.prototype.hasOwnProperty.call(settings, Flags.UseCamera)
            ? settings[Flags.UseCamera]
            : false, useUrlParams));
        this.flags.set(Flags.StartVideoMuted, new _SettingFlag__WEBPACK_IMPORTED_MODULE_4__.SettingFlag(Flags.StartVideoMuted, 'Start video muted', 'Video will start muted if true.', settings && Object.prototype.hasOwnProperty.call(settings, Flags.StartVideoMuted)
            ? settings[Flags.StartVideoMuted]
            : false, useUrlParams));
        this.flags.set(Flags.SuppressBrowserKeys, new _SettingFlag__WEBPACK_IMPORTED_MODULE_4__.SettingFlag(Flags.SuppressBrowserKeys, 'Suppress browser keys', 'Suppress certain browser keys that we use in UE, for example F5 to show shader complexity instead of refresh the page.', settings && Object.prototype.hasOwnProperty.call(settings, Flags.SuppressBrowserKeys)
            ? settings[Flags.SuppressBrowserKeys]
            : true, useUrlParams));
        this.flags.set(Flags.IsQualityController, new _SettingFlag__WEBPACK_IMPORTED_MODULE_4__.SettingFlag(Flags.IsQualityController, 'Is quality controller?', 'True if this peer controls stream quality', settings && Object.prototype.hasOwnProperty.call(settings, Flags.IsQualityController)
            ? settings[Flags.IsQualityController]
            : true, useUrlParams));
        this.flags.set(Flags.ForceMonoAudio, new _SettingFlag__WEBPACK_IMPORTED_MODULE_4__.SettingFlag(Flags.ForceMonoAudio, 'Force mono audio', 'Force browser to request mono audio in the SDP', settings && Object.prototype.hasOwnProperty.call(settings, Flags.ForceMonoAudio)
            ? settings[Flags.ForceMonoAudio]
            : false, useUrlParams));
        this.flags.set(Flags.ForceTURN, new _SettingFlag__WEBPACK_IMPORTED_MODULE_4__.SettingFlag(Flags.ForceTURN, 'Force TURN', 'Only generate TURN/Relayed ICE candidates.', settings && Object.prototype.hasOwnProperty.call(settings, Flags.ForceTURN)
            ? settings[Flags.ForceTURN]
            : false, useUrlParams));
        this.flags.set(Flags.AFKDetection, new _SettingFlag__WEBPACK_IMPORTED_MODULE_4__.SettingFlag(Flags.AFKDetection, 'AFK if idle', 'Timeout the experience if user is AFK for a period.', settings && Object.prototype.hasOwnProperty.call(settings, Flags.AFKDetection)
            ? settings[Flags.AFKDetection]
            : false, useUrlParams));
        this.flags.set(Flags.MatchViewportResolution, new _SettingFlag__WEBPACK_IMPORTED_MODULE_4__.SettingFlag(Flags.MatchViewportResolution, 'Match viewport resolution', 'Pixel Streaming will be instructed to dynamically resize the video stream to match the size of the video element.', settings && Object.prototype.hasOwnProperty.call(settings, Flags.MatchViewportResolution)
            ? settings[Flags.MatchViewportResolution]
            : false, useUrlParams));
        this.flags.set(Flags.HoveringMouseMode, new _SettingFlag__WEBPACK_IMPORTED_MODULE_4__.SettingFlag(Flags.HoveringMouseMode, 'Control Scheme: Locked Mouse', 'Either locked mouse, where the pointer is consumed by the video and locked to it, or hovering mouse, where the mouse is not consumed.', settings && Object.prototype.hasOwnProperty.call(settings, Flags.HoveringMouseMode)
            ? settings[Flags.HoveringMouseMode]
            : false, useUrlParams, (isHoveringMouse, setting) => {
            setting.label = `Control Scheme: ${isHoveringMouse ? 'Hovering' : 'Locked'} Mouse`;
        }));
        this.flags.set(Flags.FakeMouseWithTouches, new _SettingFlag__WEBPACK_IMPORTED_MODULE_4__.SettingFlag(Flags.FakeMouseWithTouches, 'Fake mouse with touches', 'A single finger touch is converted into a mouse event. This allows a non-touch application to be controlled partially via a touch device.', settings && Object.prototype.hasOwnProperty.call(settings, Flags.FakeMouseWithTouches)
            ? settings[Flags.FakeMouseWithTouches]
            : false, useUrlParams));
        this.flags.set(Flags.KeyboardInput, new _SettingFlag__WEBPACK_IMPORTED_MODULE_4__.SettingFlag(Flags.KeyboardInput, 'Keyboard input', 'If enabled, send keyboard events to streamer', settings && Object.prototype.hasOwnProperty.call(settings, Flags.KeyboardInput)
            ? settings[Flags.KeyboardInput]
            : true, useUrlParams));
        this.flags.set(Flags.MouseInput, new _SettingFlag__WEBPACK_IMPORTED_MODULE_4__.SettingFlag(Flags.MouseInput, 'Mouse input', 'If enabled, send mouse events to streamer', settings && Object.prototype.hasOwnProperty.call(settings, Flags.MouseInput)
            ? settings[Flags.MouseInput]
            : true, useUrlParams));
        this.flags.set(Flags.TouchInput, new _SettingFlag__WEBPACK_IMPORTED_MODULE_4__.SettingFlag(Flags.TouchInput, 'Touch input', 'If enabled, send touch events to streamer', settings && Object.prototype.hasOwnProperty.call(settings, Flags.TouchInput)
            ? settings[Flags.TouchInput]
            : true, useUrlParams));
        this.flags.set(Flags.GamepadInput, new _SettingFlag__WEBPACK_IMPORTED_MODULE_4__.SettingFlag(Flags.GamepadInput, 'Gamepad input', 'If enabled, send gamepad events to streamer', settings && Object.prototype.hasOwnProperty.call(settings, Flags.GamepadInput)
            ? settings[Flags.GamepadInput]
            : true, useUrlParams));
        this.flags.set(Flags.XRControllerInput, new _SettingFlag__WEBPACK_IMPORTED_MODULE_4__.SettingFlag(Flags.XRControllerInput, 'XR controller input', 'If enabled, send XR controller events to streamer', settings && Object.prototype.hasOwnProperty.call(settings, Flags.XRControllerInput)
            ? settings[Flags.XRControllerInput]
            : true, useUrlParams));
        this.flags.set(Flags.WaitForStreamer, new _SettingFlag__WEBPACK_IMPORTED_MODULE_4__.SettingFlag(Flags.WaitForStreamer, 'Wait for streamer', 'Will continue trying to connect to the first streamer available.', settings && Object.prototype.hasOwnProperty.call(settings, Flags.WaitForStreamer)
            ? settings[Flags.WaitForStreamer]
            : true, useUrlParams));
        this.flags.set(Flags.HideUI, new _SettingFlag__WEBPACK_IMPORTED_MODULE_4__.SettingFlag(Flags.HideUI, 'Hide the UI overlay', 'Will hide all UI overlay details', settings && Object.prototype.hasOwnProperty.call(settings, Flags.HideUI)
            ? settings[Flags.HideUI]
            : false, useUrlParams));
        this.flags.set(Flags.EnableCaptureTimeExt, new _SettingFlag__WEBPACK_IMPORTED_MODULE_4__.SettingFlag(Flags.EnableCaptureTimeExt, 'Enable abs-capture-time', 'Enables the abs-capture-time RTP header extension', settings && Object.prototype.hasOwnProperty.call(settings, Flags.EnableCaptureTimeExt)
            ? settings[Flags.EnableCaptureTimeExt]
            : false, useUrlParams));
        /**
         * Numeric parameters
         */
        this.numericParameters.set(NumericParameters.AFKTimeoutSecs, new _SettingNumber__WEBPACK_IMPORTED_MODULE_5__.SettingNumber(NumericParameters.AFKTimeoutSecs, 'AFK timeout', 'The time (in seconds) it takes for the application to time out if AFK timeout is enabled.', 0 /*min*/, null /*max*/, settings && Object.prototype.hasOwnProperty.call(settings, NumericParameters.AFKTimeoutSecs)
            ? settings[NumericParameters.AFKTimeoutSecs]
            : 120 /*value*/, useUrlParams));
        this.numericParameters.set(NumericParameters.AFKCountdownSecs, new _SettingNumber__WEBPACK_IMPORTED_MODULE_5__.SettingNumber(NumericParameters.AFKCountdownSecs, 'AFK countdown', 'The time (in seconds) for a user to respond before the stream is ended after an AFK timeout.', 10 /*min*/, null /*max*/, 10 /*value*/, useUrlParams));
        this.numericParameters.set(NumericParameters.MaxReconnectAttempts, new _SettingNumber__WEBPACK_IMPORTED_MODULE_5__.SettingNumber(NumericParameters.MaxReconnectAttempts, 'Max Reconnects', 'Maximum number of reconnects the application will attempt when a streamer disconnects.', 0 /*min*/, 999 /*max*/, settings &&
            Object.prototype.hasOwnProperty.call(settings, NumericParameters.MaxReconnectAttempts)
            ? settings[NumericParameters.MaxReconnectAttempts]
            : 3 /*value*/, useUrlParams));
        this.numericParameters.set(NumericParameters.MinQP, new _SettingNumber__WEBPACK_IMPORTED_MODULE_5__.SettingNumber(NumericParameters.MinQP, 'Min QP', 'The lower bound for the quantization parameter (QP) of the encoder. 0 = Best quality, 51 = worst quality.', 0 /*min*/, 51 /*max*/, settings && Object.prototype.hasOwnProperty.call(settings, NumericParameters.MinQP)
            ? settings[NumericParameters.MinQP]
            : 0 /*value*/, useUrlParams));
        this.numericParameters.set(NumericParameters.MaxQP, new _SettingNumber__WEBPACK_IMPORTED_MODULE_5__.SettingNumber(NumericParameters.MaxQP, 'Max QP', 'The upper bound for the quantization parameter (QP) of the encoder. 0 = Best quality, 51 = worst quality.', 0 /*min*/, 51 /*max*/, settings && Object.prototype.hasOwnProperty.call(settings, NumericParameters.MaxQP)
            ? settings[NumericParameters.MaxQP]
            : 51 /*value*/, useUrlParams));
        this.numericParameters.set(NumericParameters.MinQuality, new _SettingNumber__WEBPACK_IMPORTED_MODULE_5__.SettingNumber(NumericParameters.MinQuality, 'Min Quality', 'The lower bound for the quality factor of the encoder. 0 = Worst quality, 100 = Best quality.', 0 /*min*/, 100 /*max*/, settings && Object.prototype.hasOwnProperty.call(settings, NumericParameters.MinQuality)
            ? settings[NumericParameters.MinQuality]
            : 0 /*value*/, useUrlParams));
        this.numericParameters.set(NumericParameters.MaxQuality, new _SettingNumber__WEBPACK_IMPORTED_MODULE_5__.SettingNumber(NumericParameters.MaxQuality, 'Max Quality', 'The upper bound for the quality factor of the encoder. 0 = Worst quality, 100 = Best quality.', 0 /*min*/, 100 /*max*/, settings && Object.prototype.hasOwnProperty.call(settings, NumericParameters.MaxQuality)
            ? settings[NumericParameters.MaxQuality]
            : 100 /*value*/, useUrlParams));
        this.numericParameters.set(NumericParameters.CompatQualityMin, new _SettingNumber__WEBPACK_IMPORTED_MODULE_5__.SettingNumber(NumericParameters.CompatQualityMin, 'Min Quality', 'The lower bound for encoding quality. 0 = Worst, 100 = Best.', 0 /*min*/, 100 /*max*/, settings && Object.prototype.hasOwnProperty.call(settings, NumericParameters.CompatQualityMin)
            ? settings[NumericParameters.CompatQualityMin]
            : 0 /*value*/, useUrlParams));
        this.numericParameters.set(NumericParameters.CompatQualityMax, new _SettingNumber__WEBPACK_IMPORTED_MODULE_5__.SettingNumber(NumericParameters.CompatQualityMax, 'Max Quality', 'The upper bound for encoding quality. 0 = Worst, 100 = Best.', 0 /*min*/, 100 /*max*/, settings && Object.prototype.hasOwnProperty.call(settings, NumericParameters.CompatQualityMax)
            ? settings[NumericParameters.CompatQualityMax]
            : 100 /*value*/, useUrlParams));
        this.numericParameters.set(NumericParameters.WebRTCFPS, new _SettingNumber__WEBPACK_IMPORTED_MODULE_5__.SettingNumber(NumericParameters.WebRTCFPS, 'Max FPS', 'The maximum FPS that WebRTC will try to transmit frames at.', 1 /*min*/, 999 /*max*/, settings && Object.prototype.hasOwnProperty.call(settings, NumericParameters.WebRTCFPS)
            ? settings[NumericParameters.WebRTCFPS]
            : 60 /*value*/, useUrlParams));
        this.numericParameters.set(NumericParameters.WebRTCMinBitrate, new _SettingNumber__WEBPACK_IMPORTED_MODULE_5__.SettingNumber(NumericParameters.WebRTCMinBitrate, 'Min Bitrate (kbps)', 'The minimum bitrate that WebRTC should use.', 0 /*min*/, 500000 /*max*/, settings && Object.prototype.hasOwnProperty.call(settings, NumericParameters.WebRTCMinBitrate)
            ? settings[NumericParameters.WebRTCMinBitrate]
            : 0 /*value*/, useUrlParams));
        this.numericParameters.set(NumericParameters.WebRTCMaxBitrate, new _SettingNumber__WEBPACK_IMPORTED_MODULE_5__.SettingNumber(NumericParameters.WebRTCMaxBitrate, 'Max Bitrate (kbps)', 'The maximum bitrate that WebRTC should use.', 0 /*min*/, 500000 /*max*/, settings && Object.prototype.hasOwnProperty.call(settings, NumericParameters.WebRTCMaxBitrate)
            ? settings[NumericParameters.WebRTCMaxBitrate]
            : 0 /*value*/, useUrlParams));
        this.numericParameters.set(NumericParameters.StreamerAutoJoinInterval, new _SettingNumber__WEBPACK_IMPORTED_MODULE_5__.SettingNumber(NumericParameters.StreamerAutoJoinInterval, 'Streamer Auto Join Interval (ms)', 'Delay between retries when waiting for an available streamer.', 500 /*min*/, 900000 /*max*/, settings &&
            Object.prototype.hasOwnProperty.call(settings, NumericParameters.StreamerAutoJoinInterval)
            ? settings[NumericParameters.StreamerAutoJoinInterval]
            : 3000 /*value*/, useUrlParams));
        this.numericParameters.set(NumericParameters.KeepaliveDelay, new _SettingNumber__WEBPACK_IMPORTED_MODULE_5__.SettingNumber(NumericParameters.KeepaliveDelay, 'Connection Keepalive delay', 'Delay between keepalive pings to the signalling server.', 0 /*min*/, 900000 /*max*/, settings && Object.prototype.hasOwnProperty.call(settings, NumericParameters.KeepaliveDelay)
            ? settings[NumericParameters.KeepaliveDelay]
            : 30000 /*value*/, useUrlParams));
    }
    /**
     * Add a callback to fire when the numeric setting is toggled.
     * @param id The id of the flag.
     * @param onChangedListener The callback to fire when the numeric value changes.
     */
    _addOnNumericSettingChangedListener(id, onChangedListener) {
        if (this.numericParameters.has(id)) {
            this.numericParameters.get(id).addOnChangedListener(onChangedListener);
        }
    }
    _addOnOptionSettingChangedListener(id, onChangedListener) {
        if (this.optionParameters.has(id)) {
            this.optionParameters.get(id).addOnChangedListener(onChangedListener);
        }
    }
    /**
     * @param id The id of the numeric setting we are interested in getting a value for.
     * @returns The numeric value stored in the parameter with the passed id.
     */
    getNumericSettingValue(id) {
        if (this.numericParameters.has(id)) {
            return this.numericParameters.get(id).number;
        }
        else {
            throw new Error(`There is no numeric setting with the id of ${id}`);
        }
    }
    /**
     * @param id The id of the text setting we are interested in getting a value for.
     * @returns The text value stored in the parameter with the passed id.
     */
    getTextSettingValue(id) {
        if (this.textParameters.has(id)) {
            return this.textParameters.get(id).value;
        }
        else {
            throw new Error(`There is no numeric setting with the id of ${id}`);
        }
    }
    /**
     * Set number in the setting.
     * @param id The id of the numeric setting we are interested in.
     * @param value The numeric value to set.
     */
    setNumericSetting(id, value) {
        if (this.numericParameters.has(id)) {
            this.numericParameters.get(id).number = value;
        }
        else {
            throw new Error(`There is no numeric setting with the id of ${id}`);
        }
    }
    /**
     * Add a callback to fire when the flag is toggled.
     * @param id The id of the flag.
     * @param onChangeListener The callback to fire when the value changes.
     */
    _addOnSettingChangedListener(id, onChangeListener) {
        if (this.flags.has(id)) {
            this.flags.get(id).onChange = onChangeListener;
        }
    }
    /**
     * Add a callback to fire when the text is changed.
     * @param id The id of the flag.
     * @param onChangeListener The callback to fire when the value changes.
     */
    _addOnTextSettingChangedListener(id, onChangeListener) {
        if (this.textParameters.has(id)) {
            this.textParameters.get(id).onChange = onChangeListener;
        }
    }
    /**
     * Get the option which has the given id.
     * @param id The id of the option.
     * @returns The SettingOption object matching id
     */
    getSettingOption(id) {
        return this.optionParameters.get(id);
    }
    /**
     * Get the value of the configuration flag which has the given id.
     * @param id The unique id for the flag.
     * @returns True if the flag is enabled.
     */
    isFlagEnabled(id) {
        return this.flags.get(id).flag;
    }
    /**
     * Set flag to be enabled/disabled.
     * @param id The id of the flag to toggle.
     * @param flagEnabled True if the flag should be enabled.
     */
    setFlagEnabled(id, flagEnabled) {
        if (!this.flags.has(id)) {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_3__.Logger.Warning(`Cannot toggle flag called ${id} - it does not exist in the Config.flags map.`);
        }
        else {
            this.flags.get(id).flag = flagEnabled;
        }
    }
    /**
     * Set the text setting.
     * @param id The id of the setting
     * @param settingValue The value to set in the setting.
     */
    setTextSetting(id, settingValue) {
        if (!this.textParameters.has(id)) {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_3__.Logger.Warning(`Cannot set text setting called ${id} - it does not exist in the Config.textParameters map.`);
        }
        else {
            this.textParameters.get(id).text = settingValue;
        }
    }
    /**
     * Set the option setting list of options.
     * @param id The id of the setting
     * @param settingOptions The values the setting could take
     */
    setOptionSettingOptions(id, settingOptions) {
        if (!this.optionParameters.has(id)) {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_3__.Logger.Warning(`Cannot set text setting called ${id} - it does not exist in the Config.optionParameters map.`);
        }
        else {
            this.optionParameters.get(id).options = settingOptions;
        }
    }
    /**
     * Set option enum settings selected option.
     * @param id The id of the setting
     * @param settingOptions The value to select out of all the options
     */
    setOptionSettingValue(id, settingValue) {
        if (!this.optionParameters.has(id)) {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_3__.Logger.Warning(`Cannot set text setting called ${id} - it does not exist in the Config.enumParameters map.`);
        }
        else {
            const optionSetting = this.optionParameters.get(id);
            const existingOptions = optionSetting.options;
            if (!existingOptions.includes(settingValue)) {
                existingOptions.push(settingValue);
                optionSetting.options = existingOptions;
            }
            optionSetting.selected = settingValue;
        }
    }
    /**
     * Set the label for the flag.
     * @param id The id of the flag.
     * @param label The new label to use for the flag.
     */
    setFlagLabel(id, label) {
        if (!this.flags.has(id)) {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_3__.Logger.Warning(`Cannot set label for flag called ${id} - it does not exist in the Config.flags map.`);
        }
        else {
            this.flags.get(id).label = label;
        }
    }
    /**
     * Set a subset of all settings in one function call.
     *
     * @param settings A (partial) list of settings to set
     */
    setSettings(settings) {
        for (const key of Object.keys(settings)) {
            if (isFlagId(key)) {
                this.setFlagEnabled(key, settings[key]);
            }
            else if (isNumericId(key)) {
                this.setNumericSetting(key, settings[key]);
            }
            else if (isTextId(key)) {
                this.setTextSetting(key, settings[key]);
            }
            else if (isOptionId(key)) {
                this.setOptionSettingValue(key, settings[key]);
            }
        }
    }
    /**
     * Get all settings
     * @returns All setting values as an object with setting ids as keys
     */
    getSettings() {
        const settings = {};
        for (const [key, value] of this.flags.entries()) {
            settings[key] = value.flag;
        }
        for (const [key, value] of this.numericParameters.entries()) {
            settings[key] = value.number;
        }
        for (const [key, value] of this.textParameters.entries()) {
            settings[key] = value.text;
        }
        for (const [key, value] of this.optionParameters.entries()) {
            settings[key] = value.selected;
        }
        return settings;
    }
    /**
     * Get all Flag settings as an array.
     * @returns All SettingFlag objects
     */
    getFlags() {
        return Array.from(this.flags.values());
    }
    /**
     * Get all Text settings as an array.
     * @returns All SettingText objects
     */
    getTextSettings() {
        return Array.from(this.textParameters.values());
    }
    /**
     * Get all Number settings as an array.
     * @returns All SettingNumber objects
     */
    getNumericSettings() {
        return Array.from(this.numericParameters.values());
    }
    /**
     * Get all Option settings as an array.
     * @returns All SettingOption objects
     */
    getOptionSettings() {
        return Array.from(this.optionParameters.values());
    }
    /**
     * Emit events when settings change.
     * @param eventEmitter
     */
    _registerOnChangeEvents(eventEmitter) {
        for (const key of this.flags.keys()) {
            const flag = this.flags.get(key);
            if (flag) {
                flag.onChangeEmit = (newValue) => eventEmitter.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_6__.SettingsChangedEvent({
                    id: flag.id,
                    type: 'flag',
                    value: newValue,
                    target: flag
                }));
            }
        }
        for (const key of this.numericParameters.keys()) {
            const number = this.numericParameters.get(key);
            if (number) {
                number.onChangeEmit = (newValue) => eventEmitter.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_6__.SettingsChangedEvent({
                    id: number.id,
                    type: 'number',
                    value: newValue,
                    target: number
                }));
            }
        }
        for (const key of this.textParameters.keys()) {
            const text = this.textParameters.get(key);
            if (text) {
                text.onChangeEmit = (newValue) => eventEmitter.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_6__.SettingsChangedEvent({
                    id: text.id,
                    type: 'text',
                    value: newValue,
                    target: text
                }));
            }
        }
        for (const key of this.optionParameters.keys()) {
            const option = this.optionParameters.get(key);
            if (option) {
                option.onChangeEmit = (newValue) => eventEmitter.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_6__.SettingsChangedEvent({
                    id: option.id,
                    type: 'option',
                    value: newValue,
                    target: option
                }));
            }
        }
    }
}
/**
 * The enum associated with the mouse being locked or hovering
 */
var ControlSchemeType;
(function (ControlSchemeType) {
    ControlSchemeType[ControlSchemeType["LockedMouse"] = 0] = "LockedMouse";
    ControlSchemeType[ControlSchemeType["HoveringMouse"] = 1] = "HoveringMouse";
})(ControlSchemeType || (ControlSchemeType = {}));
//# sourceMappingURL=Config.js.map

/***/ }),

/***/ 4638:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SettingBase": () => (/* binding */ SettingBase)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
/**
 * Base class for a setting that has a text label and an arbitrary setting value it stores.
 */
class SettingBase {
    constructor(id, label, description, defaultSettingValue, defaultOnChangeListener = () => {
        /* Do nothing, to be overridden. */
    }) {
        this.parseURLParams();
        this.onChange = defaultOnChangeListener;
        this.onChangeEmit = () => {
            /* Do nothing, to be overridden. */
        };
        this.id = id;
        this.description = description;
        this.label = label;
        this.value = defaultSettingValue;
    }
    /**
     * Set the label text for the setting.
     * @param label setting label.
     */
    set label(inLabel) {
        this._label = inLabel;
        this.onChangeEmit(this._value);
    }
    /**
     * @returns The label text for the setting.
     */
    get label() {
        return this._label;
    }
    /**
     * @return The setting's value.
     */
    get value() {
        return this._value;
    }
    /**
     * Update the setting's stored value.
     * @param inValue The new value for the setting.
     */
    set value(inValue) {
        this._value = inValue;
        this.onChange(this._value, this);
        this.onChangeEmit(this._value);
    }
    /**
     * Persist the setting value in URL.
     */
    updateURLParams() {
        if (this.useUrlParams) {
            // set url params
            const urlParams = new URLSearchParams(window.location.search);
            const valueString = this.getValueAsString();
            let set = false;
            for (const [name, _value] of urlParams) {
                if (name.toLowerCase() == this.id.toLowerCase()) {
                    urlParams.set(name, valueString);
                    set = true;
                    break;
                }
            }
            if (!set) {
                urlParams.set(this.id, valueString);
            }
            window.history.replaceState({}, '', urlParams.toString() !== '' ? `${location.pathname}?${urlParams}` : `${location.pathname}`);
        }
    }
    /**
     * Allows sub types to provide their value for the url search params.
     */
    getValueAsString() {
        return '';
    }
    parseURLParams() {
        this._urlParams = {};
        const params = new URLSearchParams(window.location.search);
        for (const [name, value] of params) {
            this._urlParams[name.toLowerCase()] = value;
        }
    }
    hasURLParam(name) {
        return name.toLowerCase() in this._urlParams;
    }
    getURLParam(name) {
        if (this.hasURLParam(name)) {
            return this._urlParams[name.toLowerCase()];
        }
        return '';
    }
}
//# sourceMappingURL=SettingBase.js.map

/***/ }),

/***/ 4506:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SettingFlag": () => (/* binding */ SettingFlag)
/* harmony export */ });
/* harmony import */ var _SettingBase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4638);
// Copyright Epic Games, Inc. All Rights Reserved.

/**
 * A boolean flag setting object with a text label.
 */
class SettingFlag extends _SettingBase__WEBPACK_IMPORTED_MODULE_0__.SettingBase {
    constructor(id, label, description, defaultFlagValue, useUrlParams, defaultOnChangeListener = () => {
        /* Do nothing, to be overridden. */
    }) {
        super(id, label, description, defaultFlagValue, defaultOnChangeListener);
        if (!useUrlParams || !this.hasURLParam(this.id)) {
            this.flag = defaultFlagValue;
        }
        else {
            // parse flag from url parameters
            const urlParamFlag = this.getURLParam(this.id);
            this.flag = urlParamFlag.toLowerCase() != 'false';
        }
        this.useUrlParams = useUrlParams;
    }
    getValueAsString() {
        return this.flag ? 'true' : 'false';
    }
    /**
     * Enables this flag.
     */
    enable() {
        this.flag = true;
    }
    /**
     * @return The setting's value.
     */
    get flag() {
        return !!this.value;
    }
    /**
     * Update the setting's stored value.
     * @param inValue The new value for the setting.
     */
    set flag(inValue) {
        this.value = inValue;
    }
}
//# sourceMappingURL=SettingFlag.js.map

/***/ }),

/***/ 6915:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SettingNumber": () => (/* binding */ SettingNumber)
/* harmony export */ });
/* harmony import */ var _SettingBase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4638);
// Copyright Epic Games, Inc. All Rights Reserved.

/**
 * A number setting object with a text label. Min and max limit the range of allowed values.
 */
class SettingNumber extends _SettingBase__WEBPACK_IMPORTED_MODULE_0__.SettingBase {
    constructor(id, label, description, min, max, defaultNumber, useUrlParams, defaultOnChangeListener = () => {
        /* Do nothing, to be overridden. */
    }) {
        super(id, label, description, defaultNumber, defaultOnChangeListener);
        this._min = min;
        this._max = max;
        // attempt to read the number from the url params
        if (!useUrlParams || !this.hasURLParam(this.id)) {
            this.number = defaultNumber;
        }
        else {
            const parsedValue = Number.parseFloat(this.getURLParam(this.id));
            this.number = Number.isNaN(parsedValue) ? defaultNumber : parsedValue;
        }
        this.useUrlParams = useUrlParams;
    }
    getValueAsString() {
        return this.number.toString();
    }
    /**
     * Set the number value (will be clamped within range).
     */
    set number(newNumber) {
        this.value = this.clamp(newNumber);
    }
    /**
     * @returns The number stored.
     */
    get number() {
        return this.value;
    }
    /**
     * Clamps a number between the min and max values (inclusive).
     * @param inNumber The number to clamp.
     * @returns The clamped number.
     */
    clamp(inNumber) {
        if (this._min == null && this._max == null) {
            return inNumber;
        }
        else if (this._min == null) {
            return Math.min(this._max, inNumber);
        }
        else if (this._max == null) {
            return Math.max(this._min, inNumber);
        }
        else {
            return Math.max(Math.min(this._max, inNumber), this._min);
        }
    }
    /**
     * Returns the minimum value
     * @returns The minimum value
     */
    get min() {
        return this._min;
    }
    /**
     * Returns the maximum value
     * @returns The maximum value
     */
    get max() {
        return this._max;
    }
    /**
     * Add a change listener to the number object.
     */
    addOnChangedListener(onChangedFunc) {
        this.onChange = onChangedFunc;
    }
}
//# sourceMappingURL=SettingNumber.js.map

/***/ }),

/***/ 4138:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SettingOption": () => (/* binding */ SettingOption)
/* harmony export */ });
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7800);
/* harmony import */ var _SettingBase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4638);
// Copyright Epic Games, Inc. All Rights Reserved.


/**
 * An Option setting object with a text label. Allows you to specify an array of options and select one of them.
 */
class SettingOption extends _SettingBase__WEBPACK_IMPORTED_MODULE_0__.SettingBase {
    constructor(id, label, description, defaultTextValue, options, useUrlParams, defaultUrlParamResolver = function (value) {
        /* Return the string as-is by default */
        return value;
    }, defaultOnChangeListener = () => {
        /* Do nothing, to be overridden. */
    }) {
        super(id, label, description, defaultTextValue, defaultOnChangeListener);
        this._urlParamResolver = defaultUrlParamResolver;
        const stringToMatch = this.hasURLParam(this.id)
            ? this._urlParamResolver(this.getURLParam(this.id))
            : defaultTextValue;
        this.options = options !== null && options !== void 0 ? options : [stringToMatch];
        this.selected = stringToMatch;
        this.useUrlParams = useUrlParams;
    }
    getValueAsString() {
        return this.selected;
    }
    /**
     * Add a change listener to the select element.
     */
    addOnChangedListener(onChangedFunc) {
        this.onChange = onChangedFunc;
    }
    /**
     * @returns All available options as an array
     */
    get options() {
        return this._options;
    }
    /**
     * Set options
     * @param values Array of options
     */
    set options(values) {
        this._options = values;
        this.onChangeEmit(this.selected);
    }
    /**
     * @returns Selected option as a string
     */
    get selected() {
        return this.value;
    }
    /**
     * Set selected option if it matches one of the available options
     * @param value Selected option
     */
    set selected(value) {
        if (value === undefined) {
            return;
        }
        // If options contains the value, then set that as selected
        if (this.options.includes(value)) {
            this.value = value;
        }
        else {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_1__.Logger.Error(`Could not set "${value}" as the selected option for ${this.id} because it wasn't one of the options.`);
        }
    }
    /**
     * Set the url parameter resolver to do some transformation to the string value
     * that is extracted from the url parameters.
     * @param urlParam A function that transforms the extracted url parameter string for this setting to something else.
     */
    set urlParamResolver(value) {
        this._urlParamResolver = value;
    }
}
//# sourceMappingURL=SettingOption.js.map

/***/ }),

/***/ 9689:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SettingText": () => (/* binding */ SettingText)
/* harmony export */ });
/* harmony import */ var _SettingBase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4638);
// Copyright Epic Games, Inc. All Rights Reserved.

/**
 * A text setting object with a text label.
 */
class SettingText extends _SettingBase__WEBPACK_IMPORTED_MODULE_0__.SettingBase {
    constructor(id, label, description, defaultTextValue, useUrlParams, defaultOnChangeListener = () => {
        /* Do nothing, to be overridden. */
    }) {
        super(id, label, description, defaultTextValue, defaultOnChangeListener);
        if (!useUrlParams || !this.hasURLParam(this.id)) {
            this.text = defaultTextValue;
        }
        else {
            // parse flag from url parameters
            this.text = this.getURLParam(this.id);
        }
        this.useUrlParams = useUrlParams;
    }
    getValueAsString() {
        return this.text;
    }
    /**
     * @return The setting's value.
     */
    get text() {
        return this.value;
    }
    /**
     * Update the setting's stored value.
     * @param inValue The new value for the setting.
     */
    set text(inValue) {
        this.value = inValue;
    }
}
//# sourceMappingURL=SettingText.js.map

/***/ }),

/***/ 7748:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DataChannelController": () => (/* binding */ DataChannelController)
/* harmony export */ });
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7800);
// Copyright Epic Games, Inc. All Rights Reserved.

/**
 * Handles the Sending and Receiving of messages to the UE Instance via the Data Channel
 */
class DataChannelController {
    constructor() {
        this.isReceivingFreezeFrame = false;
    }
    /**
     * return the current state of a datachannel controller instance
     * @returns the current DataChannelController instance
     */
    getDataChannelInstance() {
        return this;
    }
    /**
     * To Create and Set up a Data Channel
     * @param peerConnection - The RTC Peer Connection
     * @param label - Label of the Data Channel
     * @param datachannelOptions - Optional RTC DataChannel options
     */
    createDataChannel(peerConnection, label, datachannelOptions) {
        this.peerConnection = peerConnection;
        this.label = label;
        this.datachannelOptions = datachannelOptions;
        if (datachannelOptions == null) {
            this.datachannelOptions = {};
            this.datachannelOptions.ordered = true;
        }
        this.dataChannel = this.peerConnection.createDataChannel(this.label, this.datachannelOptions);
        this.setupDataChannel();
    }
    setupDataChannel() {
        //We Want an Array Buffer not a blob
        this.dataChannel.binaryType = 'arraybuffer';
        this.dataChannel.onopen = (ev) => this.handleOnOpen(ev);
        this.dataChannel.onclose = (ev) => this.handleOnClose(ev);
        this.dataChannel.onmessage = (ev) => this.handleOnMessage(ev);
        this.dataChannel.onerror = (ev) => this.handleOnError(ev);
    }
    /**
     * Handles when the Data Channel is opened
     */
    handleOnOpen(ev) {
        var _a;
        _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_0__.Logger.Info(`Data Channel (${this.label}) opened.`);
        this.onOpen((_a = this.dataChannel) === null || _a === void 0 ? void 0 : _a.label, ev);
    }
    /**
     * Handles when the Data Channel is closed
     */
    handleOnClose(ev) {
        var _a;
        _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_0__.Logger.Info(`Data Channel (${this.label}) closed.`);
        this.onClose((_a = this.dataChannel) === null || _a === void 0 ? void 0 : _a.label, ev);
    }
    /**
     * Handles when a message is received
     * @param event - Message Event
     */
    handleOnMessage(event) {
        // Higher log level to prevent log spam with messages received
        _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_0__.Logger.Info(`Data Channel (${this.label}) message: ${event}`);
    }
    /**
     * Handles when an error is thrown
     * @param event - Error Event
     */
    handleOnError(event) {
        var _a;
        _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_0__.Logger.Info(`Data Channel (${this.label}) error: ${event}`);
        this.onError((_a = this.dataChannel) === null || _a === void 0 ? void 0 : _a.label, event);
    }
    /**
     * Override to register onOpen handler
     * @param label Data channel label ("datachannel", "send-datachannel", "recv-datachannel")
     * @param ev event
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onOpen(label, ev) {
        // empty default implementation
    }
    /**
     * Override to register onClose handler
     * @param label Data channel label ("datachannel", "send-datachannel", "recv-datachannel")
     * @param ev event
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onClose(label, ev) {
        // empty default implementation
    }
    /**
     * Override to register onError handler
     * @param label Data channel label ("datachannel", "send-datachannel", "recv-datachannel")
     * @param ev event
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onError(label, ev) {
        // empty default implementation
    }
}
//# sourceMappingURL=DataChannelController.js.map

/***/ }),

/***/ 1075:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DataChannelLatencyTestController": () => (/* binding */ DataChannelLatencyTestController)
/* harmony export */ });
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7800);
/* harmony import */ var _DataChannelLatencyTestResults__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2410);
// Copyright Epic Games, Inc. All Rights Reserved.


class DataChannelLatencyTestController {
    constructor(sink, callback) {
        this.intervalHandle = undefined;
        this.sink = sink;
        this.callback = callback;
        this.records = new Map();
        this.seq = 0;
    }
    start(config) {
        if (this.isRunning()) {
            return false;
        }
        this.startTime = Date.now();
        this.records.clear();
        this.intervalHandle = window.setInterval((() => {
            if (Date.now() - this.startTime >= config.duration) {
                this.stop();
            }
            else {
                this.sendRequest(config.requestSize, config.responseSize);
            }
        }).bind(this), Math.floor(1000 / config.rps));
        return true;
    }
    stop() {
        if (this.intervalHandle) {
            window.clearInterval(this.intervalHandle);
            this.intervalHandle = undefined;
            this.callback(this.produceResult());
        }
    }
    produceResult() {
        const resultRecords = new Map(this.records);
        return {
            records: resultRecords,
            dataChannelRtt: Math.ceil(Array.from(this.records.values()).reduce((acc, next) => {
                return acc + (next.playerReceivedTimestamp - next.playerSentTimestamp);
            }, 0) / this.records.size),
            playerToStreamerTime: Math.ceil(Array.from(this.records.values()).reduce((acc, next) => {
                return acc + (next.streamerReceivedTimestamp - next.playerSentTimestamp);
            }, 0) / this.records.size),
            streamerToPlayerTime: Math.ceil(Array.from(this.records.values()).reduce((acc, next) => {
                return acc + (next.playerReceivedTimestamp - next.streamerSentTimestamp);
            }, 0) / this.records.size),
            exportLatencyAsCSV: () => {
                let csv = 'Timestamp;RTT;PlayerToStreamer;StreamerToPlayer;\n';
                resultRecords.forEach((record) => {
                    csv += record.playerSentTimestamp + ';';
                    csv += record.playerReceivedTimestamp - record.playerSentTimestamp + ';';
                    csv += record.streamerReceivedTimestamp - record.playerSentTimestamp + ';';
                    csv += record.playerReceivedTimestamp - record.streamerSentTimestamp + ';';
                    csv += '\n';
                });
                return csv;
            }
        };
    }
    isRunning() {
        return !!this.intervalHandle;
    }
    receive(response) {
        if (!this.isRunning()) {
            return;
        }
        if (!response) {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_0__.Logger.Error('Undefined response from server');
            return;
        }
        const record = this.records.get(response.Seq);
        if (record) {
            record.update(response);
        }
    }
    sendRequest(requestSize, responseSize) {
        const request = this.createRequest(requestSize, responseSize);
        const record = new _DataChannelLatencyTestResults__WEBPACK_IMPORTED_MODULE_1__.DataChannelLatencyTestRecord(request);
        this.records.set(record.seq, record);
        this.sink(request);
    }
    createRequest(requestSize, responseSize) {
        return {
            Seq: this.seq++,
            FillResponseSize: responseSize,
            Filler: requestSize ? 'A'.repeat(requestSize) : ''
        };
    }
}
//# sourceMappingURL=DataChannelLatencyTestController.js.map

/***/ }),

/***/ 2410:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DataChannelLatencyTestRecord": () => (/* binding */ DataChannelLatencyTestRecord)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
class DataChannelLatencyTestRecord {
    constructor(request) {
        this.seq = request.Seq;
        this.playerSentTimestamp = Date.now();
        this.requestFillerSize = request.Filler ? request.Filler.length : 0;
    }
    update(response) {
        this.playerReceivedTimestamp = Date.now();
        this.streamerReceivedTimestamp = response.ReceivedTimestamp;
        this.streamerSentTimestamp = response.SentTimestamp;
        this.responseFillerSize = response.Filler ? response.Filler.length : 0;
    }
}
//# sourceMappingURL=DataChannelLatencyTestResults.js.map

/***/ }),

/***/ 8156:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DataChannelSender": () => (/* binding */ DataChannelSender)
/* harmony export */ });
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7800);
// Copyright Epic Games, Inc. All Rights Reserved.

/**
 * A class for sending data channel messages
 */
class DataChannelSender {
    /**
     * @param dataChannelProvider - Data channel object type
     */
    constructor(dataChannelProvider) {
        this.dataChannelProvider = dataChannelProvider;
    }
    canSend() {
        return (this.dataChannelProvider.getDataChannelInstance().dataChannel !== undefined &&
            this.dataChannelProvider.getDataChannelInstance().dataChannel.readyState == 'open');
    }
    /**
     * Send Data over the Data channel to the UE Instance
     * @param data - Message Data Array Buffer
     */
    sendData(data) {
        // reset the afk inactivity
        const dataChannelInstance = this.dataChannelProvider.getDataChannelInstance();
        if (dataChannelInstance.dataChannel.readyState == 'open') {
            dataChannelInstance.dataChannel.send(data);
            _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_0__.Logger.Info(`Message Sent: ${new Uint8Array(data)}`);
            this.resetAfkWarningTimerOnDataSend();
        }
        else {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_0__.Logger.Error(`Message Failed: ${new Uint8Array(data)}`);
        }
    }
    /**
     * An override method for resetting the Afk warning timer when data is sent over the data channel
     */
    resetAfkWarningTimerOnDataSend() {
        // Base Functionality: Do Nothing
    }
}
//# sourceMappingURL=DataChannelSender.js.map

/***/ }),

/***/ 877:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EncoderSettings": () => (/* binding */ EncoderSettings),
/* harmony export */   "InitialSettings": () => (/* binding */ InitialSettings),
/* harmony export */   "PixelStreamingSettings": () => (/* binding */ PixelStreamingSettings),
/* harmony export */   "WebRTCSettings": () => (/* binding */ WebRTCSettings)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
/**
 * Latency Test Results Data
 */
class InitialSettings {
    constructor() {
        this.PixelStreamingSettings = new PixelStreamingSettings();
        this.EncoderSettings = new EncoderSettings();
        this.WebRTCSettings = new WebRTCSettings();
    }
    /**
     * Checks for compatibility with the FPS and MaxFPS stats between 4.27 and 5
     */
    ueCompatible() {
        if (this.WebRTCSettings.MaxFPS != null) {
            this.WebRTCSettings.FPS = this.WebRTCSettings.MaxFPS;
        }
    }
}
/**
 * A class for handling Pixel Streaming details
 */
class PixelStreamingSettings {
}
/**
 * A class for handling encoder stats
 */
class EncoderSettings {
}
/**
 * A class for handling web rtc stats
 */
class WebRTCSettings {
}
//# sourceMappingURL=InitialSettings.js.map

/***/ }),

/***/ 7942:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LatencyTestResults": () => (/* binding */ LatencyTestResults)
/* harmony export */ });
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7800);
// Copyright Epic Games, Inc. All Rights Reserved.

/**
 * Latency Test Results Data
 */
class LatencyTestResults {
    constructor() {
        //Fields Set from the latency payload regardless of version
        this.ReceiptTimeMs = null;
        this.TransmissionTimeMs = null;
        //Fields Set from the latency payload from 4.27.2
        this.PreCaptureTimeMs = null;
        this.PostCaptureTimeMs = null;
        this.PreEncodeTimeMs = null;
        this.PostEncodeTimeMs = null;
        //Fields Set from the latency payload from 5.0
        this.EncodeMs = null;
        this.CaptureToSendMs = null;
        //Fields Set when processed
        this.testStartTimeMs = 0;
        this.browserReceiptTimeMs = 0;
        //Fields set from calculations
        this.latencyExcludingDecode = 0;
        this.testDuration = 0;
        //ueLatency: number = 0;
        this.networkLatency = 0;
        this.browserSendLatency = 0;
        this.frameDisplayDeltaTimeMs = 0;
        this.endToEndLatency = 0;
        //uePixelStreamLatency: number = 0;
        this.encodeLatency = 0;
    }
    /**
     * Sets the Delta Time Milliseconds
     * @param DeltaTimeMs - Delta Time Milliseconds
     */
    setFrameDisplayDeltaTime(DeltaTimeMs) {
        if (this.frameDisplayDeltaTimeMs == 0) {
            this.frameDisplayDeltaTimeMs = Math.round(DeltaTimeMs);
        }
    }
    /**
     * Process the encoder times and set them
     */
    processFields() {
        if (this.EncodeMs == null && (this.PreEncodeTimeMs != null || this.PostEncodeTimeMs != null)) {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_0__.Logger.Info(`Setting Encode Ms \n ${this.PostEncodeTimeMs} \n ${this.PreEncodeTimeMs}`);
            this.EncodeMs = this.PostEncodeTimeMs - this.PreEncodeTimeMs;
        }
        if (this.CaptureToSendMs == null &&
            (this.PreCaptureTimeMs != null || this.PostCaptureTimeMs != null)) {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_0__.Logger.Info(`Setting CaptureToSendMs Ms \n ${this.PostCaptureTimeMs} \n ${this.PreCaptureTimeMs}`);
            this.CaptureToSendMs = this.PostCaptureTimeMs - this.PreCaptureTimeMs;
        }
    }
}
//# sourceMappingURL=LatencyTestResults.js.map

/***/ }),

/***/ 6462:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FreezeFrame": () => (/* binding */ FreezeFrame)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
/**
 * A class for managing the freeze frame object
 */
class FreezeFrame {
    /**
     * Construct a freeze frame
     * @param rootDiv the div that a freeze frame element will be injected into
     */
    constructor(rootDiv) {
        this.freezeFrameHeight = 0;
        this.freezeFrameWidth = 0;
        this.rootDiv = rootDiv;
        // create the overlay
        this.rootElement = document.createElement('div');
        this.rootElement.id = 'freezeFrame';
        this.rootElement.style.display = 'none';
        this.rootElement.style.pointerEvents = 'none';
        this.rootElement.style.position = 'absolute';
        this.rootElement.style.zIndex = '20';
        // create the image place holder
        this.imageElement = document.createElement('img');
        this.imageElement.style.position = 'absolute';
        // append the image into the root element and append the element to the root div
        this.rootElement.appendChild(this.imageElement);
        this.rootDiv.appendChild(this.rootElement);
    }
    /**
     * Set the freeze frame element for showing
     */
    setElementForShow() {
        this.rootElement.style.display = 'block';
    }
    /**
     * Set the freeze frame element for hiding
     */
    setElementForHide() {
        this.rootElement.style.display = 'none';
    }
    /**
     * Update the freeze frames image source
     * @param jpeg - the freeze frame image as a byte array data
     */
    updateImageElementSource(jpeg) {
        const base64 = btoa(jpeg.reduce((data, byte) => data + String.fromCharCode(byte), ''));
        this.imageElement.src = 'data:image/jpeg;base64,' + base64;
    }
    /**
     * Set the dimensions for the freeze frame from the element and resize it
     */
    setDimensionsFromElementAndResize() {
        this.freezeFrameHeight = this.imageElement.naturalHeight;
        this.freezeFrameWidth = this.imageElement.naturalWidth;
        this.resize();
    }
    /**
     * Resize a freeze frame element
     */
    resize() {
        if (this.freezeFrameWidth !== 0 && this.freezeFrameHeight !== 0) {
            let displayWidth = 0;
            let displayHeight = 0;
            let displayTop = 0;
            let displayLeft = 0;
            const parentAspectRatio = this.rootDiv.clientWidth / this.rootDiv.clientHeight;
            const videoAspectRatio = this.freezeFrameWidth / this.freezeFrameHeight;
            if (parentAspectRatio < videoAspectRatio) {
                displayWidth = this.rootDiv.clientWidth;
                displayHeight = Math.floor(this.rootDiv.clientWidth / videoAspectRatio);
                displayTop = Math.floor((this.rootDiv.clientHeight - displayHeight) * 0.5);
                displayLeft = 0;
            }
            else {
                displayWidth = Math.floor(this.rootDiv.clientHeight * videoAspectRatio);
                displayHeight = this.rootDiv.clientHeight;
                displayTop = 0;
                displayLeft = Math.floor((this.rootDiv.clientWidth - displayWidth) * 0.5);
            }
            this.rootElement.style.width = this.rootDiv.offsetWidth + 'px';
            this.rootElement.style.height = this.rootDiv.offsetHeight + 'px';
            this.rootElement.style.left = 0 + 'px';
            this.rootElement.style.top = 0 + 'px';
            this.imageElement.style.width = displayWidth + 'px';
            this.imageElement.style.height = displayHeight + 'px';
            this.imageElement.style.left = displayLeft + 'px';
            this.imageElement.style.top = displayTop + 'px';
        }
    }
}
//# sourceMappingURL=FreezeFrame.js.map

/***/ }),

/***/ 742:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FreezeFrameController": () => (/* binding */ FreezeFrameController)
/* harmony export */ });
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7800);
/* harmony import */ var _FreezeFrame__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6462);
// Copyright Epic Games, Inc. All Rights Reserved.


/**
 * A class for controlling freeze frame functionality
 */
class FreezeFrameController {
    /**
     * Construct a freeze frame controller
     * @param rootDiv - the div that a freeze frame element will be injected into
     */
    constructor(rootDiv) {
        this.receiving = false;
        this.size = 0;
        this.jpeg = undefined;
        this.valid = false;
        this.freezeFrameDelay = 50;
        this.freezeFrame = new _FreezeFrame__WEBPACK_IMPORTED_MODULE_0__.FreezeFrame(rootDiv);
    }
    /**
     * Show the freeze frame if it is valid
     */
    showFreezeFrame() {
        if (this.valid) {
            this.freezeFrame.setElementForShow();
        }
    }
    /**
     * Hide the freeze frame and set the validity to false
     */
    hideFreezeFrame() {
        this.valid = false;
        this.freezeFrame.setElementForHide();
    }
    /**
     * Update the freeze frames image source and load it
     * @param jpeg - the freeze frame image as a byte array data
     * @param onLoadCallBack - a call back for managing if the play overlay needs to be shown or not
     */
    updateFreezeFrameAndShow(jpeg, onLoadCallBack) {
        this.freezeFrame.updateImageElementSource(jpeg);
        this.freezeFrame.imageElement.onload = () => {
            this.freezeFrame.setDimensionsFromElementAndResize();
            onLoadCallBack();
        };
    }
    /**
     * Process the new freeze frame image and update it
     * @param view - the freeze frame image as a byte array data
     * @param onLoadCallBack - a call back for managing if the play overlay needs to be shown or not
     */
    processFreezeFrameMessage(view, onLoadCallBack) {
        // Reset freeze frame if we got a freeze frame message and we are not "receiving" yet.
        if (!this.receiving) {
            this.receiving = true;
            this.valid = false;
            this.size = 0;
            this.jpeg = undefined;
        }
        // Extract total size of freeze frame (across all chunks)
        this.size = new DataView(view.slice(1, 5).buffer).getInt32(0, true);
        // Get the jpeg part of the payload
        const jpegBytes = view.slice(1 + 4);
        // Append to existing jpeg that holds the freeze frame
        if (this.jpeg) {
            const jpeg = new Uint8Array(this.jpeg.length + jpegBytes.length);
            jpeg.set(this.jpeg, 0);
            jpeg.set(jpegBytes, this.jpeg.length);
            this.jpeg = jpeg;
        }
        // No existing freeze frame jpeg, make one
        else {
            this.jpeg = jpegBytes;
            this.receiving = true;
            _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_1__.Logger.Info(`received first chunk of freeze frame: ${this.jpeg.length}/${this.size}`);
        }
        // Finished receiving freeze frame, we can show it now
        if (this.jpeg.length === this.size) {
            this.receiving = false;
            this.valid = true;
            _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_1__.Logger.Info(`received complete freeze frame ${this.size}`);
            this.updateFreezeFrameAndShow(this.jpeg, onLoadCallBack);
        }
        // We received more data than the freeze frame payload message indicate (this is an error)
        else if (this.jpeg.length > this.size) {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_1__.Logger.Error(`received bigger freeze frame than advertised: ${this.jpeg.length}/${this.size}`);
            this.jpeg = undefined;
            this.receiving = false;
        }
    }
}
//# sourceMappingURL=FreezeFrameController.js.map

/***/ }),

/***/ 9402:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "GamepadController": () => (/* binding */ GamepadController),
/* harmony export */   "GamepadLayout": () => (/* binding */ GamepadLayout)
/* harmony export */ });
/* harmony import */ var _GamepadTypes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4057);
// Copyright Epic Games, Inc. All Rights Reserved.

/**
 * Gamepad layout codes enum
 */
var GamepadLayout;
(function (GamepadLayout) {
    GamepadLayout[GamepadLayout["RightClusterBottomButton"] = 0] = "RightClusterBottomButton";
    GamepadLayout[GamepadLayout["RightClusterRightButton"] = 1] = "RightClusterRightButton";
    GamepadLayout[GamepadLayout["RightClusterLeftButton"] = 2] = "RightClusterLeftButton";
    GamepadLayout[GamepadLayout["RightClusterTopButton"] = 3] = "RightClusterTopButton";
    GamepadLayout[GamepadLayout["LeftShoulder"] = 4] = "LeftShoulder";
    GamepadLayout[GamepadLayout["RightShoulder"] = 5] = "RightShoulder";
    GamepadLayout[GamepadLayout["LeftTrigger"] = 6] = "LeftTrigger";
    GamepadLayout[GamepadLayout["RightTrigger"] = 7] = "RightTrigger";
    GamepadLayout[GamepadLayout["SelectOrBack"] = 8] = "SelectOrBack";
    GamepadLayout[GamepadLayout["StartOrForward"] = 9] = "StartOrForward";
    GamepadLayout[GamepadLayout["LeftAnalogPress"] = 10] = "LeftAnalogPress";
    GamepadLayout[GamepadLayout["RightAnalogPress"] = 11] = "RightAnalogPress";
    GamepadLayout[GamepadLayout["LeftClusterTopButton"] = 12] = "LeftClusterTopButton";
    GamepadLayout[GamepadLayout["LeftClusterBottomButton"] = 13] = "LeftClusterBottomButton";
    GamepadLayout[GamepadLayout["LeftClusterLeftButton"] = 14] = "LeftClusterLeftButton";
    GamepadLayout[GamepadLayout["LeftClusterRightButton"] = 15] = "LeftClusterRightButton";
    GamepadLayout[GamepadLayout["CentreButton"] = 16] = "CentreButton";
    // Axes
    GamepadLayout[GamepadLayout["LeftStickHorizontal"] = 0] = "LeftStickHorizontal";
    GamepadLayout[GamepadLayout["LeftStickVertical"] = 1] = "LeftStickVertical";
    GamepadLayout[GamepadLayout["RightStickHorizontal"] = 2] = "RightStickHorizontal";
    GamepadLayout[GamepadLayout["RightStickVertical"] = 3] = "RightStickVertical";
})(GamepadLayout || (GamepadLayout = {}));
/**
 * Handles gamepad events from the document to send to the streamer.
 */
class GamepadController {
    constructor(streamMessageController) {
        this.streamMessageController = streamMessageController;
        this.onGamepadConnectedListener = this.onGamepadConnected.bind(this);
        this.onGamepadDisconnectedListener = this.onGamepadDisconnected.bind(this);
        this.beforeUnloadListener = this.onBeforeUnload.bind(this);
        this.requestAnimationFrame = (window.mozRequestAnimationFrame ||
            window.webkitRequestAnimationFrame ||
            window.requestAnimationFrame).bind(window);
    }
    register() {
        window.addEventListener('beforeunload', this.beforeUnloadListener);
        const browserWindow = window;
        if ('GamepadEvent' in browserWindow) {
            window.addEventListener('gamepadconnected', this.onGamepadConnectedListener);
            window.addEventListener('gamepaddisconnected', this.onGamepadDisconnectedListener);
        }
        else if ('WebKitGamepadEvent' in browserWindow) {
            window.addEventListener('webkitgamepadconnected', this.onGamepadConnectedListener);
            window.addEventListener('webkitgamepaddisconnected', this.onGamepadDisconnectedListener);
        }
        this.controllers = [];
        if (navigator.getGamepads) {
            for (const gamepad of navigator.getGamepads()) {
                if (gamepad) {
                    this.onGamepadConnected(new GamepadEvent('gamepadconnected', { gamepad }));
                }
            }
        }
    }
    unregister() {
        window.removeEventListener('gamepadconnected', this.onGamepadConnectedListener);
        window.removeEventListener('gamepaddisconnected', this.onGamepadDisconnectedListener);
        window.removeEventListener('webkitgamepadconnected', this.onGamepadConnectedListener);
        window.removeEventListener('webkitgamepaddisconnected', this.onGamepadDisconnectedListener);
        for (const controller of this.controllers) {
            if (controller && controller.id !== undefined) {
                this.streamMessageController.toStreamerHandlers.get('GamepadDisconnected')([controller.id]);
            }
        }
        this.controllers = [];
    }
    onGamepadResponseReceived(gamepadId) {
        for (const controller of this.controllers) {
            if (controller && controller.id === undefined) {
                controller.id = gamepadId;
                break;
            }
        }
    }
    onGamepadConnected(event) {
        const gamepad = event.gamepad;
        const newController = {
            currentState: (0,_GamepadTypes__WEBPACK_IMPORTED_MODULE_0__.deepCopyGamepad)(gamepad),
            prevState: (0,_GamepadTypes__WEBPACK_IMPORTED_MODULE_0__.deepCopyGamepad)(gamepad),
            id: undefined
        };
        this.controllers[gamepad.index] = newController;
        window.requestAnimationFrame(() => this.updateStatus());
        this.streamMessageController.toStreamerHandlers.get('GamepadConnected')();
    }
    onGamepadDisconnected(event) {
        const gamepad = event.gamepad;
        const deletedController = this.controllers[gamepad.index];
        delete this.controllers[gamepad.index];
        this.controllers = this.controllers.filter((controller) => controller !== undefined);
        if (deletedController.id !== undefined) {
            this.streamMessageController.toStreamerHandlers.get('GamepadDisconnected')([
                deletedController.id
            ]);
        }
    }
    scanGamepads() {
        const gamepads = navigator.getGamepads
            ? navigator.getGamepads()
            : navigator.webkitGetGamepads
                ? navigator.webkitGetGamepads()
                : [];
        for (let i = 0; i < gamepads.length; i++) {
            if (gamepads[i] && this.controllers[gamepads[i].index] !== undefined) {
                this.controllers[gamepads[i].index].currentState = gamepads[i];
            }
        }
    }
    updateStatus() {
        this.scanGamepads();
        const toStreamerHandlers = this.streamMessageController.toStreamerHandlers;
        // Iterate over multiple controllers in the case the multiple gamepads are connected
        for (const controller of this.controllers) {
            if (!controller) {
                continue;
            }
            // If we haven't received an id (possible if using an older version of UE), return to original functionality
            const controllerId = controller.id === undefined ? this.controllers.indexOf(controller) : controller.id;
            const currentState = controller.currentState;
            for (let i = 0; i < controller.currentState.buttons.length; i++) {
                const currentButton = controller.currentState.buttons[i];
                const previousButton = controller.prevState.buttons[i];
                if (currentButton.pressed) {
                    // press
                    if (i == GamepadLayout.LeftTrigger) {
                        // UEs left analog has a button index of 5
                        toStreamerHandlers.get('GamepadAnalog')([controllerId, 5, currentButton.value]);
                    }
                    else if (i == GamepadLayout.RightTrigger) {
                        // UEs right analog has a button index of 6
                        toStreamerHandlers.get('GamepadAnalog')([controllerId, 6, currentButton.value]);
                    }
                    else {
                        toStreamerHandlers.get('GamepadButtonPressed')([
                            controllerId,
                            i,
                            previousButton.pressed ? 1 : 0
                        ]);
                    }
                }
                else if (!currentButton.pressed && previousButton.pressed) {
                    // release
                    if (i == GamepadLayout.LeftTrigger) {
                        // UEs left analog has a button index of 5
                        toStreamerHandlers.get('GamepadAnalog')([controllerId, 5, 0]);
                    }
                    else if (i == GamepadLayout.RightTrigger) {
                        // UEs right analog has a button index of 6
                        toStreamerHandlers.get('GamepadAnalog')([controllerId, 6, 0]);
                    }
                    else {
                        toStreamerHandlers.get('GamepadButtonReleased')([controllerId, i, 0]);
                    }
                }
            }
            // Iterate over gamepad axes (we will increment in lots of 2 as there is 2 axes per stick)
            for (let i = 0; i < currentState.axes.length; i += 2) {
                // Horizontal axes are even numbered
                const x = parseFloat(currentState.axes[i].toFixed(4));
                // Vertical axes are odd numbered
                // https://w3c.github.io/gamepad/#remapping Gamepad browser side standard mapping has positive down, negative up. This is downright disgusting. So we fix it.
                const y = -parseFloat(currentState.axes[i + 1].toFixed(4));
                // UE's analog axes follow the same order as the browsers, but start at index 1 so we will offset as such
                toStreamerHandlers.get('GamepadAnalog')([controllerId, i + 1, x]); // Horizontal axes, only offset by 1
                toStreamerHandlers.get('GamepadAnalog')([controllerId, i + 2, y]); // Vertical axes, offset by two (1 to match UEs axes convention and then another 1 for the vertical axes)
            }
            const controllerIndex = this.controllers.indexOf(controller);
            this.controllers[controllerIndex].prevState = (0,_GamepadTypes__WEBPACK_IMPORTED_MODULE_0__.deepCopyGamepad)(currentState);
        }
        if (this.controllers.length > 0) {
            this.requestAnimationFrame(() => this.updateStatus());
        }
    }
    onBeforeUnload(_) {
        // When a user navigates away from the page, we need to inform UE of all the disconnecting
        // controllers
        for (const controller of this.controllers) {
            if (!controller || controller.id === undefined) {
                continue;
            }
            this.streamMessageController.toStreamerHandlers.get('GamepadDisconnected')([controller.id]);
        }
    }
}
//# sourceMappingURL=GamepadController.js.map

/***/ }),

/***/ 4057:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "deepCopyGamepad": () => (/* binding */ deepCopyGamepad)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
/**
 * Deep copies the values from a gamepad by first converting it to a JSON object and then back to a gamepad
 *
 * @param gamepad the original gamepad
 * @returns a new gamepad object, populated with the original gamepads values
 */
function deepCopyGamepad(gamepad) {
    return JSON.parse(JSON.stringify({
        buttons: gamepad.buttons.map((b) => JSON.parse(JSON.stringify({
            pressed: b.pressed,
            touched: b.touched,
            value: b.value
        }))),
        axes: gamepad.axes
    }));
}
//# sourceMappingURL=GamepadTypes.js.map

/***/ }),

/***/ 1523:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ActiveKeys": () => (/* binding */ ActiveKeys),
/* harmony export */   "InputClassesFactory": () => (/* binding */ InputClassesFactory)
/* harmony export */ });
/* harmony import */ var _KeyboardController__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6066);
/* harmony import */ var _MouseControllerLocked__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(2395);
/* harmony import */ var _MouseControllerHovering__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(3748);
/* harmony import */ var _TouchController__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(9907);
/* harmony import */ var _TouchControllerFake__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(5788);
/* harmony import */ var _GamepadController__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(9402);
/* harmony import */ var _Config_Config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7463);
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7800);
// Copyright Epic Games, Inc. All Rights Reserved.








/**
 * Class for making and setting up input class types
 */
class InputClassesFactory {
    /**
     * @param toStreamerMessagesProvider - Stream message instance
     * @param videoElementProvider - Video Player instance
     * @param coordinateConverter - A coordinateConverter instance
     */
    constructor(toStreamerMessagesProvider, videoElementProvider, coordinateConverter) {
        this.activeKeys = new ActiveKeys();
        this.toStreamerMessagesProvider = toStreamerMessagesProvider;
        this.videoElementProvider = videoElementProvider;
        this.coordinateConverter = coordinateConverter;
    }
    /**
     * Registers browser key events.
     */
    registerKeyBoard(config) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_0__.Logger.Info('Register Keyboard Events');
        const keyboardController = new _KeyboardController__WEBPACK_IMPORTED_MODULE_1__.KeyboardController(this.toStreamerMessagesProvider, config, this.activeKeys);
        keyboardController.register();
        return keyboardController;
    }
    /**
     * register mouse events based on a control type
     * @param controlScheme - if the mouse is either hovering or locked
     */
    registerMouse(controlScheme) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_0__.Logger.Info('Register Mouse Events');
        let mouseController;
        if (controlScheme == _Config_Config__WEBPACK_IMPORTED_MODULE_2__.ControlSchemeType.HoveringMouse) {
            mouseController = new _MouseControllerHovering__WEBPACK_IMPORTED_MODULE_3__.MouseControllerHovering(this.toStreamerMessagesProvider, this.videoElementProvider, this.coordinateConverter, this.activeKeys);
        }
        else {
            mouseController = new _MouseControllerLocked__WEBPACK_IMPORTED_MODULE_4__.MouseControllerLocked(this.toStreamerMessagesProvider, this.videoElementProvider, this.coordinateConverter, this.activeKeys);
        }
        mouseController.register();
        return mouseController;
    }
    /**
     * register touch events
     * @param fakeMouseTouch - the faked mouse touch event
     */
    registerTouch(fakeMouseTouch) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_0__.Logger.Info('Registering Touch');
        let touchController;
        if (fakeMouseTouch) {
            touchController = new _TouchControllerFake__WEBPACK_IMPORTED_MODULE_5__.TouchControllerFake(this.toStreamerMessagesProvider, this.videoElementProvider, this.coordinateConverter);
        }
        else {
            touchController = new _TouchController__WEBPACK_IMPORTED_MODULE_6__.TouchController(this.toStreamerMessagesProvider, this.videoElementProvider, this.coordinateConverter);
        }
        touchController.register();
        return touchController;
    }
    /**
     * registers a gamepad
     */
    registerGamePad() {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_0__.Logger.Info('Register Game Pad');
        const gamepadController = new _GamepadController__WEBPACK_IMPORTED_MODULE_7__.GamepadController(this.toStreamerMessagesProvider);
        gamepadController.register();
        return gamepadController;
    }
}
/**
 * A class that keeps track of current active keys
 */
class ActiveKeys {
    constructor() {
        this.activeKeys = [];
        this.activeKeys = [];
    }
    /**
     * Get the current array of active keys
     * @returns - an array of active keys
     */
    getActiveKeys() {
        return this.activeKeys;
    }
}
//# sourceMappingURL=InputClassesFactory.js.map

/***/ }),

/***/ 7692:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CodeToKeyCode": () => (/* binding */ CodeToKeyCode)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
/*
 * New browser APIs have moved away from KeyboardEvent.keyCode to KeyboardEvent.Code.
 * For details see: https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/keyCode#constants_for_keycode_value
 * We still use old KeyboardEvent.keyCode integers in the UE C++ side, so we need a way to map the new
 * string-based KeyboardEvent.Code to the old integers.
 */
const CodeToKeyCode = Object.freeze({
    Escape: 27,
    Digit0: 48,
    Digit1: 49,
    Digit2: 50,
    Digit3: 51,
    Digit4: 52,
    Digit5: 53,
    Digit6: 54,
    Digit7: 55,
    Digit8: 56,
    Digit9: 57,
    Minus: 173,
    Equal: 187,
    Backspace: 8,
    Tab: 9,
    KeyQ: 81,
    KeyW: 87,
    KeyE: 69,
    KeyR: 82,
    KeyT: 84,
    KeyY: 89,
    KeyU: 85,
    KeyI: 73,
    KeyO: 79,
    KeyP: 80,
    BracketLeft: 219,
    BracketRight: 221,
    Enter: 13,
    ControlLeft: 17,
    KeyA: 65,
    KeyS: 83,
    KeyD: 68,
    KeyF: 70,
    KeyG: 71,
    KeyH: 72,
    KeyJ: 74,
    KeyK: 75,
    KeyL: 76,
    Semicolon: 186,
    Quote: 222,
    Backquote: 192,
    ShiftLeft: 16,
    Backslash: 220,
    KeyZ: 90,
    KeyX: 88,
    KeyC: 67,
    KeyV: 86,
    KeyB: 66,
    KeyN: 78,
    KeyM: 77,
    Comma: 188,
    Period: 190,
    Slash: 191,
    ShiftRight: 253,
    AltLeft: 18,
    Space: 32,
    CapsLock: 20,
    F1: 112,
    F2: 113,
    F3: 114,
    F4: 115,
    F5: 116,
    F6: 117,
    F7: 118,
    F8: 119,
    F9: 120,
    F10: 121,
    F11: 122,
    F12: 123,
    Pause: 19,
    ScrollLock: 145,
    NumpadDivide: 111,
    NumpadMultiply: 106,
    NumpadSubtract: 109,
    NumpadAdd: 107,
    NumpadDecimal: 110,
    Numpad9: 105,
    Numpad8: 104,
    Numpad7: 103,
    Numpad6: 102,
    Numpad5: 101,
    Numpad4: 100,
    Numpad3: 99,
    Numpad2: 98,
    Numpad1: 97,
    Numpad0: 96,
    NumLock: 144,
    ControlRight: 254,
    AltRight: 255,
    Home: 36,
    End: 35,
    ArrowUp: 38,
    ArrowLeft: 37,
    ArrowRight: 39,
    ArrowDown: 40,
    PageUp: 33,
    PageDown: 34,
    Insert: 45,
    Delete: 46,
    ContextMenu: 93
});
//# sourceMappingURL=KeyCodes.js.map

/***/ }),

/***/ 6066:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "KeyboardController": () => (/* binding */ KeyboardController)
/* harmony export */ });
/* harmony import */ var _SpecialKeyCodes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7269);
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(7800);
/* harmony import */ var _Config_Config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7463);
/* harmony import */ var _KeyCodes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7692);
// Copyright Epic Games, Inc. All Rights Reserved.




/**
 * Handles the Keyboard Inputs for the document
 */
class KeyboardController {
    constructor(streamMessageController, config, activeKeys) {
        this.streamMessageController = streamMessageController;
        this.config = config;
        this.activeKeys = activeKeys;
        this.onKeyDownListener = this.handleOnKeyDown.bind(this);
        this.onKeyUpListener = this.handleOnKeyUp.bind(this);
        this.onKeyPressListener = this.handleOnKeyPress.bind(this);
    }
    register() {
        document.addEventListener('keydown', this.onKeyDownListener);
        document.addEventListener('keyup', this.onKeyUpListener);
        //This has been deprecated as at Jun 13 2021
        document.addEventListener('keypress', this.onKeyPressListener);
    }
    unregister() {
        document.removeEventListener('keydown', this.onKeyDownListener);
        document.removeEventListener('keyup', this.onKeyUpListener);
        document.removeEventListener('keypress', this.onKeyPressListener);
    }
    handleOnKeyDown(keyboardEvent) {
        var _a;
        const keyCode = this.getKeycode(keyboardEvent);
        if (!keyCode || keyCode === 229) {
            return;
        }
        const toStreamerHandlers = this.streamMessageController.toStreamerHandlers;
        (_a = toStreamerHandlers.get('KeyDown')) === null || _a === void 0 ? void 0 : _a([this.getKeycode(keyboardEvent), keyboardEvent.repeat ? 1 : 0]);
        const activeKeys = this.activeKeys.getActiveKeys();
        activeKeys.push(keyCode);
        // Backspace is not considered a keypress in JavaScript but we need it
        // to be so characters may be deleted in a UE text entry field.
        // since keypress is deprecated we really should be sending all keys to keypress
        // or we change everything to handle the deprecation of these parts
        if (keyCode === _SpecialKeyCodes__WEBPACK_IMPORTED_MODULE_0__.SpecialKeyCodes.backSpace) {
            this.handleOnKeyPress(new KeyboardEvent('keypress', {
                charCode: _SpecialKeyCodes__WEBPACK_IMPORTED_MODULE_0__.SpecialKeyCodes.backSpace,
                keyCode: _SpecialKeyCodes__WEBPACK_IMPORTED_MODULE_0__.SpecialKeyCodes.backSpace
            }));
        }
        if (this.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_1__.Flags.SuppressBrowserKeys) && this.isKeyCodeBrowserKey(keyCode)) {
            keyboardEvent.preventDefault();
        }
    }
    handleOnKeyUp(keyboardEvent) {
        var _a;
        const keyCode = this.getKeycode(keyboardEvent);
        if (!keyCode) {
            return;
        }
        const toStreamerHandlers = this.streamMessageController.toStreamerHandlers;
        (_a = toStreamerHandlers.get('KeyUp')) === null || _a === void 0 ? void 0 : _a([keyCode]);
        if (this.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_1__.Flags.SuppressBrowserKeys) && this.isKeyCodeBrowserKey(keyCode)) {
            keyboardEvent.preventDefault();
        }
    }
    handleOnKeyPress(keyboardEvent) {
        var _a;
        const keyCode = this.getKeycode(keyboardEvent);
        if (!keyCode) {
            return;
        }
        const toStreamerHandlers = this.streamMessageController.toStreamerHandlers;
        (_a = toStreamerHandlers.get('KeyPress')) === null || _a === void 0 ? void 0 : _a([keyCode]);
    }
    /**
     * Gets the Keycode of the Key pressed
     * @param keyboardEvent - Key board Event
     * @returns - the key code of the Key
     */
    getKeycode(keyboardEvent) {
        // If we don't have keyCode property because browser API is deprecated then use KeyboardEvent.code instead.
        // See: https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/keyCode#constants_for_keycode_value
        if (!('keyCode' in keyboardEvent)) {
            // this type assertion here is required because if 'keyCode' doesnt exist in keyboardEvent then
            // it cannot be a KeyboardEvent and so it gets narrowed to 'never'
            const event = keyboardEvent;
            // Convert KeyboardEvent.code string into integer-based key code for backwards compatibility reasons.
            if (event.code in _KeyCodes__WEBPACK_IMPORTED_MODULE_2__.CodeToKeyCode) {
                return _KeyCodes__WEBPACK_IMPORTED_MODULE_2__.CodeToKeyCode[event.code];
            }
            else {
                _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_3__.Logger.Warning(`Keyboard code of ${event.code} is not supported in our mapping, ignoring this key.`);
                return null;
            }
        }
        // If we made it here KeyboardEvent.keyCode is still supported so we can safely use it.
        if (keyboardEvent.keyCode === _SpecialKeyCodes__WEBPACK_IMPORTED_MODULE_0__.SpecialKeyCodes.shift && keyboardEvent.code === 'ShiftRight') {
            return _SpecialKeyCodes__WEBPACK_IMPORTED_MODULE_0__.SpecialKeyCodes.rightShift;
        }
        else if (keyboardEvent.keyCode === _SpecialKeyCodes__WEBPACK_IMPORTED_MODULE_0__.SpecialKeyCodes.control &&
            keyboardEvent.code === 'ControlRight') {
            return _SpecialKeyCodes__WEBPACK_IMPORTED_MODULE_0__.SpecialKeyCodes.rightControl;
        }
        else if (keyboardEvent.keyCode === _SpecialKeyCodes__WEBPACK_IMPORTED_MODULE_0__.SpecialKeyCodes.alt && keyboardEvent.code === 'AltRight') {
            return _SpecialKeyCodes__WEBPACK_IMPORTED_MODULE_0__.SpecialKeyCodes.rightAlt;
        }
        else {
            return keyboardEvent.keyCode;
        }
    }
    /**
     * Browser keys do not have a charCode so we only need to test keyCode.
     * @param keyCode - the browser keycode number
     */
    isKeyCodeBrowserKey(keyCode) {
        // Function keys or tab key are considered "browser keys" that we may wish to suppress by preventing them being process by browser.
        return (keyCode >= 112 && keyCode <= 123) || keyCode === 9;
    }
}
//# sourceMappingURL=KeyboardController.js.map

/***/ }),

/***/ 1368:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MouseButton": () => (/* binding */ MouseButton),
/* harmony export */   "MouseButtonsMask": () => (/* binding */ MouseButtonsMask)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
/**
 * Mouse Button Data
 * {@link https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button}
 */
class MouseButton {
}
MouseButton.mainButton = 0; // Left button.
MouseButton.auxiliaryButton = 1; // Wheel button.
MouseButton.secondaryButton = 2; // Right button.
MouseButton.fourthButton = 3; // Browser Back button.
MouseButton.fifthButton = 4; // Browser Forward button.
/**
 * Mouse Button Mask Data
 * {@link https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons}
 */
class MouseButtonsMask {
}
MouseButtonsMask.primaryButton = 1; // Left button.
MouseButtonsMask.secondaryButton = 2; // Right button.
MouseButtonsMask.auxiliaryButton = 4; // Wheel button.
MouseButtonsMask.fourthButton = 8; // Browser Back button.
MouseButtonsMask.fifthButton = 16; // Browser Forward button.
//# sourceMappingURL=MouseButtons.js.map

/***/ }),

/***/ 4639:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MouseController": () => (/* binding */ MouseController)
/* harmony export */ });
/* harmony import */ var _MouseButtons__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1368);
// Copyright Epic Games, Inc. All Rights Reserved.

/**
 * The base class for mouse controllers. Since there is a bunch of shared behaviour between locked and
 * hover mouse controllers this is where that shared behaviour lives.
 */
class MouseController {
    constructor(streamMessageController, videoPlayer, coordinateConverter, activeKeys) {
        this.streamMessageController = streamMessageController;
        this.coordinateConverter = coordinateConverter;
        this.videoPlayer = videoPlayer;
        this.activeKeys = activeKeys;
        this.onEnterListener = this.onMouseEnter.bind(this);
        this.onLeaveListener = this.onMouseLeave.bind(this);
    }
    register() {
        this.registerMouseEnterAndLeaveEvents();
    }
    unregister() {
        this.unregisterMouseEnterAndLeaveEvents();
    }
    registerMouseEnterAndLeaveEvents() {
        const videoElementParent = this.videoPlayer.getVideoParentElement();
        videoElementParent === null || videoElementParent === void 0 ? void 0 : videoElementParent.addEventListener('mouseenter', this.onEnterListener);
        videoElementParent === null || videoElementParent === void 0 ? void 0 : videoElementParent.addEventListener('mouseleave', this.onLeaveListener);
    }
    unregisterMouseEnterAndLeaveEvents() {
        const videoElementParent = this.videoPlayer.getVideoParentElement();
        videoElementParent === null || videoElementParent === void 0 ? void 0 : videoElementParent.removeEventListener('mouseenter', this.onEnterListener);
        videoElementParent === null || videoElementParent === void 0 ? void 0 : videoElementParent.removeEventListener('mouseleave', this.onLeaveListener);
    }
    onMouseEnter(event) {
        var _a;
        if (!this.videoPlayer.isVideoReady()) {
            return;
        }
        (_a = this.streamMessageController.toStreamerHandlers.get('MouseEnter')) === null || _a === void 0 ? void 0 : _a();
        this.pressMouseButtons(event.buttons, event.x, event.y);
    }
    onMouseLeave(event) {
        var _a;
        if (!this.videoPlayer.isVideoReady()) {
            return;
        }
        (_a = this.streamMessageController.toStreamerHandlers.get('MouseLeave')) === null || _a === void 0 ? void 0 : _a();
        this.releaseMouseButtons(event.buttons, event.x, event.y);
    }
    releaseMouseButtons(buttons, X, Y) {
        const coord = this.coordinateConverter.translateUnsigned(X, Y);
        if (buttons & _MouseButtons__WEBPACK_IMPORTED_MODULE_0__.MouseButtonsMask.primaryButton) {
            this.sendMouseUp(_MouseButtons__WEBPACK_IMPORTED_MODULE_0__.MouseButton.mainButton, coord.x, coord.y);
        }
        if (buttons & _MouseButtons__WEBPACK_IMPORTED_MODULE_0__.MouseButtonsMask.secondaryButton) {
            this.sendMouseUp(_MouseButtons__WEBPACK_IMPORTED_MODULE_0__.MouseButton.secondaryButton, coord.x, coord.y);
        }
        if (buttons & _MouseButtons__WEBPACK_IMPORTED_MODULE_0__.MouseButtonsMask.auxiliaryButton) {
            this.sendMouseUp(_MouseButtons__WEBPACK_IMPORTED_MODULE_0__.MouseButton.auxiliaryButton, coord.x, coord.y);
        }
        if (buttons & _MouseButtons__WEBPACK_IMPORTED_MODULE_0__.MouseButtonsMask.fourthButton) {
            this.sendMouseUp(_MouseButtons__WEBPACK_IMPORTED_MODULE_0__.MouseButton.fourthButton, coord.x, coord.y);
        }
        if (buttons & _MouseButtons__WEBPACK_IMPORTED_MODULE_0__.MouseButtonsMask.fifthButton) {
            this.sendMouseUp(_MouseButtons__WEBPACK_IMPORTED_MODULE_0__.MouseButton.fifthButton, coord.x, coord.y);
        }
    }
    pressMouseButtons(buttons, X, Y) {
        if (!this.videoPlayer.isVideoReady()) {
            return;
        }
        const coord = this.coordinateConverter.translateUnsigned(X, Y);
        if (buttons & _MouseButtons__WEBPACK_IMPORTED_MODULE_0__.MouseButtonsMask.primaryButton) {
            this.sendMouseDown(_MouseButtons__WEBPACK_IMPORTED_MODULE_0__.MouseButton.mainButton, coord.x, coord.y);
        }
        if (buttons & _MouseButtons__WEBPACK_IMPORTED_MODULE_0__.MouseButtonsMask.secondaryButton) {
            this.sendMouseDown(_MouseButtons__WEBPACK_IMPORTED_MODULE_0__.MouseButton.secondaryButton, coord.x, coord.y);
        }
        if (buttons & _MouseButtons__WEBPACK_IMPORTED_MODULE_0__.MouseButtonsMask.auxiliaryButton) {
            this.sendMouseDown(_MouseButtons__WEBPACK_IMPORTED_MODULE_0__.MouseButton.auxiliaryButton, coord.x, coord.y);
        }
        if (buttons & _MouseButtons__WEBPACK_IMPORTED_MODULE_0__.MouseButtonsMask.fourthButton) {
            this.sendMouseDown(_MouseButtons__WEBPACK_IMPORTED_MODULE_0__.MouseButton.fourthButton, coord.x, coord.y);
        }
        if (buttons & _MouseButtons__WEBPACK_IMPORTED_MODULE_0__.MouseButtonsMask.fifthButton) {
            this.sendMouseDown(_MouseButtons__WEBPACK_IMPORTED_MODULE_0__.MouseButton.fifthButton, coord.x, coord.y);
        }
    }
    sendMouseDown(button, X, Y) {
        var _a;
        (_a = this.streamMessageController.toStreamerHandlers.get('MouseDown')) === null || _a === void 0 ? void 0 : _a([button, X, Y]);
    }
    sendMouseUp(button, X, Y) {
        var _a;
        const coord = this.coordinateConverter.translateUnsigned(X, Y);
        (_a = this.streamMessageController.toStreamerHandlers.get('MouseUp')) === null || _a === void 0 ? void 0 : _a([button, coord.x, coord.y]);
    }
}
//# sourceMappingURL=MouseController.js.map

/***/ }),

/***/ 3748:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MouseControllerHovering": () => (/* binding */ MouseControllerHovering)
/* harmony export */ });
/* harmony import */ var _MouseController__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4639);

/**
 * A mouse controller that allows the mouse to freely float over the video document.
 */
class MouseControllerHovering extends _MouseController__WEBPACK_IMPORTED_MODULE_0__.MouseController {
    constructor(streamMessageController, videoPlayer, coordinateConverter, activeKeys) {
        super(streamMessageController, videoPlayer, coordinateConverter, activeKeys);
        this.videoElementParent = videoPlayer.getVideoParentElement();
        this.onMouseUpListener = this.onMouseUp.bind(this);
        this.onMouseDownListener = this.onMouseDown.bind(this);
        this.onMouseDblClickListener = this.onMouseDblClick.bind(this);
        this.onMouseWheelListener = this.onMouseWheel.bind(this);
        this.onMouseMoveListener = this.onMouseMove.bind(this);
        this.onContextMenuListener = this.onContextMenu.bind(this);
    }
    register() {
        super.register();
        this.videoElementParent.addEventListener('mousemove', this.onMouseMoveListener);
        this.videoElementParent.addEventListener('mousedown', this.onMouseDownListener);
        this.videoElementParent.addEventListener('mouseup', this.onMouseUpListener);
        this.videoElementParent.addEventListener('contextmenu', this.onContextMenuListener);
        this.videoElementParent.addEventListener('wheel', this.onMouseWheelListener);
        this.videoElementParent.addEventListener('dblclick', this.onMouseDblClickListener);
    }
    unregister() {
        this.videoElementParent.removeEventListener('mousemove', this.onMouseMoveListener);
        this.videoElementParent.removeEventListener('mousedown', this.onMouseDownListener);
        this.videoElementParent.removeEventListener('mouseup', this.onMouseUpListener);
        this.videoElementParent.removeEventListener('contextmenu', this.onContextMenuListener);
        this.videoElementParent.removeEventListener('wheel', this.onMouseWheelListener);
        this.videoElementParent.removeEventListener('dblclick', this.onMouseDblClickListener);
        super.unregister();
    }
    onMouseDown(event) {
        if (!this.videoPlayer.isVideoReady()) {
            return;
        }
        const coord = this.coordinateConverter.translateUnsigned(event.offsetX, event.offsetY);
        this.streamMessageController.toStreamerHandlers.get('MouseDown')([event.button, coord.x, coord.y]);
        event.preventDefault();
    }
    onMouseUp(event) {
        if (!this.videoPlayer.isVideoReady()) {
            return;
        }
        const coord = this.coordinateConverter.translateUnsigned(event.offsetX, event.offsetY);
        this.streamMessageController.toStreamerHandlers.get('MouseUp')([event.button, coord.x, coord.y]);
        event.preventDefault();
    }
    onContextMenu(event) {
        if (!this.videoPlayer.isVideoReady()) {
            return;
        }
        event.preventDefault();
    }
    onMouseMove(event) {
        if (!this.videoPlayer.isVideoReady()) {
            return;
        }
        const coord = this.coordinateConverter.translateUnsigned(event.offsetX, event.offsetY);
        const delta = this.coordinateConverter.translateSigned(event.movementX, event.movementY);
        this.streamMessageController.toStreamerHandlers.get('MouseMove')([
            coord.x,
            coord.y,
            delta.x,
            delta.y
        ]);
        event.preventDefault();
    }
    onMouseWheel(event) {
        if (!this.videoPlayer.isVideoReady()) {
            return;
        }
        const coord = this.coordinateConverter.translateUnsigned(event.offsetX, event.offsetY);
        this.streamMessageController.toStreamerHandlers.get('MouseWheel')([
            event.wheelDelta,
            coord.x,
            coord.y
        ]);
        event.preventDefault();
    }
    onMouseDblClick(event) {
        if (!this.videoPlayer.isVideoReady()) {
            return;
        }
        const coord = this.coordinateConverter.translateUnsigned(event.offsetX, event.offsetY);
        this.streamMessageController.toStreamerHandlers.get('MouseDouble')([event.button, coord.x, coord.y]);
    }
}
//# sourceMappingURL=MouseControllerHovering.js.map

/***/ }),

/***/ 2395:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MouseControllerLocked": () => (/* binding */ MouseControllerLocked)
/* harmony export */ });
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7800);
/* harmony import */ var _MouseController__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4639);
// Copyright Epic Games, Inc. All Rights Reserved.


/**
 * A mouse controller that locks the mouse to the video document and prevents it from leaving the window
 */
class MouseControllerLocked extends _MouseController__WEBPACK_IMPORTED_MODULE_0__.MouseController {
    constructor(streamMessageController, videoPlayer, coordinateConverter, activeKeys) {
        super(streamMessageController, videoPlayer, coordinateConverter, activeKeys);
        this.videoElementParent = videoPlayer.getVideoParentElement();
        this.x = this.videoElementParent.getBoundingClientRect().width / 2;
        this.y = this.videoElementParent.getBoundingClientRect().height / 2;
        this.normalizedCoord = this.coordinateConverter.translateUnsigned(this.x, this.y);
        this.onRequestLockListener = this.onRequestLock.bind(this);
        this.onLockStateChangeListener = this.onLockStateChange.bind(this);
        this.onMouseUpListener = this.onMouseUp.bind(this);
        this.onMouseDownListener = this.onMouseDown.bind(this);
        this.onMouseDblClickListener = this.onMouseDblClick.bind(this);
        this.onMouseWheelListener = this.onMouseWheel.bind(this);
        this.onMouseMoveListener = this.onMouseMove.bind(this);
    }
    register() {
        super.register();
        this.videoElementParent.requestPointerLock =
            this.videoElementParent.requestPointerLock || this.videoElementParent.mozRequestPointerLock;
        document.exitPointerLock = document.exitPointerLock || document.mozExitPointerLock;
        if (this.videoElementParent.requestPointerLock) {
            this.videoElementParent.addEventListener('click', this.onRequestLockListener);
        }
        document.addEventListener('pointerlockchange', this.onLockStateChangeListener);
        document.addEventListener('mozpointerlockchange', this.onLockStateChangeListener);
        this.videoElementParent.addEventListener('mousedown', this.onMouseDownListener);
        this.videoElementParent.addEventListener('mouseup', this.onMouseUpListener);
        this.videoElementParent.addEventListener('wheel', this.onMouseWheelListener);
        this.videoElementParent.addEventListener('dblclick', this.onMouseDblClickListener);
    }
    unregister() {
        const pointerLockElement = document.pointerLockElement || document.mozPointerLockElement;
        if (document.exitPointerLock && pointerLockElement === this.videoElementParent) {
            document.exitPointerLock();
        }
        this.videoElementParent.removeEventListener('click', this.onRequestLockListener);
        document.removeEventListener('pointerlockchange', this.onLockStateChangeListener);
        document.removeEventListener('mozpointerlockchange', this.onLockStateChangeListener);
        document.removeEventListener('mousemove', this.onMouseMoveListener);
        this.videoElementParent.removeEventListener('mousedown', this.onMouseDownListener);
        this.videoElementParent.removeEventListener('mouseup', this.onMouseUpListener);
        this.videoElementParent.removeEventListener('wheel', this.onMouseWheelListener);
        this.videoElementParent.removeEventListener('dblclick', this.onMouseDblClickListener);
        super.unregister();
    }
    onRequestLock() {
        this.videoElementParent.requestPointerLock();
    }
    onLockStateChange() {
        const pointerLockElement = document.pointerLockElement || document.mozPointerLockElement;
        if (pointerLockElement === this.videoElementParent) {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_1__.Logger.Info('Pointer locked');
            document.addEventListener('mousemove', this.onMouseMoveListener);
        }
        else {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_1__.Logger.Info('The pointer lock status is now unlocked');
            document.removeEventListener('mousemove', this.onMouseMoveListener);
            // If mouse loses focus, send a key up for all of the currently held-down keys
            // This is necessary as when the mouse loses focus, the windows stops listening for events and as such
            // the keyup listener won't get fired
            const activeKeys = this.activeKeys.getActiveKeys();
            activeKeys.forEach((key) => {
                this.streamMessageController.toStreamerHandlers.get('KeyUp')([key]);
            });
        }
    }
    onMouseDown(event) {
        if (!this.videoPlayer.isVideoReady()) {
            return;
        }
        this.streamMessageController.toStreamerHandlers.get('MouseDown')([
            event.button,
            // We use the store value of this.coord as opposed to the mouseEvent.x/y as the mouseEvent location
            // uses the system cursor location which hasn't moved
            this.normalizedCoord.x,
            this.normalizedCoord.y
        ]);
    }
    onMouseUp(event) {
        if (!this.videoPlayer.isVideoReady()) {
            return;
        }
        this.streamMessageController.toStreamerHandlers.get('MouseUp')([
            event.button,
            // We use the store value of this.coord as opposed to the mouseEvent.x/y as the mouseEvent location
            // uses the system cursor location which hasn't moved
            this.normalizedCoord.x,
            this.normalizedCoord.y
        ]);
    }
    onMouseMove(event) {
        if (!this.videoPlayer.isVideoReady()) {
            return;
        }
        const styleWidth = this.videoPlayer.getVideoParentElement().clientWidth;
        const styleHeight = this.videoPlayer.getVideoParentElement().clientHeight;
        this.x += event.movementX;
        this.y += event.movementY;
        while (this.x > styleWidth) {
            this.x -= styleWidth;
        }
        while (this.y > styleHeight) {
            this.y -= styleHeight;
        }
        while (this.x < 0) {
            this.x += styleWidth;
        }
        while (this.y < 0) {
            this.y += styleHeight;
        }
        this.normalizedCoord = this.coordinateConverter.translateUnsigned(this.x, this.y);
        const delta = this.coordinateConverter.translateSigned(event.movementX, event.movementY);
        this.streamMessageController.toStreamerHandlers.get('MouseMove')([
            this.normalizedCoord.x,
            this.normalizedCoord.y,
            delta.x,
            delta.y
        ]);
    }
    onMouseWheel(event) {
        if (!this.videoPlayer.isVideoReady()) {
            return;
        }
        this.streamMessageController.toStreamerHandlers.get('MouseWheel')([
            event.wheelDelta,
            // We use the store value of this.coord as opposed to the mouseEvent.x/y as the mouseEvent location
            // uses the system cursor location which hasn't moved
            this.normalizedCoord.x,
            this.normalizedCoord.y
        ]);
    }
    onMouseDblClick(event) {
        if (!this.videoPlayer.isVideoReady()) {
            return;
        }
        this.streamMessageController.toStreamerHandlers.get('MouseDouble')([
            event.button,
            // We use the store value of this.coord as opposed to the mouseEvent.x/y as the mouseEvent location
            // uses the system cursor location which hasn't moved
            this.normalizedCoord.x,
            this.normalizedCoord.y
        ]);
    }
}
//# sourceMappingURL=MouseControllerLocked.js.map

/***/ }),

/***/ 7269:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SpecialKeyCodes": () => (/* binding */ SpecialKeyCodes)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
/**
 * Registers the Special Key codes
 *  Must be kept in sync with JavaScriptKeyCodeToFKey C++ array.
 * The index of the entry in the array is the special key code given below.
 */
class SpecialKeyCodes {
}
SpecialKeyCodes.backSpace = 8;
SpecialKeyCodes.shift = 16;
SpecialKeyCodes.control = 17;
SpecialKeyCodes.alt = 18;
SpecialKeyCodes.rightShift = 253;
SpecialKeyCodes.rightControl = 254;
SpecialKeyCodes.rightAlt = 255;
//# sourceMappingURL=SpecialKeyCodes.js.map

/***/ }),

/***/ 9907:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TouchController": () => (/* binding */ TouchController)
/* harmony export */ });
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7800);
// Copyright Epic Games, Inc. All Rights Reserved.

/**
 * The basic touch controller that handles the touch events on the document.
 */
class TouchController {
    constructor(streamMessageController, videoPlayer, coordinateConverter) {
        this.fingers = [9, 8, 7, 6, 5, 4, 3, 2, 1, 0];
        this.fingerIds = new Map();
        this.maxByteValue = 255;
        this.streamMessageController = streamMessageController;
        this.videoPlayer = videoPlayer;
        this.coordinateConverter = coordinateConverter;
        this.videoElementParent = videoPlayer.getVideoElement();
        this.onTouchStartListener = this.onTouchStart.bind(this);
        this.onTouchEndListener = this.onTouchEnd.bind(this);
        this.onTouchMoveListener = this.onTouchMove.bind(this);
    }
    register() {
        this.videoElementParent.addEventListener('touchstart', this.onTouchStartListener);
        this.videoElementParent.addEventListener('touchend', this.onTouchEndListener);
        this.videoElementParent.addEventListener('touchmove', this.onTouchMoveListener);
    }
    unregister() {
        this.videoElementParent.removeEventListener('touchstart', this.onTouchStartListener);
        this.videoElementParent.removeEventListener('touchend', this.onTouchEndListener);
        this.videoElementParent.removeEventListener('touchmove', this.onTouchMoveListener);
    }
    rememberTouch(touch) {
        const finger = this.fingers.pop();
        if (finger === undefined) {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_0__.Logger.Info('exhausted touch identifiers');
        }
        this.fingerIds.set(touch.identifier, finger);
    }
    forgetTouch(touch) {
        this.fingers.push(this.fingerIds.get(touch.identifier));
        // Sort array back into descending order. This means if finger '1' were to lift after finger '0', we would ensure that 0 will be the first index to pop
        this.fingers.sort(function (a, b) {
            return b - a;
        });
        this.fingerIds.delete(touch.identifier);
    }
    onTouchStart(touchEvent) {
        if (!this.videoPlayer.isVideoReady()) {
            return;
        }
        for (let t = 0; t < touchEvent.changedTouches.length; t++) {
            this.rememberTouch(touchEvent.changedTouches[t]);
        }
        this.emitTouchData('TouchStart', touchEvent.changedTouches);
        touchEvent.preventDefault();
    }
    onTouchEnd(touchEvent) {
        if (!this.videoPlayer.isVideoReady()) {
            return;
        }
        this.emitTouchData('TouchEnd', touchEvent.changedTouches);
        // Re-cycle unique identifiers previously assigned to each touch.
        for (let t = 0; t < touchEvent.changedTouches.length; t++) {
            this.forgetTouch(touchEvent.changedTouches[t]);
        }
        touchEvent.preventDefault();
    }
    onTouchMove(touchEvent) {
        if (!this.videoPlayer.isVideoReady()) {
            return;
        }
        this.emitTouchData('TouchMove', touchEvent.touches);
        touchEvent.preventDefault();
    }
    emitTouchData(type, touches) {
        if (!this.videoPlayer.isVideoReady()) {
            return;
        }
        const offset = this.videoPlayer.getVideoParentElement().getBoundingClientRect();
        const toStreamerHandlers = this.streamMessageController.toStreamerHandlers;
        for (let t = 0; t < touches.length; t++) {
            const numTouches = 1; // the number of touches to be sent this message
            const touch = touches[t];
            const x = touch.clientX - offset.left;
            const y = touch.clientY - offset.top;
            _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_0__.Logger.Info(`F${this.fingerIds.get(touch.identifier)}=(${x}, ${y})`);
            const coord = this.coordinateConverter.translateUnsigned(x, y);
            switch (type) {
                case 'TouchStart':
                    toStreamerHandlers.get('TouchStart')([
                        numTouches,
                        coord.x,
                        coord.y,
                        this.fingerIds.get(touch.identifier),
                        this.maxByteValue * (touch.force > 0 ? touch.force : 1),
                        coord.inRange ? 1 : 0
                    ]);
                    break;
                case 'TouchEnd':
                    toStreamerHandlers.get('TouchEnd')([
                        numTouches,
                        coord.x,
                        coord.y,
                        this.fingerIds.get(touch.identifier),
                        this.maxByteValue * touch.force,
                        coord.inRange ? 1 : 0
                    ]);
                    break;
                case 'TouchMove':
                    toStreamerHandlers.get('TouchMove')([
                        numTouches,
                        coord.x,
                        coord.y,
                        this.fingerIds.get(touch.identifier),
                        this.maxByteValue * (touch.force > 0 ? touch.force : 1),
                        coord.inRange ? 1 : 0
                    ]);
                    break;
            }
        }
    }
}
//# sourceMappingURL=TouchController.js.map

/***/ }),

/***/ 5788:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TouchControllerFake": () => (/* binding */ TouchControllerFake)
/* harmony export */ });
/* harmony import */ var _MouseButtons__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1368);
// Copyright Epic Games, Inc. All Rights Reserved.

/**
 * Allows for the usage of fake touch events
 */
class TouchControllerFake {
    constructor(streamMessageController, videoPlayer, coordinateConverter) {
        this.streamMessageController = streamMessageController;
        this.videoPlayer = videoPlayer;
        this.coordinateConverter = coordinateConverter;
        this.onTouchStartListener = this.onTouchStart.bind(this);
        this.onTouchEndListener = this.onTouchEnd.bind(this);
        this.onTouchMoveListener = this.onTouchMove.bind(this);
        this.videoElementParentClientRect = this.videoPlayer.getVideoParentElement().getBoundingClientRect();
    }
    register() {
        document.addEventListener('touchstart', this.onTouchStartListener);
        document.addEventListener('touchend', this.onTouchEndListener);
        document.addEventListener('touchmove', this.onTouchMoveListener);
    }
    unregister() {
        document.removeEventListener('touchstart', this.onTouchStartListener);
        document.removeEventListener('touchend', this.onTouchEndListener);
        document.removeEventListener('touchmove', this.onTouchMoveListener);
    }
    onTouchStart(touch) {
        if (!this.videoPlayer.isVideoReady() || touch.target !== this.videoPlayer.getVideoElement()) {
            return;
        }
        if (this.fakeTouchFinger == null) {
            const first_touch = touch.changedTouches[0];
            this.fakeTouchFinger = {
                id: first_touch.identifier,
                x: first_touch.clientX - this.videoElementParentClientRect.left,
                y: first_touch.clientY - this.videoElementParentClientRect.top
            };
            const videoElementParent = this.videoPlayer.getVideoParentElement();
            const mouseEvent = new MouseEvent('mouseenter', first_touch);
            videoElementParent.dispatchEvent(mouseEvent);
            const coord = this.coordinateConverter.translateUnsigned(this.fakeTouchFinger.x, this.fakeTouchFinger.y);
            const toStreamerHandlers = this.streamMessageController.toStreamerHandlers;
            toStreamerHandlers.get('MouseDown')([_MouseButtons__WEBPACK_IMPORTED_MODULE_0__.MouseButton.mainButton, coord.x, coord.y]);
        }
        touch.preventDefault();
    }
    onTouchEnd(touchEvent) {
        if (!this.videoPlayer.isVideoReady() || this.fakeTouchFinger == null) {
            return;
        }
        const videoElementParent = this.videoPlayer.getVideoParentElement();
        const toStreamerHandlers = this.streamMessageController.toStreamerHandlers;
        for (let t = 0; t < touchEvent.changedTouches.length; t++) {
            const touch = touchEvent.changedTouches[t];
            if (touch.identifier === this.fakeTouchFinger.id) {
                const x = touch.clientX - this.videoElementParentClientRect.left;
                const y = touch.clientY - this.videoElementParentClientRect.top;
                const coord = this.coordinateConverter.translateUnsigned(x, y);
                toStreamerHandlers.get('MouseUp')([_MouseButtons__WEBPACK_IMPORTED_MODULE_0__.MouseButton.mainButton, coord.x, coord.y]);
                const mouseEvent = new MouseEvent('mouseleave', touch);
                videoElementParent.dispatchEvent(mouseEvent);
                this.fakeTouchFinger = null;
                break;
            }
        }
        touchEvent.preventDefault();
    }
    onTouchMove(touchEvent) {
        if (!this.videoPlayer.isVideoReady() || this.fakeTouchFinger == null) {
            return;
        }
        const toStreamerHandlers = this.streamMessageController.toStreamerHandlers;
        for (let t = 0; t < touchEvent.touches.length; t++) {
            const touch = touchEvent.touches[t];
            if (touch.identifier === this.fakeTouchFinger.id) {
                const x = touch.clientX - this.videoElementParentClientRect.left;
                const y = touch.clientY - this.videoElementParentClientRect.top;
                const coord = this.coordinateConverter.translateUnsigned(x, y);
                const delta = this.coordinateConverter.translateSigned(x - this.fakeTouchFinger.x, y - this.fakeTouchFinger.y);
                toStreamerHandlers.get('MouseMove')([coord.x, coord.y, delta.x, delta.y]);
                this.fakeTouchFinger.x = x;
                this.fakeTouchFinger.y = y;
                break;
            }
        }
        touchEvent.preventDefault();
    }
}
//# sourceMappingURL=TouchControllerFake.js.map

/***/ }),

/***/ 9835:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "XRGamepadController": () => (/* binding */ XRGamepadController)
/* harmony export */ });
/* harmony import */ var _GamepadTypes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4057);
// Copyright Epic Games, Inc. All Rights Reserved.

/**
 * The class that handles the functionality of XR gamepads and controllers.
 */
class XRGamepadController {
    /**
     * @param toStreamerMessagesProvider - Stream message instance
     */
    constructor(toStreamerMessagesProvider) {
        this.toStreamerMessagesProvider = toStreamerMessagesProvider;
        this.controllers = [];
    }
    updateStatus(source, frame, refSpace) {
        if (source.gamepad) {
            const gamepadPose = frame.getPose(source.gripSpace, refSpace);
            if (!gamepadPose) {
                return;
            }
            let system = 0;
            if (source.profiles.includes('htc-vive')) {
                system = 1;
            }
            else if (source.profiles.includes('oculus-touch')) {
                system = 2;
            }
            // TODO (william.belcher): Add other profiles (Quest, Microsoft Mixed Reality, etc)
            this.toStreamerMessagesProvider.toStreamerHandlers.get('XRSystem')([system]);
            // Default: AnyHand (2)
            let handedness = 2;
            switch (source.handedness) {
                case 'left':
                    handedness = 0;
                    break;
                case 'right':
                    handedness = 1;
                    break;
            }
            // Send controller transform
            const matrix = gamepadPose.transform.matrix;
            const mat = [];
            for (let i = 0; i < 16; i++) {
                mat[i] = new Float32Array([matrix[i]])[0];
            }
            // prettier-ignore
            this.toStreamerMessagesProvider.toStreamerHandlers.get('XRControllerTransform')([
                mat[0], mat[4], mat[8], mat[12],
                mat[1], mat[5], mat[9], mat[13],
                mat[2], mat[6], mat[10], mat[14],
                mat[3], mat[7], mat[11], mat[15],
                handedness
            ]);
            // Handle controller buttons and axes
            if (this.controllers[handedness] === undefined) {
                this.controllers[handedness] = {
                    prevState: undefined,
                    currentState: undefined,
                    id: undefined
                };
                this.controllers[handedness].prevState = (0,_GamepadTypes__WEBPACK_IMPORTED_MODULE_0__.deepCopyGamepad)(source.gamepad);
            }
            this.controllers[handedness].currentState = (0,_GamepadTypes__WEBPACK_IMPORTED_MODULE_0__.deepCopyGamepad)(source.gamepad);
            const controller = this.controllers[handedness];
            const currState = controller.currentState;
            const prevState = controller.prevState;
            // Iterate over buttons
            for (let i = 0; i < currState.buttons.length; i++) {
                const currButton = currState.buttons[i];
                const prevButton = prevState.buttons[i];
                if (currButton.pressed) {
                    // press
                    const isRepeat = prevButton.pressed ? 1 : 0;
                    this.toStreamerMessagesProvider.toStreamerHandlers.get('XRButtonPressed')([
                        handedness,
                        i,
                        isRepeat,
                        currButton.value
                    ]);
                }
                else if (prevButton.pressed) {
                    this.toStreamerMessagesProvider.toStreamerHandlers.get('XRButtonReleased')([
                        handedness,
                        i,
                        0
                    ]);
                }
                if (currButton.touched) {
                    // touched
                    const isRepeat = prevButton.touched ? 1 : 0;
                    this.toStreamerMessagesProvider.toStreamerHandlers.get('XRButtonTouched')([
                        handedness,
                        i,
                        isRepeat
                    ]);
                }
                else if (prevButton.touched) {
                    this.toStreamerMessagesProvider.toStreamerHandlers.get('XRButtonTouchReleased')([
                        handedness,
                        i,
                        0
                    ]);
                }
            }
            // Iterate over gamepad axes
            for (let i = 0; i < currState.axes.length; i++) {
                const curAxisValue = currState.axes[i];
                const prevAxisValue = prevState.axes[i];
                // Only send axis update if there is a change
                if (curAxisValue != prevAxisValue) {
                    this.toStreamerMessagesProvider.toStreamerHandlers.get('XRAnalog')([
                        handedness,
                        i,
                        curAxisValue
                    ]);
                }
            }
            this.controllers[handedness].prevState = currState;
        }
    }
}
//# sourceMappingURL=XRGamepadController.js.map

/***/ }),

/***/ 6136:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AggregatedStats": () => (/* binding */ AggregatedStats)
/* harmony export */ });
/* harmony import */ var _InboundRTPStats__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7190);
/* harmony import */ var _DataChannelStats__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3450);
/* harmony import */ var _CandidateStat__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(5239);
/* harmony import */ var _OutBoundRTPStats__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(4598);
/* harmony import */ var _SessionStats__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(3925);
/* harmony import */ var _StreamStats__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(4229);
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(7800);
// Copyright Epic Games, Inc. All Rights Reserved.







/**
 * The Aggregated Stats that is generated from the RTC Stats Report
 */
class AggregatedStats {
    constructor() {
        this.inboundVideoStats = new _InboundRTPStats__WEBPACK_IMPORTED_MODULE_0__.InboundVideoStats();
        this.inboundAudioStats = new _InboundRTPStats__WEBPACK_IMPORTED_MODULE_0__.InboundAudioStats();
        this.datachannelStats = new _DataChannelStats__WEBPACK_IMPORTED_MODULE_1__.DataChannelStats();
        this.outboundVideoStats = new _OutBoundRTPStats__WEBPACK_IMPORTED_MODULE_2__.OutboundRTPStats();
        this.outboundAudioStats = new _OutBoundRTPStats__WEBPACK_IMPORTED_MODULE_2__.OutboundRTPStats();
        this.remoteOutboundAudioStats = new _OutBoundRTPStats__WEBPACK_IMPORTED_MODULE_2__.RemoteOutboundRTPStats();
        this.remoteOutboundVideoStats = new _OutBoundRTPStats__WEBPACK_IMPORTED_MODULE_2__.RemoteOutboundRTPStats();
        this.sessionStats = new _SessionStats__WEBPACK_IMPORTED_MODULE_3__.SessionStats();
        this.streamStats = new _StreamStats__WEBPACK_IMPORTED_MODULE_4__.StreamStats();
        this.codecs = new Map();
    }
    /**
     * Gather all the information from the RTC Peer Connection Report
     * @param rtcStatsReport - RTC Stats Report
     */
    processStats(rtcStatsReport) {
        this.localCandidates = new Array();
        this.remoteCandidates = new Array();
        this.candidatePairs = new Array();
        rtcStatsReport.forEach((stat) => {
            const type = stat.type;
            switch (type) {
                case 'candidate-pair':
                    this.handleCandidatePair(stat);
                    break;
                case 'certificate':
                    break;
                case 'codec':
                    this.handleCodec(stat);
                    break;
                case 'data-channel':
                    this.handleDataChannel(stat);
                    break;
                case 'inbound-rtp':
                    this.handleInboundRTP(stat);
                    break;
                case 'local-candidate':
                    this.handleLocalCandidate(stat);
                    break;
                case 'media-source':
                    break;
                case 'media-playout':
                    break;
                case 'outbound-rtp':
                    this.handleLocalOutbound(stat);
                    break;
                case 'peer-connection':
                    break;
                case 'remote-candidate':
                    this.handleRemoteCandidate(stat);
                    break;
                case 'remote-inbound-rtp':
                    break;
                case 'remote-outbound-rtp':
                    this.handleRemoteOutbound(stat);
                    break;
                case 'track':
                    this.handleTrack(stat);
                    break;
                case 'transport':
                    this.handleTransport(stat);
                    break;
                case 'stream':
                    this.handleStream(stat);
                    break;
                default:
                    _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_5__.Logger.Error('unhandled Stat Type');
                    _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_5__.Logger.Info(stat);
                    break;
            }
        });
    }
    /**
     * Process stream stats data from webrtc
     *
     * @param stat - the stats coming in from webrtc
     */
    handleStream(stat) {
        this.streamStats = stat;
    }
    /**
     * Process the Ice Candidate Pair Data
     * @param stat - the stats coming in from ice candidates
     */
    handleCandidatePair(stat) {
        // Add the candidate pair to the candidate pair array
        this.candidatePairs.push(stat);
    }
    /**
     * Process the Data Channel Data
     * @param stat - the stats coming in from the data channel
     */
    handleDataChannel(stat) {
        this.datachannelStats.bytesReceived = stat.bytesReceived;
        this.datachannelStats.bytesSent = stat.bytesSent;
        this.datachannelStats.dataChannelIdentifier = stat.dataChannelIdentifier;
        this.datachannelStats.id = stat.id;
        this.datachannelStats.label = stat.label;
        this.datachannelStats.messagesReceived = stat.messagesReceived;
        this.datachannelStats.messagesSent = stat.messagesSent;
        this.datachannelStats.protocol = stat.protocol;
        this.datachannelStats.state = stat.state;
        this.datachannelStats.timestamp = stat.timestamp;
    }
    /**
     * Process the Local Ice Candidate Data
     * @param stat - local stats
     */
    handleLocalCandidate(stat) {
        const localCandidate = new _CandidateStat__WEBPACK_IMPORTED_MODULE_6__.CandidateStat();
        localCandidate.label = 'local-candidate';
        localCandidate.address = stat.address;
        localCandidate.port = stat.port;
        localCandidate.protocol = stat.protocol;
        localCandidate.candidateType = stat.candidateType;
        localCandidate.id = stat.id;
        localCandidate.relayProtocol = stat.relayProtocol;
        localCandidate.transportId = stat.transportId;
        this.localCandidates.push(localCandidate);
    }
    /**
     * Process the Remote Ice Candidate Data
     * @param stat - ice candidate stats
     */
    handleRemoteCandidate(stat) {
        const remoteCandidate = new _CandidateStat__WEBPACK_IMPORTED_MODULE_6__.CandidateStat();
        remoteCandidate.label = 'remote-candidate';
        remoteCandidate.address = stat.address;
        remoteCandidate.port = stat.port;
        remoteCandidate.protocol = stat.protocol;
        remoteCandidate.id = stat.id;
        remoteCandidate.candidateType = stat.candidateType;
        remoteCandidate.relayProtocol = stat.relayProtocol;
        remoteCandidate.transportId = stat.transportId;
        this.remoteCandidates.push(remoteCandidate);
    }
    /**
     * Process the Inbound RTP Audio and Video Data
     * @param stat - inbound rtp stats
     */
    handleInboundRTP(stat) {
        switch (stat.kind) {
            case 'video':
                // Calculate bitrate between stat updates
                if (stat.bytesReceived > this.inboundVideoStats.bytesReceived &&
                    stat.timestamp > this.inboundVideoStats.timestamp) {
                    this.inboundVideoStats.bitrate =
                        (8 * (stat.bytesReceived - this.inboundVideoStats.bytesReceived)) /
                            (stat.timestamp - this.inboundVideoStats.timestamp);
                    this.inboundVideoStats.bitrate = Math.floor(this.inboundVideoStats.bitrate);
                }
                // Copy members from stat into `this.inboundVideoStats`
                for (const key in stat) {
                    this.inboundVideoStats[key] = stat[key];
                }
                break;
            case 'audio':
                if (stat.bytesReceived > this.inboundAudioStats.bytesReceived &&
                    stat.timestamp > this.inboundAudioStats.timestamp) {
                    this.inboundAudioStats.bitrate =
                        (8 * (stat.bytesReceived - this.inboundAudioStats.bytesReceived)) /
                            (stat.timestamp - this.inboundAudioStats.timestamp);
                    this.inboundAudioStats.bitrate = Math.floor(this.inboundAudioStats.bitrate);
                }
                // Copy members from stat into `this.inboundAudioStats`
                for (const key in stat) {
                    this.inboundAudioStats[key] = stat[key];
                }
                break;
            default:
                _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_5__.Logger.Error(`Kind should be audio or video, we got ${stat.kind} - that's unsupported.`);
                break;
        }
    }
    /**
     * Process the "local" outbound RTP Audio and Video stats.
     * @param stat - local outbound rtp stats
     */
    handleLocalOutbound(stat) {
        const localOutboundStats = stat.kind === 'audio' ? this.outboundAudioStats : this.outboundVideoStats;
        localOutboundStats.active = stat.active;
        localOutboundStats.codecId = stat.codecId;
        localOutboundStats.bytesSent = stat.bytesSent;
        localOutboundStats.frameHeight = stat.frameHeight;
        localOutboundStats.frameWidth = stat.frameWidth;
        localOutboundStats.framesEncoded = stat.framesEncoded;
        localOutboundStats.framesPerSecond = stat.framesPerSecond;
        localOutboundStats.headerBytesSent = stat.headerBytesSent;
        localOutboundStats.id = stat.id;
        localOutboundStats.keyFramesEncoded = stat.keyFramesEncoded;
        localOutboundStats.kind = stat.kind;
        localOutboundStats.mediaSourceId = stat.mediaSourceId;
        localOutboundStats.mid = stat.mid;
        localOutboundStats.nackCount = stat.nackCount;
        localOutboundStats.packetsSent = stat.packetsSent;
        localOutboundStats.qpSum = stat.qpSum;
        localOutboundStats.qualityLimitationDurations = stat.qualityLimitationDurations;
        localOutboundStats.qualityLimitationReason = stat.qualityLimitationReason;
        localOutboundStats.remoteId = stat.remoteId;
        localOutboundStats.retransmittedBytesSent = stat.retransmittedBytesSent;
        localOutboundStats.rid = stat.rid;
        localOutboundStats.scalabilityMode = stat.scalabilityMode;
        localOutboundStats.ssrc = stat.ssrc;
        localOutboundStats.targetBitrate = stat.targetBitrate;
        localOutboundStats.timestamp = stat.timestamp;
        localOutboundStats.totalEncodeTime = stat.totalEncodeTime;
        localOutboundStats.totalEncodeBytesTarget = stat.totalEncodeBytesTarget;
        localOutboundStats.totalPacketSendDelay = stat.totalPacketSendDelay;
        localOutboundStats.transportId = stat.transportId;
    }
    /**
     * Process the "remote" outbound RTP Audio and Video stats.
     * @param stat - remote outbound rtp stats
     */
    handleRemoteOutbound(stat) {
        const remoteOutboundStats = stat.kind === 'audio' ? this.remoteOutboundAudioStats : this.remoteOutboundVideoStats;
        remoteOutboundStats.bytesSent = stat.bytesSent;
        remoteOutboundStats.codecId = stat.codecId;
        remoteOutboundStats.id = stat.id;
        remoteOutboundStats.kind = stat.kind;
        remoteOutboundStats.localId = stat.localId;
        remoteOutboundStats.packetsSent = stat.packetsSent;
        remoteOutboundStats.remoteTimestamp = stat.remoteTimestamp;
        remoteOutboundStats.reportsSent = stat.reportsSent;
        remoteOutboundStats.roundTripTimeMeasurements = stat.roundTripTimeMeasurements;
        remoteOutboundStats.ssrc = stat.ssrc;
        remoteOutboundStats.timestamp = stat.timestamp;
        remoteOutboundStats.totalRoundTripTime = stat.totalRoundTripTime;
        remoteOutboundStats.transportId = stat.transportId;
    }
    /**
     * Process the Inbound Video Track Data
     * @param stat - video track stats
     */
    handleTrack(stat) {
        // we only want to extract stats from the video track
        if (stat.type === 'track' && (stat.trackIdentifier === 'video_label' || stat.kind === 'video')) {
            this.inboundVideoStats.framesDropped = stat.framesDropped;
            this.inboundVideoStats.framesReceived = stat.framesReceived;
            this.inboundVideoStats.frameHeight = stat.frameHeight;
            this.inboundVideoStats.frameWidth = stat.frameWidth;
        }
    }
    handleTransport(stat) {
        this.transportStats = stat;
    }
    handleCodec(stat) {
        const codecId = stat.id;
        this.codecs.set(codecId, stat);
    }
    handleSessionStatistics(videoStartTime, inputController, videoEncoderAvgQP) {
        const deltaTime = Date.now() - videoStartTime;
        this.sessionStats.runTime = new Date(deltaTime).toISOString().substr(11, 8).toString();
        const controlsStreamInput = inputController === null ? 'Not sent yet' : inputController ? 'true' : 'false';
        this.sessionStats.controlsStreamInput = controlsStreamInput;
        this.sessionStats.videoEncoderAvgQP = videoEncoderAvgQP;
    }
    /**
     * Check if a value coming in from our stats is actually a number
     * @param value - the number to be checked
     */
    isNumber(value) {
        return typeof value === 'number' && isFinite(value);
    }
    /**
     * Helper function to return the active candidate pair
     * @returns The candidate pair that is currently receiving data
     */
    getActiveCandidatePair() {
        if (this.candidatePairs === undefined) {
            return null;
        }
        // Check if the RTCTransport stat is not undefined
        if (this.transportStats) {
            // Return the candidate pair that matches the transport candidate pair id
            const selectedPair = this.candidatePairs.find((candidatePair) => candidatePair.id === this.transportStats.selectedCandidatePairId);
            if (selectedPair === undefined) {
                return null;
            }
            else {
                return selectedPair;
            }
        }
        // Fall back to the `.selected` member of the candidate pair
        const selectedPair = this.candidatePairs.find((candidatePair) => candidatePair.selected);
        if (selectedPair === undefined) {
            return null;
        }
        else {
            return selectedPair;
        }
    }
}
//# sourceMappingURL=AggregatedStats.js.map

/***/ }),

/***/ 7167:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CandidatePairStats": () => (/* binding */ CandidatePairStats)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
/**
 * ICE Candidate Pair Stats collected from the RTC Stats Report
 */
class CandidatePairStats {
}
//# sourceMappingURL=CandidatePairStats.js.map

/***/ }),

/***/ 5239:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CandidateStat": () => (/* binding */ CandidateStat)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
/**
 * ICE Candidate Stat collected from the RTC Stats Report
 */
class CandidateStat {
}
//# sourceMappingURL=CandidateStat.js.map

/***/ }),

/***/ 3450:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DataChannelStats": () => (/* binding */ DataChannelStats)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
/**
 * Data Channel Stats collected from the RTC Stats Report
 */
class DataChannelStats {
}
//# sourceMappingURL=DataChannelStats.js.map

/***/ }),

/***/ 7190:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "InboundAudioStats": () => (/* binding */ InboundAudioStats),
/* harmony export */   "InboundRTPStats": () => (/* binding */ InboundRTPStats),
/* harmony export */   "InboundVideoStats": () => (/* binding */ InboundVideoStats)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
/**
 * Inbound Audio Stats collected from the RTC Stats Report
 */
class InboundAudioStats {
}
/**
 * Inbound Video Stats collected from the RTC Stats Report
 */
class InboundVideoStats {
}
/**
 * Inbound Stats collected from the RTC Stats Report
 */
class InboundRTPStats {
}
//# sourceMappingURL=InboundRTPStats.js.map

/***/ }),

/***/ 7445:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FrameTimingInfo": () => (/* binding */ FrameTimingInfo),
/* harmony export */   "LatencyCalculator": () => (/* binding */ LatencyCalculator),
/* harmony export */   "LatencyInfo": () => (/* binding */ LatencyInfo)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
/**
 * Represents either a:
 * - synchronization source: https://developer.mozilla.org/en-US/docs/Web/API/RTCRtpReceiver/getSynchronizationSources
 * - contributing source: https://developer.mozilla.org/en-US/docs/Web/API/RTCRtpReceiver/getContributingSources
 * Which also (if browser supports it) may optionall contain fields for captureTimestamp + senderCaptureTimeOffset
 * if the abs-capture-time RTP header extension is enabled (currently this only works in Chromium based browsers).
 */
class RTCRtpCaptureSource {
}
/**
 * FrameTimingInfo is a Chromium-specific set of WebRTC stats useful for latency calculation. It is stored in WebRTC stats as `googTimingFrameInfo`.
 * It is defined as an RTP header extension here: https://webrtc.googlesource.com/src/+/refs/heads/main/docs/native-code/rtp-hdrext/video-timing/README.md
 * It is defined in source code here: https://source.chromium.org/chromium/chromium/src/+/main:third_party/webrtc/api/video/video_timing.cc;l=82;drc=8d399817282e3c12ed54eb23ec42a5e418298ec6
 * It is discussed by its author here: https://github.com/w3c/webrtc-provisional-stats/issues/40#issuecomment-1272916692
 * In summary it a comma-delimited string that contains the following (in this order):
 * 1)  RTP timestamp: the RTP timestamp of the frame
 * 2)  Capture time: timestamp when this frame was captured
 * 3)  Encode start: timestamp when this frame started to be encoded
 * 4)  Encode finish: timestamp when this frame finished encoding
 * 5)  Packetization finish: timestamp when this frame was split into packets and was ready to be sent over the network
 * 6)  Pacer exit: timestamp when last packet of this frame was sent over the network by the sender at this timestamp
 * 7)  Network timestamp1: place for the SFU to mark when the frame started being forwarded. Application specific.
 * 8)  Network timestamp2: place for the SFU to mark when the frame finished being forwarded. Application specific.
 * 9)  Receive start: timestamp when the first packet of this frame was received
 * 10) Receive finish: timestamp when the last packet of this frame was received
 * 11) Decode start:  timestamp when the frame was passed to decoder
 * 12) Decode finish:  timestamp when the frame was decoded
 * 13) Render time:  timestamp of the projected render time for this frame
 * 14) "is outlier": a flag for if this frame is bigger in encoded size than the average frame by at least 5x.
 * 15) "triggered by timer": a flag for if this report was triggered by the timer (The report is sent every 200ms)
 */
class FrameTimingInfo {
}
/**
 * Calculates a combination of latency statistics using purely WebRTC API.
 */
class LatencyCalculator {
    constructor() {
        /* Clock offset between peer clocks cannot always be calculated as it relies of latest sender reports.
         * so we store the last time we had a valid clock offset in the assumption that clocks haven't drifted too much since then.
         */
        this.latestSenderRecvClockOffset = null;
    }
    calculate(stats, receivers) {
        const latencyInfo = new LatencyInfo();
        const rttMS = this.getRTTMs(stats);
        if (rttMS != null) {
            latencyInfo.rttMs = rttMS;
            // Calculate sender latency using the first valid video ssrc/csrc
            const captureSource = this.getCaptureSource(receivers);
            if (captureSource != null) {
                const senderLatencyMs = this.calculateSenderLatency(stats, captureSource);
                if (senderLatencyMs !== null) {
                    latencyInfo.senderLatencyMs = senderLatencyMs;
                }
            }
        }
        // https://w3c.github.io/webrtc-stats/#dom-rtcinboundrtpstreamstats-totalprocessingdelay
        if (stats.inboundVideoStats.totalProcessingDelay !== undefined &&
            stats.inboundVideoStats.framesDecoded !== undefined) {
            latencyInfo.averageProcessingDelayMs =
                (stats.inboundVideoStats.totalProcessingDelay / stats.inboundVideoStats.framesDecoded) * 1000;
        }
        // https://w3c.github.io/webrtc-stats/#dom-rtcinboundrtpstreamstats-jitterbufferminimumdelay
        if (stats.inboundVideoStats.jitterBufferDelay !== undefined &&
            stats.inboundVideoStats.jitterBufferEmittedCount !== undefined) {
            latencyInfo.averageJitterBufferDelayMs =
                (stats.inboundVideoStats.jitterBufferDelay /
                    stats.inboundVideoStats.jitterBufferEmittedCount) *
                    1000;
        }
        // https://w3c.github.io/webrtc-stats/#dom-rtcinboundrtpstreamstats-totaldecodetime
        if (stats.inboundVideoStats.framesDecoded !== undefined &&
            stats.inboundVideoStats.totalDecodeTime !== undefined) {
            latencyInfo.averageDecodeLatencyMs =
                (stats.inboundVideoStats.totalDecodeTime / stats.inboundVideoStats.framesDecoded) * 1000;
        }
        // https://w3c.github.io/webrtc-stats/#dom-rtcinboundrtpstreamstats-framesassembledfrommultiplepackets
        if (stats.inboundVideoStats.totalAssemblyTime !== undefined &&
            stats.inboundVideoStats.framesAssembledFromMultiplePackets !== undefined) {
            latencyInfo.averageAssemblyDelayMs =
                (stats.inboundVideoStats.totalAssemblyTime /
                    stats.inboundVideoStats.framesAssembledFromMultiplePackets) *
                    1000;
        }
        // Extract extra Chrome-specific stats like encoding latency
        if (stats.inboundVideoStats.googTimingFrameInfo !== undefined &&
            stats.inboundVideoStats.googTimingFrameInfo.length > 0) {
            latencyInfo.frameTiming = this.extractFrameTimingInfo(stats.inboundVideoStats.googTimingFrameInfo);
        }
        // Calculate E2E latency using video-timing capture to send time + one way network latency + receiver-side latency
        if (latencyInfo.frameTiming !== undefined &&
            latencyInfo.frameTiming.captureToSendLatencyMs !== undefined &&
            latencyInfo.averageProcessingDelayMs !== undefined &&
            latencyInfo.rttMs !== undefined) {
            latencyInfo.averageE2ELatency =
                latencyInfo.frameTiming.captureToSendLatencyMs +
                    latencyInfo.rttMs * 0.5 +
                    latencyInfo.averageProcessingDelayMs;
        }
        // Calculate E2E latency as abs-capture-time capture to send latency + one way network latency + receiver-side latency
        if (latencyInfo.senderLatencyMs != undefined &&
            latencyInfo.averageProcessingDelayMs !== undefined &&
            latencyInfo.rttMs !== undefined) {
            latencyInfo.averageE2ELatency =
                latencyInfo.senderLatencyMs + latencyInfo.rttMs * 0.5 + latencyInfo.averageProcessingDelayMs;
        }
        return latencyInfo;
    }
    extractFrameTimingInfo(googTimingFrameInfo) {
        const timingInfo = new FrameTimingInfo();
        const timingInfoArr = googTimingFrameInfo.split(',');
        // Should have exactly 15 elements according to:
        // https://source.chromium.org/chromium/chromium/src/+/main:third_party/webrtc/api/video/video_timing.cc;l=82;drc=8d399817282e3c12ed54eb23ec42a5e418298ec6
        if (timingInfoArr.length === 15) {
            timingInfo.rtpTimestamp = Number.parseInt(timingInfoArr[0]);
            timingInfo.captureTimestamp = Number.parseInt(timingInfoArr[1]);
            timingInfo.encodeStartTimestamp = Number.parseInt(timingInfoArr[2]);
            timingInfo.encodeFinishTimestamp = Number.parseInt(timingInfoArr[3]);
            timingInfo.packetizerFinishTimestamp = Number.parseInt(timingInfoArr[4]);
            timingInfo.pacerExitTimestamp = Number.parseInt(timingInfoArr[5]);
            timingInfo.networkTimestamp1 = Number.parseInt(timingInfoArr[6]);
            timingInfo.networkTimestamp2 = Number.parseInt(timingInfoArr[7]);
            timingInfo.receiveStart = Number.parseInt(timingInfoArr[8]);
            timingInfo.receiveFinish = Number.parseInt(timingInfoArr[9]);
            timingInfo.decodeStart = Number.parseInt(timingInfoArr[10]);
            timingInfo.decodeFinish = Number.parseInt(timingInfoArr[11]);
            timingInfo.renderTime = Number.parseInt(timingInfoArr[12]);
            timingInfo.isOutlier = Number.parseInt(timingInfoArr[13]) > 0;
            timingInfo.isTriggeredByTimer = Number.parseInt(timingInfoArr[14]) > 0;
            // Calculate some latency stats
            timingInfo.encoderLatencyMs = timingInfo.encodeFinishTimestamp - timingInfo.encodeStartTimestamp;
            timingInfo.packetizeLatencyMs =
                timingInfo.packetizerFinishTimestamp - timingInfo.encodeFinishTimestamp;
            timingInfo.pacerLatencyMs = timingInfo.pacerExitTimestamp - timingInfo.packetizerFinishTimestamp;
            timingInfo.captureToSendLatencyMs = timingInfo.pacerExitTimestamp - timingInfo.captureTimestamp;
        }
        return timingInfo;
    }
    calculateSenderLatency(stats, captureSource) {
        // The calculation performed in this function is as per the procedure defined here:
        // https://w3c.github.io/webrtc-extensions/#dom-rtcrtpcontributingsource-sendercapturetimeoffset
        // Get the sender capture in the sender's clock
        const senderCaptureTimestamp = captureSource.captureTimestamp + captureSource.senderCaptureTimeOffset;
        let sendRecvClockOffset = this.calculateSenderReceiverClockOffset(stats);
        // Use latest clock offset if we couldn't calculate one now
        if (sendRecvClockOffset == null) {
            if (this.latestSenderRecvClockOffset != null) {
                sendRecvClockOffset = this.latestSenderRecvClockOffset;
            }
            else {
                return null;
            }
        }
        else {
            this.latestSenderRecvClockOffset = sendRecvClockOffset;
        }
        // This brings sender clock roughly inline with recv clock
        const recvCaptureTimestampNTP = senderCaptureTimestamp + sendRecvClockOffset;
        // As defined in Chrome source: https://chromium.googlesource.com/external/webrtc/+/master/system_wrappers/include/clock.h#26
        const ntp1970 = 2208988800000;
        const recvCaptureTimestamp = recvCaptureTimestampNTP - ntp1970;
        const senderLatency = captureSource.timestamp - recvCaptureTimestamp;
        return senderLatency;
    }
    /**
     * Find the first valid ssrc or csrc that has capture time fields present from abs-capture-time header extension.
     * @param receivers The RTP receviers this peer connection has.
     * @returns A single valid ssrc or csrc that has capture time fields or null if there is none (e.g. in non-chromium browsers it will be null).
     */
    getCaptureSource(receivers) {
        // We only want video receivers
        receivers = receivers.filter((receiver) => receiver.track.kind === 'video');
        for (const receiver of receivers) {
            // Go through all ssrc and csrc to check for capture timestamp
            // Note: Conversion to `any` here is because TS does not have captureTimestamp etc defined in the types
            // these fields only exist in Chromium currently.
            const sources = receiver
                .getSynchronizationSources()
                .concat(receiver.getContributingSources());
            for (const src of sources) {
                if (src.captureTimestamp !== undefined &&
                    src.senderCaptureTimeOffset !== undefined &&
                    src.timestamp !== undefined) {
                    const captureSrc = new RTCRtpCaptureSource();
                    captureSrc.timestamp = src.timestamp;
                    captureSrc.captureTimestamp = src.captureTimestamp;
                    captureSrc.senderCaptureTimeOffset = src.senderCaptureTimeOffset;
                    return captureSrc;
                }
            }
        }
        return null;
    }
    calculateSenderReceiverClockOffset(stats) {
        // The calculation performed in this function is as per the procedure defined here:
        // https://w3c.github.io/webrtc-extensions/#dom-rtcrtpcontributingsource-sendercapturetimeoffset
        const hasRemoteOutboundVideoStats = stats.remoteOutboundVideoStats !== undefined &&
            stats.remoteOutboundVideoStats.timestamp !== undefined &&
            stats.remoteOutboundVideoStats.remoteTimestamp !== undefined;
        // Note: As of Chrome 132, remote-outbound-rtp stats for video are not yet implemented (audio works).
        // This codepath should activate once they do begin to work.
        if (!hasRemoteOutboundVideoStats) {
            return null;
        }
        const remoteStatsArrivedTimestamp = stats.remoteOutboundVideoStats.timestamp;
        const remoteStatsSentTimestamp = stats.remoteOutboundVideoStats.remoteTimestamp;
        const rttMs = this.getRTTMs(stats);
        if (remoteStatsArrivedTimestamp !== undefined &&
            remoteStatsSentTimestamp !== undefined &&
            rttMs !== null) {
            const onewayDelay = rttMs * 0.5;
            return remoteStatsArrivedTimestamp - (remoteStatsSentTimestamp + onewayDelay);
        }
        // Could not get stats to calculate sender/receiver clock offset
        else {
            return null;
        }
    }
    getRTTMs(stats) {
        // Try to get it from the active candidate pair
        const activeCandidatePair = stats.getActiveCandidatePair();
        if (!!activeCandidatePair && activeCandidatePair.currentRoundTripTime !== undefined) {
            const curRTTSeconds = activeCandidatePair.currentRoundTripTime;
            return curRTTSeconds * 1000;
        }
        // Next try to get it from remote-outbound-rtp video stats
        if (!!stats.remoteOutboundVideoStats &&
            stats.remoteOutboundVideoStats.totalRoundTripTime !== undefined &&
            stats.remoteOutboundVideoStats.roundTripTimeMeasurements !== undefined &&
            stats.remoteOutboundVideoStats.roundTripTimeMeasurements > 0) {
            const avgRttSeconds = stats.remoteOutboundVideoStats.totalRoundTripTime /
                stats.remoteOutboundVideoStats.roundTripTimeMeasurements;
            return avgRttSeconds * 1000;
        }
        // Next try to get it from remote-outbound-rtp audio stats
        if (!!stats.remoteOutboundAudioStats &&
            stats.remoteOutboundAudioStats.totalRoundTripTime !== undefined &&
            stats.remoteOutboundAudioStats.roundTripTimeMeasurements !== undefined &&
            stats.remoteOutboundAudioStats.roundTripTimeMeasurements > 0) {
            const avgRttSeconds = stats.remoteOutboundAudioStats.totalRoundTripTime /
                stats.remoteOutboundAudioStats.roundTripTimeMeasurements;
            return avgRttSeconds * 1000;
        }
        return null;
    }
}
/**
 * A collection of latency information calculated using the WebRTC API.
 * Most stats are calculated following the spec:
 * https://w3c.github.io/webrtc-stats/#dictionary-rtcinboundrtpstreamstats-members
 */
class LatencyInfo {
    constructor() {
        /**
         * The time taken from the moment a frame is done capturing to the moment it is sent over the network.
         * Note: This can only be calculated if both offer and answer contain the
         * the RTP header extension for `video-timing` (Chrome only for now)
         */
        this.senderLatencyMs = undefined;
        /**
         * The time taken from the moment a frame is done capturing to the moment it is sent over the network.
         * Note: This can only be calculated if both offer and answer contain the
         * the RTP header extension for `abs-capture-time` (Chrome only for now)
         */
        this.senderLatencyAbsCaptureTimeMs = undefined;
        /* The round trip time (milliseconds) between each sender->receiver->sender */
        this.rttMs = undefined;
        /* Average time taken (milliseconds) from video packet receipt to post-decode. */
        this.averageProcessingDelayMs = undefined;
        /* Average time taken (milliseconds) inside the jitter buffer (which is post-receipt but pre-decode). */
        this.averageJitterBufferDelayMs = undefined;
        /* Average time taken (milliseconds) to decode a video frame. */
        this.averageDecodeLatencyMs = undefined;
        /* Average time taken (milliseconds) to between receipt of the first and last video packet of a. */
        this.averageAssemblyDelayMs = undefined;
        /* The sender latency + RTT/2 + processing delay */
        this.averageE2ELatency = undefined;
        /* Timing information about the worst performing frame since the last getStats call (only works on Chrome) */
        this.frameTiming = undefined;
    }
}
//# sourceMappingURL=LatencyCalculator.js.map

/***/ }),

/***/ 4598:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "OutboundRTPStats": () => (/* binding */ OutboundRTPStats),
/* harmony export */   "RemoteOutboundRTPStats": () => (/* binding */ RemoteOutboundRTPStats)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
/**
 * Outbound RTP stats collected from the RTC Stats Report under `outbound-rtp`.
 * Wrapper around: https://developer.mozilla.org/en-US/docs/Web/API/RTCOutboundRtpStreamStats
 * These are stats for video we are sending to a remote peer.
 */
class OutboundRTPStats {
}
/**
 * Remote outbound stats collected from the RTC Stats Report under `remote-outbound-rtp`.
 * Wrapper around: https://developer.mozilla.org/en-US/docs/Web/API/RTCRemoteOutboundRtpStreamStats
 * These are stats for media we are receiving from a remote peer.
 */
class RemoteOutboundRTPStats {
}
//# sourceMappingURL=OutBoundRTPStats.js.map

/***/ }),

/***/ 6024:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PeerConnectionController": () => (/* binding */ PeerConnectionController),
/* harmony export */   "kAbsCaptureTime": () => (/* binding */ kAbsCaptureTime)
/* harmony export */ });
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(7800);
/* harmony import */ var _Config_Config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7463);
/* harmony import */ var _AggregatedStats__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(6136);
/* harmony import */ var sdp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7539);
/* harmony import */ var sdp__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(sdp__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _Util_RTCUtils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(4412);
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(4250);
/* harmony import */ var _LatencyCalculator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7445);
// Copyright Epic Games, Inc. All Rights Reserved.
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};







const kAbsCaptureTime = 'http://www.webrtc.org/experiments/rtp-hdrext/abs-capture-time';
/**
 * Handles the Peer Connection
 */
class PeerConnectionController {
    /**
     * Create a new RTC Peer Connection client
     * @param options - Peer connection Options
     * @param config - The config for our PS experience.
     */
    constructor(options, config, preferredCodec) {
        this.config = config;
        this.createPeerConnection(options, preferredCodec);
        this.latencyCalculator = new _LatencyCalculator__WEBPACK_IMPORTED_MODULE_1__.LatencyCalculator();
    }
    createPeerConnection(options, preferredCodec) {
        // Set the ICE transport to relay if TURN enabled
        if (this.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_2__.Flags.ForceTURN)) {
            options.iceTransportPolicy = 'relay';
            _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_3__.Logger.Info('Forcing TURN usage by setting ICE Transport Policy in peer connection config.');
        }
        // build a new peer connection with the options
        this.peerConnection = new RTCPeerConnection(options);
        this.peerConnection.onsignalingstatechange = (ev) => this.handleSignalStateChange(ev);
        this.peerConnection.oniceconnectionstatechange = (ev) => this.handleIceConnectionStateChange(ev);
        this.peerConnection.onicegatheringstatechange = (ev) => this.handleIceGatheringStateChange(ev);
        this.peerConnection.ontrack = (ev) => this.handleOnTrack(ev);
        this.peerConnection.onicecandidate = (ev) => this.handleIceCandidate(ev);
        this.peerConnection.ondatachannel = (ev) => this.handleDataChannel(ev);
        this.aggregatedStats = new _AggregatedStats__WEBPACK_IMPORTED_MODULE_4__.AggregatedStats();
        this.preferredCodec = preferredCodec;
        this.updateCodecSelection = true;
    }
    /**
     * Create an offer for the Web RTC handshake and send the offer to the signaling server via websocket
     * @param offerOptions - RTC Offer Options
     */
    createOffer(offerOptions, config) {
        return __awaiter(this, void 0, void 0, function* () {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_3__.Logger.Info('Create Offer');
            const isLocalhostConnection = location.hostname === 'localhost' || location.hostname === '127.0.0.1';
            const isHttpsConnection = location.protocol === 'https:';
            let useMic = config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_2__.Flags.UseMic);
            let useCamera = config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_2__.Flags.UseCamera);
            if ((useMic || useCamera) && !(isLocalhostConnection || isHttpsConnection)) {
                useMic = false;
                useCamera = false;
                _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_3__.Logger.Error('Microphone and Webcam access in the browser will not work if you are not on HTTPS or localhost. Disabling mic and webcam access.');
                _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_3__.Logger.Error("For testing you can enable HTTP microphone access Chrome by visiting chrome://flags/ and enabling 'unsafely-treat-insecure-origin-as-secure'");
            }
            this.setupTransceiversAsync(useMic, useCamera).finally(() => {
                var _a;
                (_a = this.peerConnection) === null || _a === void 0 ? void 0 : _a.createOffer(offerOptions).then((offer) => {
                    var _a;
                    this.showTextOverlayConnecting();
                    offer.sdp = this.mungeSDP(offer.sdp, useMic);
                    (_a = this.peerConnection) === null || _a === void 0 ? void 0 : _a.setLocalDescription(offer);
                    this.onSendWebRTCOffer(offer);
                }).catch(() => {
                    this.showTextOverlaySetupFailure();
                });
            });
        });
    }
    /**
     * Receive offer from UE side and process it as the remote description of this peer connection
     */
    receiveOffer(offer, config) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_3__.Logger.Info('Receive Offer');
            // If UE or JSStreamer did send abs-capture-time RTP header extension to a non-Chrome browser
            // then remove it from the SDP because if Firefox detects it in offer or answer it will fail to connect
            // due having 15 or more header extensions: https://mailarchive.ietf.org/arch/msg/rtcweb/QRnWNuWzGuLRovWdHkodNP6VOgg/
            if (this.isFirefox()) {
                // example: a=extmap:15 http://www.webrtc.org/experiments/rtp-hdrext/abs-capture-time
                offer.sdp = offer.sdp.replace(/^a=extmap:\d+ http:\/\/www\.webrtc\.org\/experiments\/rtp-hdrext\/abs-capture-time\r\n/gm, '');
            }
            (_a = this.peerConnection) === null || _a === void 0 ? void 0 : _a.setRemoteDescription(offer).then(() => {
                // Fire event for when remote offer description is set
                this.onSetRemoteDescription(offer);
                const isLocalhostConnection = location.hostname === 'localhost' || location.hostname === '127.0.0.1';
                const isHttpsConnection = location.protocol === 'https:';
                let useMic = config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_2__.Flags.UseMic);
                let useCamera = config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_2__.Flags.UseCamera);
                if ((useMic || useCamera) && !(isLocalhostConnection || isHttpsConnection)) {
                    useMic = false;
                    useCamera = false;
                    _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_3__.Logger.Error('Microphone and Webcam access in the browser will not work if you are not on HTTPS or localhost. Disabling mic and webcam access.');
                    _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_3__.Logger.Error("For testing you can enable HTTP microphone access Chrome by visiting chrome://flags/ and enabling 'unsafely-treat-insecure-origin-as-secure'");
                }
                // Add our list of preferred codecs, in order of preference
                this.config.setOptionSettingOptions(_Config_Config__WEBPACK_IMPORTED_MODULE_2__.OptionParameters.PreferredCodec, this.fuzzyIntersectUEAndBrowserCodecs(offer));
                this.setupTransceiversAsync(useMic, useCamera).finally(() => {
                    var _a;
                    (_a = this.peerConnection) === null || _a === void 0 ? void 0 : _a.createAnswer().then((Answer) => {
                        var _a;
                        Answer.sdp = this.mungeSDP(Answer.sdp, useMic);
                        return (_a = this.peerConnection) === null || _a === void 0 ? void 0 : _a.setLocalDescription(Answer);
                    }).then(() => {
                        var _a;
                        this.onSetLocalDescription((_a = this.peerConnection) === null || _a === void 0 ? void 0 : _a.currentLocalDescription);
                    }).catch((err) => {
                        _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_3__.Logger.Error(`createAnswer() failed - ${err}`);
                    });
                });
            });
        });
    }
    /**
     * Set the Remote Descriptor from the signaling server to the RTC Peer Connection
     * @param answer - RTC Session Descriptor from the Signaling Server
     */
    receiveAnswer(answer) {
        var _a;
        (_a = this.peerConnection) === null || _a === void 0 ? void 0 : _a.setRemoteDescription(answer);
        // Add our list of preferred codecs, in order of preference
        this.config.setOptionSettingOptions(_Config_Config__WEBPACK_IMPORTED_MODULE_2__.OptionParameters.PreferredCodec, this.fuzzyIntersectUEAndBrowserCodecs(answer));
    }
    /**
     * Generate Aggregated Stats and then fire a onVideo Stats event
     */
    generateStats() {
        this.peerConnection.getStats().then((statsData) => {
            this.aggregatedStats.processStats(statsData);
            this.onVideoStats(this.aggregatedStats);
            // Calculate latency using stats and video receivers and then call the handling function
            const latencyInfo = this.latencyCalculator.calculate(this.aggregatedStats, this.peerConnection.getReceivers());
            this.onLatencyCalculated(latencyInfo);
            // Update the preferred codec selection based on what was actually negotiated
            if (this.updateCodecSelection && !!this.aggregatedStats.inboundVideoStats.codecId) {
                // Construct the qualified codec name from the mimetype and fmtp
                const codecStats = this.aggregatedStats.codecs.get(this.aggregatedStats.inboundVideoStats.codecId);
                if (codecStats === undefined) {
                    return;
                }
                const codecShortname = codecStats.mimeType.replace('video/', '');
                let fullCodecName = codecShortname;
                if (codecStats.sdpFmtpLine && codecStats.sdpFmtpLine.trim() !== '') {
                    fullCodecName = `${codecShortname} ${codecStats.sdpFmtpLine.trim()}`;
                }
                const allBrowserCodecs = this.config.getSettingOption(_Config_Config__WEBPACK_IMPORTED_MODULE_2__.OptionParameters.PreferredCodec).options;
                // The list of codecs directly contains the one that was negotiated, select that
                if (allBrowserCodecs.includes(fullCodecName)) {
                    this.config.setOptionSettingValue(_Config_Config__WEBPACK_IMPORTED_MODULE_2__.OptionParameters.PreferredCodec, fullCodecName);
                    return;
                }
                // If we couldn't match on the full name, try to match on just the codec shortname
                const filteredList = allBrowserCodecs.filter((option) => option.indexOf(codecShortname) !== -1);
                if (filteredList.length > 0) {
                    this.config.setOptionSettingValue(_Config_Config__WEBPACK_IMPORTED_MODULE_2__.OptionParameters.PreferredCodec, filteredList[0]);
                    return;
                }
            }
        });
    }
    /**
     * Close The Peer Connection
     */
    close() {
        if (this.peerConnection) {
            this.peerConnection.close();
            this.peerConnection = null;
        }
    }
    /**
     * Modify the Session Descriptor
     * @param sdp - Session Descriptor as a string
     * @param useMic - Is the microphone in use
     * @returns A modified Session Descriptor
     */
    mungeSDP(sdp, useMic) {
        let mungedSDP = sdp.replace(/(a=fmtp:\d+ .*level-asymmetry-allowed=.*)\r\n/gm, '$1;x-google-start-bitrate=10000;x-google-max-bitrate=100000\r\n');
        // set max bitrate to highest bitrate Opus supports
        let audioSDP = 'maxaveragebitrate=510000;';
        if (useMic) {
            // set the max capture rate to 48khz (so we can send high quality audio from mic)
            audioSDP += 'sprop-maxcapturerate=48000;';
        }
        // Force mono or stereo based on whether ?forceMono was passed or not
        audioSDP += this.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_2__.Flags.ForceMonoAudio) ? 'stereo=0;' : 'stereo=1;';
        // enable in-band forward error correction for opus audio
        audioSDP += 'useinbandfec=1';
        // We use the line 'useinbandfec=1' (which Opus uses) to set our Opus specific audio parameters.
        mungedSDP = mungedSDP.replace('useinbandfec=1', audioSDP);
        // Add abs-capture-time RTP header extension if we have enabled the setting.
        // Note: As at Feb 2025, Chromium based browsers are the only ones that support this and
        // munging it into the answer in Firefox will cause the connection to fail.
        if (this.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_2__.Flags.EnableCaptureTimeExt) && !this.isFirefox()) {
            mungedSDP = _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_5__.SDPUtils.addVideoHeaderExtensionToSdp(mungedSDP, kAbsCaptureTime);
        }
        return mungedSDP;
    }
    isFirefox() {
        return navigator.userAgent.indexOf('Firefox') > 0;
    }
    /**
     * When a Ice Candidate is received add to the RTC Peer Connection
     * @param iceCandidate - RTC Ice Candidate from the Signaling Server
     */
    handleOnIce(iceCandidate) {
        var _a;
        _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_3__.Logger.Info('peerconnection handleOnIce');
        // // if forcing TURN, reject any candidates not relay
        if (this.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_2__.Flags.ForceTURN)) {
            // check if no relay address is found, if so, we are assuming it means no TURN server
            if (iceCandidate.candidate.indexOf('relay') < 0) {
                _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_3__.Logger.Info(`Dropping candidate because it was not TURN relay. | Type= ${iceCandidate.type} | Protocol= ${iceCandidate.protocol} | Address=${iceCandidate.address} | Port=${iceCandidate.port} |`);
                return;
            }
        }
        (_a = this.peerConnection) === null || _a === void 0 ? void 0 : _a.addIceCandidate(iceCandidate);
    }
    /**
     * When the RTC Peer Connection Signaling server state Changes
     * @param state - Signaling Server State Change Event
     */
    handleSignalStateChange(state) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_3__.Logger.Info('signaling state change: ' + state);
    }
    /**
     * Handle when the Ice Connection State Changes
     * @param state - Ice Connection State
     */
    handleIceConnectionStateChange(state) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_3__.Logger.Info('ice connection state change: ' + state);
        this.onIceConnectionStateChange(state);
    }
    /**
     * Handle when the Ice Gathering State Changes
     * @param state - Ice Gathering State Change
     */
    handleIceGatheringStateChange(state) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_3__.Logger.Info('ice gathering state change: ' + JSON.stringify(state));
    }
    /**
     * Activates the onTrack method
     * @param event - The webRtc track event
     */
    handleOnTrack(event) {
        if (event.streams.length < 1 || event.streams[0].id == 'probator') {
            return;
        }
        if (event.track.kind == 'video') {
            this.videoTrack = event.track;
        }
        if (event.track.kind == 'audio') {
            this.audioTrack = event.track;
        }
        this.onTrack(event);
    }
    /**
     * Activates the onPeerIceCandidate
     * @param event - The peer ice candidate
     */
    handleIceCandidate(event) {
        this.onPeerIceCandidate(event);
    }
    /**
     * Activates the onDataChannel
     * @param event - The peer's data channel
     */
    handleDataChannel(event) {
        this.onDataChannel(event);
    }
    /**
     * An override method for onTrack for use outside of the PeerConnectionController
     * @param trackEvent - The webRtc track event
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onTrack(trackEvent) {
        // Default Functionality: Do Nothing
    }
    /**
     * An override method for onIceConnectionStateChange for use outside of the PeerConnectionController
     * @param event - The webRtc iceconnectionstatechange event
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onIceConnectionStateChange(event) {
        // Default Functionality: Do Nothing
    }
    /**
     * An override method for onPeerIceCandidate for use outside of the PeerConnectionController
     * @param peerConnectionIceEvent - The peer ice candidate
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onPeerIceCandidate(peerConnectionIceEvent) {
        // Default Functionality: Do Nothing
    }
    /**
     * An override method for onDataChannel for use outside of the PeerConnectionController
     * @param datachannelEvent - The peer's data channel
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onDataChannel(datachannelEvent) {
        // Default Functionality: Do Nothing
    }
    /**
     * Find the intersection between UE and browser codecs, with fuzzy matching if some parameters are mismatched.
     * @param sdp The remote sdp
     * @returns The intersection between browser supported codecs and ue supported codecs.
     */
    fuzzyIntersectUEAndBrowserCodecs(sdp) {
        // We want to build an array of all supported codecs on both sides
        const allSupportedCodecs = new Array();
        const allUECodecs = this.parseAvailableCodecs(sdp);
        const allBrowserCodecs = this.config.getSettingOption(_Config_Config__WEBPACK_IMPORTED_MODULE_2__.OptionParameters.PreferredCodec).options;
        for (const ueCodec of allUECodecs) {
            // Check if browser codecs directly matches UE codec (with parameters and everything)
            if (allBrowserCodecs.includes(ueCodec)) {
                allSupportedCodecs.push(ueCodec);
                continue;
            }
            // Otherwise check if browser codec at least contains a match for the UE codec name (without parameters).
            else {
                const ueCodecNameAndParams = ueCodec.split(' ');
                const ueCodecName = ueCodecNameAndParams[0];
                for (const browserCodec of allBrowserCodecs) {
                    if (browserCodec.includes(ueCodecName)) {
                        // We pass browser codec here as they option contain extra parameters.
                        allSupportedCodecs.push(browserCodec);
                        break;
                    }
                }
            }
        }
        return allSupportedCodecs;
    }
    /**
     * Setup tracks on the RTC Peer Connection
     * @param useMic - is mic in use
     * @param useCamera - is webcam in use
     */
    setupTransceiversAsync(useMic, useCamera) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c, _d, _e, _f, _g, _h;
            let hasVideoReceiver = false;
            for (const transceiver of (_b = (_a = this.peerConnection) === null || _a === void 0 ? void 0 : _a.getTransceivers()) !== null && _b !== void 0 ? _b : []) {
                if (transceiver &&
                    transceiver.receiver &&
                    transceiver.receiver.track &&
                    transceiver.receiver.track.kind === 'video') {
                    hasVideoReceiver = true;
                    break;
                }
            }
            // Setup a transceiver for sending webcam video to UE and receiving video from UE
            if (!useCamera) {
                if (!hasVideoReceiver) {
                    (_c = this.peerConnection) === null || _c === void 0 ? void 0 : _c.addTransceiver('video', { direction: 'recvonly' });
                }
            }
            else {
                yield this.setupVideoSender(hasVideoReceiver);
            }
            if (RTCRtpReceiver.getCapabilities && this.preferredCodec != '') {
                for (const transceiver of (_e = (_d = this.peerConnection) === null || _d === void 0 ? void 0 : _d.getTransceivers()) !== null && _e !== void 0 ? _e : []) {
                    if (transceiver &&
                        transceiver.receiver &&
                        transceiver.receiver.track &&
                        transceiver.receiver.track.kind === 'video' &&
                        transceiver.setCodecPreferences) {
                        // Get our preferred codec from the codecs options drop down
                        const preferredRTPCodec = this.preferredCodec.split(' ');
                        const preferredRTCRtpCodecCapability = {
                            mimeType: 'video/' + preferredRTPCodec[0] /* Name */,
                            clockRate: 90000 /* All current video formats in browsers have 90khz clock rate */,
                            sdpFmtpLine: preferredRTPCodec[1] ? preferredRTPCodec[1] : ''
                        };
                        // Populate a list of codecs we will support with our preferred one in the first position
                        const ourSupportedCodecs = [preferredRTCRtpCodecCapability];
                        // Go through all codecs the browser supports and add them to the list (in any order)
                        RTCRtpReceiver.getCapabilities('video').codecs.forEach((browserSupportedCodec) => {
                            // Don't add our preferred codec again, but add everything else
                            if (browserSupportedCodec.mimeType != preferredRTCRtpCodecCapability.mimeType) {
                                ourSupportedCodecs.push(browserSupportedCodec);
                            }
                            else if ((browserSupportedCodec === null || browserSupportedCodec === void 0 ? void 0 : browserSupportedCodec.sdpFmtpLine) !=
                                (preferredRTCRtpCodecCapability === null || preferredRTCRtpCodecCapability === void 0 ? void 0 : preferredRTCRtpCodecCapability.sdpFmtpLine)) {
                                ourSupportedCodecs.push(browserSupportedCodec);
                            }
                        });
                        for (const codec of ourSupportedCodecs) {
                            if ((codec === null || codec === void 0 ? void 0 : codec.sdpFmtpLine) === undefined || codec.sdpFmtpLine === '') {
                                // We can't dynamically add members to the codec, so instead remove the field if it's empty
                                delete codec.sdpFmtpLine;
                            }
                        }
                        transceiver.setCodecPreferences(ourSupportedCodecs);
                    }
                }
            }
            let hasAudioReceiver = false;
            for (const transceiver of (_g = (_f = this.peerConnection) === null || _f === void 0 ? void 0 : _f.getTransceivers()) !== null && _g !== void 0 ? _g : []) {
                if (transceiver &&
                    transceiver.receiver &&
                    transceiver.receiver.track &&
                    transceiver.receiver.track.kind === 'audio') {
                    hasAudioReceiver = true;
                    break;
                }
            }
            // Setup a transceiver for sending mic audio to UE and receiving audio from UE
            if (!useMic) {
                if (!hasAudioReceiver) {
                    (_h = this.peerConnection) === null || _h === void 0 ? void 0 : _h.addTransceiver('audio', {
                        direction: 'recvonly'
                    });
                }
            }
            else {
                yield this.setupAudioSender(hasAudioReceiver);
            }
        });
    }
    setupVideoSender(hasVideoReceiver) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c, _d;
            // set the media send options
            const mediaSendOptions = {
                video: true
            };
            // Note using webcam on android chrome requires SSL or chrome://flags/ "unsafely-treat-insecure-origin-as-secure"
            const stream = yield navigator.mediaDevices.getUserMedia(mediaSendOptions);
            if (stream) {
                if (hasVideoReceiver) {
                    for (const transceiver of (_b = (_a = this.peerConnection) === null || _a === void 0 ? void 0 : _a.getTransceivers()) !== null && _b !== void 0 ? _b : []) {
                        if (_Util_RTCUtils__WEBPACK_IMPORTED_MODULE_6__.RTCUtils.canTransceiverReceiveVideo(transceiver)) {
                            for (const track of stream.getTracks()) {
                                if (track.kind && track.kind == 'video') {
                                    transceiver.sender.replaceTrack(track);
                                    transceiver.direction = 'sendrecv';
                                }
                            }
                        }
                    }
                }
                else {
                    for (const track of stream.getTracks()) {
                        if (track.kind && track.kind == 'video') {
                            (_c = this.peerConnection) === null || _c === void 0 ? void 0 : _c.addTransceiver(track, {
                                direction: 'sendrecv'
                            });
                        }
                    }
                }
            }
            else {
                if (!hasVideoReceiver) {
                    (_d = this.peerConnection) === null || _d === void 0 ? void 0 : _d.addTransceiver('video', { direction: 'recvonly' });
                }
            }
        });
    }
    setupAudioSender(hasAudioReceiver) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c, _d;
            // set the audio options based on mic usage
            const audioOptions = {
                autoGainControl: false,
                channelCount: 1,
                echoCancellation: false,
                latency: 0,
                noiseSuppression: false,
                sampleRate: 48000,
                sampleSize: 16,
                volume: 1.0
            };
            // set the media send options
            const mediaSendOptions = {
                video: false,
                audio: audioOptions
            };
            // Note using mic on android chrome requires SSL or chrome://flags/ "unsafely-treat-insecure-origin-as-secure"
            const stream = yield navigator.mediaDevices.getUserMedia(mediaSendOptions);
            if (stream) {
                if (hasAudioReceiver) {
                    for (const transceiver of (_b = (_a = this.peerConnection) === null || _a === void 0 ? void 0 : _a.getTransceivers()) !== null && _b !== void 0 ? _b : []) {
                        if (_Util_RTCUtils__WEBPACK_IMPORTED_MODULE_6__.RTCUtils.canTransceiverReceiveAudio(transceiver)) {
                            for (const track of stream.getTracks()) {
                                if (track.kind && track.kind == 'audio') {
                                    transceiver.sender.replaceTrack(track);
                                    transceiver.direction = 'sendrecv';
                                }
                            }
                        }
                    }
                }
                else {
                    for (const track of stream.getTracks()) {
                        if (track.kind && track.kind == 'audio') {
                            (_c = this.peerConnection) === null || _c === void 0 ? void 0 : _c.addTransceiver(track, {
                                direction: 'sendrecv'
                            });
                        }
                    }
                }
            }
            else {
                if (!hasAudioReceiver) {
                    (_d = this.peerConnection) === null || _d === void 0 ? void 0 : _d.addTransceiver('audio', {
                        direction: 'recvonly'
                    });
                }
            }
        });
    }
    /**
     * And override event for when the video stats are fired
     * @param event - Aggregated Stats
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onVideoStats(event) {
        // Default Functionality: Do Nothing
    }
    /**
     * And override event for when latency info is calculated
     * @param latencyInfo - Calculated latency information.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onLatencyCalculated(latencyInfo) {
        // Default Functionality: Do Nothing
    }
    /**
     * Event to send the RTC offer to the Signaling server
     * @param offer - RTC Offer
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onSendWebRTCOffer(offer) {
        // Default Functionality: Do Nothing
    }
    /**
     * Event fired when remote offer description is set.
     * @param offer - RTC Offer
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onSetRemoteDescription(offer) {
        // Default Functionality: Do Nothing
    }
    /**
     * Event fire when local description answer is set.
     * @param answer - RTC Answer
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onSetLocalDescription(answer) {
        // Default Functionality: Do Nothing
    }
    /**
     * An override for showing the Peer connection connecting Overlay
     */
    showTextOverlayConnecting() {
        // Default Functionality: Do Nothing
    }
    /**
     * An override for showing the Peer connection Failed overlay
     */
    showTextOverlaySetupFailure() {
        // Default Functionality: Do Nothing
    }
    parseAvailableCodecs(rtcSessionDescription) {
        // No point in updating the available codecs if on FF
        if (!RTCRtpReceiver.getCapabilities)
            return ['Only available on Chrome'];
        const ueSupportedCodecs = [];
        const sections = (0,sdp__WEBPACK_IMPORTED_MODULE_0__.splitSections)(rtcSessionDescription.sdp);
        // discard the session information as we only want media related info
        sections.shift();
        sections.forEach((mediaSection) => {
            const { codecs } = (0,sdp__WEBPACK_IMPORTED_MODULE_0__.parseRtpParameters)(mediaSection);
            // Filter only for VPX / H26X / AV1
            const matcher = /(VP\d|H26\d|AV1).*/;
            codecs.forEach((c) => {
                const str = c.name +
                    ' ' +
                    Object.keys(c.parameters || {})
                        .map((p) => p + '=' + c.parameters[p])
                        .join(';');
                const match = matcher.exec(str);
                if (match !== null) {
                    if (c.name == 'VP9') {
                        // UE answers don't specify profile but we know we want profile 0
                        c.parameters = {
                            'profile-id': '0'
                        };
                    }
                    const codecStr = c.name +
                        ' ' +
                        Object.keys(c.parameters || {})
                            .map((p) => p + '=' + c.parameters[p])
                            .join(';');
                    ueSupportedCodecs.push(codecStr);
                }
            });
        });
        return ueSupportedCodecs;
    }
}
//# sourceMappingURL=PeerConnectionController.js.map

/***/ }),

/***/ 3925:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SessionStats": () => (/* binding */ SessionStats)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
/**
 * Session statistics
 */
class SessionStats {
}
//# sourceMappingURL=SessionStats.js.map

/***/ }),

/***/ 4229:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "StreamStats": () => (/* binding */ StreamStats)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
/**
 * Class to hold the stream stats data coming in from webRtc
 */
class StreamStats {
}
//# sourceMappingURL=StreamStats.js.map

/***/ }),

/***/ 516:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PixelStreaming": () => (/* binding */ PixelStreaming)
/* harmony export */ });
/* harmony import */ var _Config_Config__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(7463);
/* harmony import */ var _WebRtcPlayer_WebRtcPlayerController__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5750);
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(7800);
/* harmony import */ var _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5391);
/* harmony import */ var _WebXR_WebXRController__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(9581);
/* harmony import */ var _UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(180);
/* harmony import */ var _DataChannel_DataChannelLatencyTestController__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(1075);
/* harmony import */ var _Util_RTCUtils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(4412);
/* harmony import */ var _Util_IURLSearchParams__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(7429);
// Copyright Epic Games, Inc. All Rights Reserved.










/**
 * The key class for the browser side of a Pixel Streaming application, it includes:
 * WebRTC handling, XR support, input handling, and emitters for lifetime and state change events.
 * Users are encouraged to use this class as is, through composition, or extend it. In any case,
 * this will likely be the core of your Pixel Streaming experience in terms of functionality.
 */
class PixelStreaming {
    /**
     * @param config - A newly instantiated config object
     * @param overrides - Parameters to override default behaviour
     * returns the base Pixel streaming object
     */
    constructor(config, overrides) {
        this.allowConsoleCommands = false;
        this.config = config;
        if (overrides === null || overrides === void 0 ? void 0 : overrides.videoElementParent) {
            this._videoElementParent = overrides.videoElementParent;
        }
        this._eventEmitter = new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.PixelStreamingEventEmitter();
        this.configureSettings();
        // setup WebRTC
        this.setWebRtcPlayerController(new _WebRtcPlayer_WebRtcPlayerController__WEBPACK_IMPORTED_MODULE_1__.WebRtcPlayerController(this.config, this));
        this._webXrController = new _WebXR_WebXRController__WEBPACK_IMPORTED_MODULE_2__.WebXRController(this._webRtcController);
        this._setupWebRtcTCPRelayDetection = this._setupWebRtcTCPRelayDetection.bind(this);
        // Add event listener for the webRtcConnected event
        this._eventEmitter.addEventListener('webRtcConnected', (_) => {
            // Bind to the stats received event
            this._eventEmitter.addEventListener('statsReceived', this._setupWebRtcTCPRelayDetection);
        });
    }
    /**
     * Gets the element that contains the video stream element.
     */
    get videoElementParent() {
        if (!this._videoElementParent) {
            this._videoElementParent = document.createElement('div');
            this._videoElementParent.id = 'videoElementParent';
        }
        return this._videoElementParent;
    }
    /**
     * Configure the settings with on change listeners and any additional per experience settings.
     */
    configureSettings() {
        this.config._addOnSettingChangedListener(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.Flags.IsQualityController, (wantsQualityController) => {
            // If the setting has been set to true (either programmatically or the user has flicked the toggle)
            // and we aren't currently quality controller, send the request
            if (wantsQualityController === true && !this._webRtcController.isQualityController) {
                this._webRtcController.sendRequestQualityControlOwnership();
            }
        });
        this.config._addOnSettingChangedListener(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.Flags.AFKDetection, (isAFKEnabled) => {
            this._webRtcController.setAfkEnabled(isAFKEnabled);
        });
        this.config._addOnSettingChangedListener(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.Flags.MatchViewportResolution, () => {
            this._webRtcController.videoPlayer.updateVideoStreamSize();
        });
        this.config._addOnSettingChangedListener(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.Flags.HoveringMouseMode, (isHoveringMouse) => {
            this.config.setFlagLabel(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.Flags.HoveringMouseMode, `Control Scheme: ${isHoveringMouse ? 'Hovering' : 'Locked'} Mouse`);
            this._webRtcController.setMouseInputEnabled(this.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.Flags.MouseInput));
        });
        // user input
        this.config._addOnSettingChangedListener(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.Flags.KeyboardInput, (isEnabled) => {
            this._webRtcController.setKeyboardInputEnabled(isEnabled);
        });
        this.config._addOnSettingChangedListener(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.Flags.MouseInput, (isEnabled) => {
            this._webRtcController.setMouseInputEnabled(isEnabled);
        });
        this.config._addOnSettingChangedListener(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.Flags.FakeMouseWithTouches, (_isFakeMouseEnabled) => {
            this._webRtcController.setTouchInputEnabled(this.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.Flags.TouchInput));
        });
        this.config._addOnSettingChangedListener(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.Flags.TouchInput, (isEnabled) => {
            this._webRtcController.setTouchInputEnabled(isEnabled);
        });
        this.config._addOnSettingChangedListener(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.Flags.GamepadInput, (isEnabled) => {
            this._webRtcController.setGamePadInputEnabled(isEnabled);
        });
        // direct qp settings
        this.config._addOnNumericSettingChangedListener(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.MinQP, (newValue) => {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_4__.Logger.Info('--------  Sending MinQP  --------');
            this._webRtcController.sendEncoderMinQP(newValue);
            _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_4__.Logger.Info('-------------------------------------------');
            const quality = Math.trunc(100 * (1 - newValue / 51));
            this.config.setNumericSetting(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.CompatQualityMax, quality);
        });
        this.config._addOnNumericSettingChangedListener(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.MaxQP, (newValue) => {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_4__.Logger.Info('--------  Sending MaxQP  --------');
            this._webRtcController.sendEncoderMaxQP(newValue);
            _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_4__.Logger.Info('-------------------------------------------');
            const quality = Math.trunc(100 * (1 - newValue / 51));
            this.config.setNumericSetting(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.CompatQualityMin, quality);
        });
        // direct quality factor settings
        this.config._addOnNumericSettingChangedListener(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.MinQuality, (newValue) => {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_4__.Logger.Info('--------  Sending MinQuality  --------');
            this._webRtcController.sendEncoderMinQuality(newValue);
            _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_4__.Logger.Info('-------------------------------------------');
            this.config.setNumericSetting(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.CompatQualityMin, newValue);
        });
        this.config._addOnNumericSettingChangedListener(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.MaxQuality, (newValue) => {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_4__.Logger.Info('--------  Sending MaxQuality  --------');
            this._webRtcController.sendEncoderMaxQuality(newValue);
            _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_4__.Logger.Info('-------------------------------------------');
            this.config.setNumericSetting(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.CompatQualityMax, newValue);
        });
        // new quality value that gets scaled to qp for legacy reasons
        this.config._addOnNumericSettingChangedListener(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.CompatQualityMin, (newValue) => {
            newValue = 51 - (newValue / 100) * 51;
            _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_4__.Logger.Info('--------  Sending MinQP from quality value  --------');
            this._webRtcController.sendEncoderMaxQP(newValue);
            _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_4__.Logger.Info('-------------------------------------------');
        });
        this.config._addOnNumericSettingChangedListener(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.CompatQualityMax, (newValue) => {
            newValue = 51 - (newValue / 100) * 51;
            _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_4__.Logger.Info('--------  Sending MaxQP from quality value  --------');
            this._webRtcController.sendEncoderMinQP(newValue);
            _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_4__.Logger.Info('-------------------------------------------');
        });
        // WebRTC settings
        this.config._addOnNumericSettingChangedListener(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.WebRTCMinBitrate, (newValue) => {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_4__.Logger.Info('--------  Sending web rtc settings  --------');
            this._webRtcController.sendWebRTCMinBitrate(newValue * 1000 /* kbps to bps */);
            _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_4__.Logger.Info('-------------------------------------------');
        });
        this.config._addOnNumericSettingChangedListener(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.WebRTCMaxBitrate, (newValue) => {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_4__.Logger.Info('--------  Sending web rtc settings  --------');
            this._webRtcController.sendWebRTCMaxBitrate(newValue * 1000 /* kbps to bps */);
            _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_4__.Logger.Info('-------------------------------------------');
        });
        this.config._addOnNumericSettingChangedListener(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.WebRTCFPS, (newValue) => {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_4__.Logger.Info('--------  Sending web rtc settings  --------');
            this._webRtcController.sendWebRTCFps(newValue);
            _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_4__.Logger.Info('-------------------------------------------');
        });
        this.config._addOnOptionSettingChangedListener(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.OptionParameters.PreferredCodec, (newValue) => {
            if (this._webRtcController) {
                this._webRtcController.setPreferredCodec(newValue);
            }
        });
        this.config._registerOnChangeEvents(this._eventEmitter);
    }
    /**
     * Set the input control ownership
     * @param inputControlOwnership - does the user have input control ownership
     */
    _onInputControlOwnership(inputControlOwnership) {
        this._inputController = inputControlOwnership;
    }
    /**
     * Instantiate the WebRTCPlayerController interface to provide WebRTCPlayerController functionality within this class and set up anything that requires it
     * @param webRtcPlayerController - a WebRtcPlayerController controller instance
     */
    setWebRtcPlayerController(webRtcPlayerController) {
        this._webRtcController = webRtcPlayerController;
        this._webRtcController.setPreferredCodec(this.config.getSettingOption(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.OptionParameters.PreferredCodec).selected);
        this._webRtcController.resizePlayerStyle();
        // connect if auto connect flag is enabled
        this.checkForAutoConnect();
    }
    /**
     * Connect to signaling server.
     */
    connect() {
        this._eventEmitter.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.StreamPreConnectEvent());
        this._webRtcController.connectToSignallingServer();
    }
    /**
     * Reconnects to the signaling server. If connection is up, disconnects first
     * before establishing a new connection
     */
    reconnect() {
        this._eventEmitter.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.StreamReconnectEvent());
        this._webRtcController.tryReconnect('Reconnecting...');
    }
    /**
     * Disconnect from the signaling server and close open peer connections.
     */
    disconnect() {
        this._eventEmitter.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.StreamPreDisconnectEvent());
        this._webRtcController.close();
    }
    /**
     * Play the stream. Can be called only after a peer connection has been established.
     */
    play() {
        this._onStreamLoading();
        this._webRtcController.playStream();
    }
    /**
     * Auto connect if AutoConnect flag is enabled
     */
    checkForAutoConnect() {
        // set up if the auto play will be used or regular click to start
        if (this.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.Flags.AutoConnect)) {
            // if autoplaying show an info overlay while while waiting for the connection to begin
            this._onWebRtcAutoConnect();
            this._webRtcController.connectToSignallingServer();
        }
    }
    /**
     * Will unmute the microphone track which is sent to Unreal Engine.
     * By default, will only unmute an existing mic track.
     *
     * @param forceEnable Can be used for cases when this object wasn't initialized with a mic track.
     * If this parameter is true, the connection will be restarted with a microphone.
     * Warning: this takes some time, as a full renegotiation and reconnection will happen.
     */
    unmuteMicrophone(forceEnable = false) {
        // If there's an existing mic track, we just set muted state
        if (this.config.isFlagEnabled('UseMic')) {
            this.setMicrophoneMuted(false);
            return;
        }
        // If there's no pre-existing mic track, and caller is ok with full reset, we enable and reset
        if (forceEnable) {
            this.config.setFlagEnabled('UseMic', true);
            this.reconnect();
            return;
        }
        // If we prefer not to force a reconnection, just warn the user that this operation didn't happen
        _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_4__.Logger.Warning('Trying to unmute mic, but PixelStreaming was initialized with no microphone track. Call with forceEnable == true to re-connect with a mic track.');
    }
    muteMicrophone() {
        if (this.config.isFlagEnabled('UseMic')) {
            this.setMicrophoneMuted(true);
            return;
        }
        // If there wasn't a mic track, just let user know there's nothing to mute
        _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_4__.Logger.Info('Trying to mute mic, but PixelStreaming has no microphone track, so sending sound is already disabled.');
    }
    setMicrophoneMuted(mute) {
        var _a, _b, _c, _d;
        for (const transceiver of (_d = (_c = (_b = (_a = this._webRtcController) === null || _a === void 0 ? void 0 : _a.peerConnectionController) === null || _b === void 0 ? void 0 : _b.peerConnection) === null || _c === void 0 ? void 0 : _c.getTransceivers()) !== null && _d !== void 0 ? _d : []) {
            if (_Util_RTCUtils__WEBPACK_IMPORTED_MODULE_5__.RTCUtils.canTransceiverSendAudio(transceiver)) {
                transceiver.sender.track.enabled = !mute;
            }
        }
    }
    /**
     * Will unmute the video track which is sent to Unreal Engine.
     * By default, will only unmute an existing video track.
     *
     * @param forceEnable Can be used for cases when this object wasn't initialized with a video track.
     * If this parameter is true, the connection will be restarted with a camera.
     * Warning: this takes some time, as a full renegotiation and reconnection will happen.
     */
    unmuteCamera(forceEnable = false) {
        // If there's an existing video track, we just set muted state
        if (this.config.isFlagEnabled('UseCamera')) {
            this.setCameraMuted(false);
            return;
        }
        // If there's no pre-existing video track, and caller is ok with full reset, we enable and reset
        if (forceEnable) {
            this.config.setFlagEnabled('UseCamera', true);
            this.reconnect();
            return;
        }
        // If we prefer not to force a reconnection, just warn the user that this operation didn't happen
        _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_4__.Logger.Warning('Trying to unmute video, but PixelStreaming was initialized with no video track. Call with forceEnable == true to re-connect with a video track.');
    }
    muteCamera() {
        if (this.config.isFlagEnabled('UseCamera')) {
            this.setCameraMuted(true);
            return;
        }
        // If there wasn't a mic track, just let user know there's nothing to mute
        _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_4__.Logger.Info('Trying to mute camera, but PixelStreaming has no video track, so sending video is already disabled.');
    }
    setCameraMuted(mute) {
        var _a, _b, _c, _d;
        for (const transceiver of (_d = (_c = (_b = (_a = this._webRtcController) === null || _a === void 0 ? void 0 : _a.peerConnectionController) === null || _b === void 0 ? void 0 : _b.peerConnection) === null || _c === void 0 ? void 0 : _c.getTransceivers()) !== null && _d !== void 0 ? _d : []) {
            if (_Util_RTCUtils__WEBPACK_IMPORTED_MODULE_5__.RTCUtils.canTransceiverSendVideo(transceiver)) {
                transceiver.sender.track.enabled = !mute;
            }
        }
    }
    /**
     * Internal function to emit an event when auto connecting occurs
     */
    _onWebRtcAutoConnect() {
        this._eventEmitter.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.WebRtcAutoConnectEvent());
    }
    /**
     * Internal function to emit an event for when SDP negotiation is fully finished.
     */
    _onWebRtcSdp() {
        this._eventEmitter.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.WebRtcSdpEvent());
    }
    /**
     * Internal function to emit an SDP offer after it has been set.
     */
    _onWebRtcSdpOffer(offer) {
        this._eventEmitter.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.WebRtcSdpOfferEvent({ sdp: offer }));
    }
    /**
     * Internal function to emit an SDP answer after it has been set.
     */
    _onWebRtcSdpAnswer(answer) {
        this._eventEmitter.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.WebRtcSdpAnswerEvent({ sdp: answer }));
    }
    /**
     * Internal function call to emit a `latencyCalculated` event.
     */
    _onLatencyCalculated(latencyInfo) {
        this._eventEmitter.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.LatencyCalculatedEvent({ latencyInfo }));
    }
    /**
     * Internal function to emits a StreamLoading event
     */
    _onStreamLoading() {
        this._eventEmitter.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.StreamLoadingEvent());
    }
    /**
     * Event fired when the video is disconnected - emits given eventString or an override
     * message from webRtcController if one has been set
     * @param eventString - a string describing why the connection closed
     * @param allowClickToReconnect - true if we want to allow the user to retry the connection with a click
     */
    _onDisconnect(eventString, allowClickToReconnect) {
        this._eventEmitter.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.WebRtcDisconnectedEvent({
            eventString: eventString,
            allowClickToReconnect: allowClickToReconnect
        }));
    }
    /**
     * Handles when Web Rtc is connecting
     */
    _onWebRtcConnecting() {
        this._eventEmitter.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.WebRtcConnectingEvent());
    }
    /**
     * Handles when Web Rtc has connected
     */
    _onWebRtcConnected() {
        this._eventEmitter.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.WebRtcConnectedEvent());
    }
    /**
     * Handles when Web Rtc fails to connect
     */
    _onWebRtcFailed() {
        this._eventEmitter.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.WebRtcFailedEvent());
    }
    /**
     * Handle when the Video has been Initialized
     */
    _onVideoInitialized() {
        this._eventEmitter.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.VideoInitializedEvent());
        this._videoStartTime = Date.now();
    }
    /**
     * Set up functionality to happen when receiving latency test results
     * @param latency - latency test results object
     */
    _onLatencyTestResult(latencyTimings) {
        this._eventEmitter.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.LatencyTestResultEvent({ latencyTimings }));
    }
    _onDataChannelLatencyTestResponse(response) {
        this._eventEmitter.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.DataChannelLatencyTestResponseEvent({ response }));
    }
    /**
     * Set up functionality to happen when receiving video statistics
     * @param videoStats - video statistics as a aggregate stats object
     */
    _onVideoStats(videoStats) {
        // Duration
        if (!this._videoStartTime || this._videoStartTime === undefined) {
            this._videoStartTime = Date.now();
        }
        videoStats.handleSessionStatistics(this._videoStartTime, this._inputController, this._webRtcController.videoAvgQp);
        this._eventEmitter.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.StatsReceivedEvent({ aggregatedStats: videoStats }));
    }
    /**
     * Set up functionality to happen when calculating the average video encoder qp
     * @param QP - the quality number of the stream
     */
    _onVideoEncoderAvgQP(QP) {
        this._eventEmitter.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.VideoEncoderAvgQPEvent({ avgQP: QP }));
    }
    /**
     * Set up functionality to happen when receiving and handling initial settings for the UE app
     * @param settings - initial UE app settings
     */
    _onInitialSettings(settings) {
        var _a;
        this._eventEmitter.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.InitialSettingsEvent({ settings }));
        if (settings.PixelStreamingSettings) {
            this.allowConsoleCommands = (_a = settings.PixelStreamingSettings.AllowPixelStreamingCommands) !== null && _a !== void 0 ? _a : false;
            if (this.allowConsoleCommands === false) {
                _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_4__.Logger.Info('-AllowPixelStreamingCommands=false, sending arbitrary console commands from browser to UE is disabled.');
            }
        }
        const useUrlParams = this.config.useUrlParams;
        const urlParams = new _Util_IURLSearchParams__WEBPACK_IMPORTED_MODULE_6__.IURLSearchParams(window.location.search);
        _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_4__.Logger.Info(`using URL parameters ${useUrlParams}`);
        if (settings.EncoderSettings) {
            // here we should either get Min/MaxQP from PS1
            // or Min/MaxQuality from PS2
            // we only want to set one set or the other as they converge in CompatQualityMin/Max and
            // we dont want to have them conflict with default values.
            if (settings.EncoderSettings.MinQP) {
                this.config.setNumericSetting(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.MinQP, 
                // If a setting is set in the URL, make sure we respect that value as opposed to what the application sends us
                useUrlParams && urlParams.has(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.MinQP)
                    ? Number.parseFloat(urlParams.get(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.MinQP))
                    : settings.EncoderSettings.MinQP || 0);
                this.config.setNumericSetting(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.MaxQP, useUrlParams && urlParams.has(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.MaxQP)
                    ? Number.parseFloat(urlParams.get(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.MaxQP))
                    : settings.EncoderSettings.MaxQP || 51);
            }
            if (settings.EncoderSettings.MinQuality) {
                this.config.setNumericSetting(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.MinQuality, 
                // If a setting is set in the URL, make sure we respect that value as opposed to what the application sends us
                useUrlParams && urlParams.has(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.MinQuality)
                    ? Number.parseFloat(urlParams.get(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.MinQuality))
                    : settings.EncoderSettings.MinQuality || 0);
                this.config.setNumericSetting(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.MaxQuality, useUrlParams && urlParams.has(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.MaxQuality)
                    ? Number.parseFloat(urlParams.get(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.MaxQuality))
                    : settings.EncoderSettings.MaxQuality || 100);
            }
            // these two are just used to converge quality and qp and behave slightly differently since they
            // shouldnt exist in EncoderSettings
            if (useUrlParams) {
                if (urlParams.has(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.CompatQualityMin)) {
                    this.config.setNumericSetting(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.CompatQualityMin, Number.parseFloat(urlParams.get(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.CompatQualityMin)));
                }
                if (urlParams.has(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.CompatQualityMax)) {
                    this.config.setNumericSetting(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.CompatQualityMax, Number.parseFloat(urlParams.get(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.CompatQualityMax)));
                }
            }
        }
        if (settings.WebRTCSettings) {
            this.config.setNumericSetting(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.WebRTCMinBitrate, useUrlParams && urlParams.has(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.WebRTCMinBitrate)
                ? Number.parseFloat(urlParams.get(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.WebRTCMinBitrate))
                : settings.WebRTCSettings.MinBitrate / 1000 /* bps to kbps */);
            this.config.setNumericSetting(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.WebRTCMaxBitrate, useUrlParams && urlParams.has(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.WebRTCMaxBitrate)
                ? Number.parseFloat(urlParams.get(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.WebRTCMaxBitrate))
                : settings.WebRTCSettings.MaxBitrate / 1000 /* bps to kbps */);
            this.config.setNumericSetting(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.WebRTCFPS, useUrlParams && urlParams.has(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.WebRTCFPS)
                ? Number.parseFloat(urlParams.get(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.NumericParameters.WebRTCFPS))
                : settings.WebRTCSettings.FPS);
        }
    }
    /**
     * Set up functionality to happen when setting quality control ownership of a stream
     * @param hasQualityOwnership - does this user have quality ownership of the stream true / false
     */
    _onQualityControlOwnership(hasQualityOwnership) {
        this.config.setFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_3__.Flags.IsQualityController, hasQualityOwnership);
    }
    _onPlayerCount(playerCount) {
        this._eventEmitter.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.PlayerCountEvent({ count: playerCount }));
    }
    _onSubscribeFailed(message) {
        this._eventEmitter.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.SubscribeFailedEvent({ message: message }));
    }
    // Sets up to emit the webrtc tcp relay detect event
    _setupWebRtcTCPRelayDetection(statsReceivedEvent) {
        // Get the active candidate pair
        const activeCandidatePair = statsReceivedEvent.data.aggregatedStats.getActiveCandidatePair();
        // Check if the active candidate pair is not null
        if (activeCandidatePair != null) {
            // Get the local candidate assigned to the active candidate pair
            const localCandidate = statsReceivedEvent.data.aggregatedStats.localCandidates.find((candidate) => candidate.id == activeCandidatePair.localCandidateId, null);
            // Check if the local candidate is not null, candidate type is relay and the relay protocol is tcp
            if (localCandidate != null &&
                localCandidate.candidateType == 'relay' &&
                localCandidate.relayProtocol == 'tcp') {
                // Send the web rtc tcp relay detected event
                this._eventEmitter.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.WebRtcTCPRelayDetectedEvent());
            }
            // The check is completed and the stats listen event can be removed
            this._eventEmitter.removeEventListener('statsReceived', this._setupWebRtcTCPRelayDetection);
        }
    }
    /**
     * Request a connection latency test.
     * NOTE: There are plans to refactor all request* functions. Expect changes if you use this!
     * @returns
     */
    requestLatencyTest() {
        if (!this._webRtcController.videoPlayer.isVideoReady()) {
            return false;
        }
        this._webRtcController.sendLatencyTest();
        return true;
    }
    /**
     * Request a data channel latency test.
     * NOTE: There are plans to refactor all request* functions. Expect changes if you use this!
     */
    requestDataChannelLatencyTest(config) {
        if (!this._webRtcController.videoPlayer.isVideoReady()) {
            return false;
        }
        if (!this._dataChannelLatencyTestController) {
            this._dataChannelLatencyTestController = new _DataChannel_DataChannelLatencyTestController__WEBPACK_IMPORTED_MODULE_7__.DataChannelLatencyTestController(this._webRtcController.sendDataChannelLatencyTest.bind(this._webRtcController), (result) => {
                this._eventEmitter.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.DataChannelLatencyTestResultEvent({ result }));
            });
            this.addEventListener('dataChannelLatencyTestResponse', ({ data: { response } }) => {
                this._dataChannelLatencyTestController.receive(response);
            });
        }
        return this._dataChannelLatencyTestController.start(config);
    }
    /**
     * Request for the UE application to show FPS counter.
     * NOTE: There are plans to refactor all request* functions. Expect changes if you use this!
     * @returns
     */
    requestShowFps() {
        if (!this._webRtcController.videoPlayer.isVideoReady()) {
            return false;
        }
        this._webRtcController.sendShowFps();
        return true;
    }
    /**
     * Request for a new IFrame from the UE application.
     * NOTE: There are plans to refactor all request* functions. Expect changes if you use this!
     * @returns
     */
    requestIframe() {
        if (!this._webRtcController.videoPlayer.isVideoReady()) {
            return false;
        }
        this._webRtcController.sendIframeRequest();
        return true;
    }
    /**
     * Send data to UE application. The data will be run through JSON.stringify() so e.g. strings
     * and any serializable plain JSON objects with no recurrence can be sent.
     * @returns true if succeeded, false if rejected
     */
    emitUIInteraction(descriptor) {
        if (!this._webRtcController.videoPlayer.isVideoReady()) {
            return false;
        }
        this._webRtcController.emitUIInteraction(descriptor);
        return true;
    }
    /**
     * Send a command to UE application. Blocks ConsoleCommand descriptors unless UE
     * has signaled that it allows console commands.
     * @returns true if succeeded, false if rejected
     */
    emitCommand(descriptor) {
        if (!this._webRtcController.videoPlayer.isVideoReady()) {
            return false;
        }
        if (!this.allowConsoleCommands && 'ConsoleCommand' in descriptor) {
            return false;
        }
        this._webRtcController.emitCommand(descriptor);
        return true;
    }
    /**
     * Send a console command to UE application. Only allowed if UE has signaled that it allows
     * console commands.
     * @returns true if succeeded, false if rejected
     */
    emitConsoleCommand(command) {
        if (!this.allowConsoleCommands || !this._webRtcController.videoPlayer.isVideoReady()) {
            return false;
        }
        this._webRtcController.emitConsoleCommand(command);
        return true;
    }
    /**
     * Sets the text contents of the currently focused UE text box widget.
     * @param contents The new contents of the UE text box.
     * @returns True if the message could be sent.
     */
    sendTextboxEntry(contents) {
        if (!this._webRtcController.videoPlayer.isVideoReady()) {
            return false;
        }
        this._webRtcController.sendTextboxEntry(contents);
        return true;
    }
    /**
     * Add a UE -> browser response event listener
     * @param name - The name of the response handler
     * @param listener - The method to be activated when a message is received
     */
    addResponseEventListener(name, listener) {
        this._webRtcController.responseController.addResponseEventListener(name, listener);
    }
    /**
     * Remove a UE -> browser response event listener
     * @param name - The name of the response handler
     */
    removeResponseEventListener(name) {
        this._webRtcController.responseController.removeResponseEventListener(name);
    }
    /**
     * Dispatch a new event.
     * @param e event
     * @returns
     */
    dispatchEvent(e) {
        return this._eventEmitter.dispatchEvent(e);
    }
    /**
     * Register an event handler.
     * @param type event name
     * @param listener event handler function
     */
    addEventListener(type, listener) {
        this._eventEmitter.addEventListener(type, listener);
    }
    /**
     * Remove an event handler.
     * @param type event name
     * @param listener event handler function
     */
    removeEventListener(type, listener) {
        this._eventEmitter.removeEventListener(type, listener);
    }
    /**
     * Enable/disable XR mode.
     */
    toggleXR() {
        this.webXrController.xrClicked();
    }
    /**
     * Pass in a function to generate a signalling server URL.
     * This function is useful if you need to programmatically construct your signalling server URL.
     * @param signallingUrlBuilderFunc A function that generates a signalling server url.
     */
    setSignallingUrlBuilder(signallingUrlBuilderFunc) {
        this._webRtcController.signallingUrlBuilder = signallingUrlBuilderFunc;
    }
    get webRtcController() {
        return this._webRtcController;
    }
    /**
     * Public getter for the websocket controller. Access to this property allows you to send
     * custom websocket messages.
     */
    get signallingProtocol() {
        return this._webRtcController.protocol;
    }
    /**
     * Public getter for the webXrController controller. Used for all XR features.
     */
    get webXrController() {
        return this._webXrController;
    }
    registerMessageHandler(name, direction, handler) {
        if (direction === _UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_8__.MessageDirection.FromStreamer && typeof handler === 'undefined') {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_4__.Logger.Warning(`Unable to register an undefined handler for ${name}`);
            return;
        }
        if (direction === _UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_8__.MessageDirection.ToStreamer && typeof handler === 'undefined') {
            this._webRtcController.streamMessageController.registerMessageHandler(direction, name, (data) => this._webRtcController.sendMessageController.sendMessageToStreamer(name, data));
        }
        else {
            this._webRtcController.streamMessageController.registerMessageHandler(direction, name, (data) => handler(data));
        }
    }
    get toStreamerHandlers() {
        return this._webRtcController.streamMessageController.toStreamerHandlers;
    }
    isReconnecting() {
        return this._webRtcController.isReconnecting;
    }
}
//# sourceMappingURL=PixelStreaming.js.map

/***/ }),

/***/ 6456:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ResponseController": () => (/* binding */ ResponseController)
/* harmony export */ });
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7800);
// Copyright Epic Games, Inc. All Rights Reserved.

class ResponseController {
    constructor() {
        this.responseEventListeners = new Map();
    }
    /**
     * Add a response event listener to the response map
     * @param name - The name of the response
     * @param listener - The method to be activated when the response is selected
     */
    addResponseEventListener(name, listener) {
        this.responseEventListeners.set(name, listener);
    }
    /**
     * Remove a response event listener to the response map
     * @param name - The name of the response
     */
    removeResponseEventListener(name) {
        this.responseEventListeners.delete(name);
    }
    /**
     * Handle a response when receiving one form the streamer
     * @param message - Data received from the data channel with the command in question
     */
    onResponse(message) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_0__.Logger.Info('DataChannelReceiveMessageType.Response');
        const responses = new TextDecoder('utf-16').decode(message.slice(1));
        _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_0__.Logger.Info(responses);
        this.responseEventListeners.forEach((listener) => {
            listener(responses);
        });
    }
}
//# sourceMappingURL=ResponseController.js.map

/***/ }),

/***/ 4477:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SendMessageController": () => (/* binding */ SendMessageController)
/* harmony export */ });
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7800);
// Copyright Epic Games, Inc. All Rights Reserved.

class SendMessageController {
    /**
     * @param dataChannelSender - Data channel instance
     * @param toStreamerMessagesMapProvider - Stream Messages instance
     */
    constructor(dataChannelSender, toStreamerMessagesMapProvider) {
        this.dataChannelSender = dataChannelSender;
        this.toStreamerMessagesMapProvider = toStreamerMessagesMapProvider;
    }
    /**
     * Send a message to the streamer through the data channel
     * @param messageType - the type of message we are sending
     * @param messageData - the message data we are sending over the data channel
     * @returns - nil
     */
    sendMessageToStreamer(messageType, messageData) {
        if (messageData === undefined) {
            messageData = [];
        }
        const toStreamerMessages = this.toStreamerMessagesMapProvider.toStreamerMessages;
        const messageFormat = toStreamerMessages.get(messageType);
        if (messageFormat === undefined) {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_0__.Logger.Error(`Attempted to send a message to the streamer with message type: ${messageType}, but the frontend hasn't been configured to send such a message. Check you've added the message type in your cpp`);
            return;
        }
        if (messageFormat.structure && messageData && messageFormat.structure.length !== messageData.length) {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_0__.Logger.Error(`Provided message data doesn't match expected layout. Expected [ ${messageFormat.structure
                .map((element) => {
                switch (element) {
                    case 'uint8':
                    case 'uint16':
                    case 'int16':
                    case 'float':
                    case 'double':
                    default:
                        return 'number';
                    case 'string':
                        return 'string';
                }
            })
                .toString()} ] but received [ ${messageData.map((element) => typeof element).toString()} ]`);
            return;
        }
        let byteLength = 0;
        const textEncoder = new TextEncoder();
        // One loop to calculate the length in bytes of all of the provided data
        messageData.forEach((element, idx) => {
            const type = messageFormat.structure[idx];
            switch (type) {
                case 'uint8':
                    byteLength += 1;
                    break;
                case 'uint16':
                    byteLength += 2;
                    break;
                case 'int16':
                    byteLength += 2;
                    break;
                case 'float':
                    byteLength += 4;
                    break;
                case 'double':
                    byteLength += 8;
                    break;
                case 'string':
                    // 2 bytes for string length
                    byteLength += 2;
                    // 2 bytes per characters
                    byteLength += 2 * textEncoder.encode(element).length;
                    break;
            }
        });
        const data = new DataView(new ArrayBuffer(byteLength + 1));
        data.setUint8(0, messageFormat.id);
        let byteOffset = 1;
        messageData.forEach((element, idx) => {
            const type = messageFormat.structure[idx];
            switch (type) {
                case 'uint8':
                    data.setUint8(byteOffset, element);
                    byteOffset += 1;
                    break;
                case 'uint16':
                    data.setUint16(byteOffset, element, true);
                    byteOffset += 2;
                    break;
                case 'int16':
                    data.setInt16(byteOffset, element, true);
                    byteOffset += 2;
                    break;
                case 'float':
                    data.setFloat32(byteOffset, element, true);
                    byteOffset += 4;
                    break;
                case 'double':
                    data.setFloat64(byteOffset, element, true);
                    byteOffset += 8;
                    break;
                case 'string':
                    data.setUint16(byteOffset, element.length, true);
                    byteOffset += 2;
                    for (let i = 0; i < element.length; i++) {
                        data.setUint16(byteOffset, element.charCodeAt(i), true);
                        byteOffset += 2;
                    }
                    break;
            }
        });
        if (!this.dataChannelSender.canSend()) {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_0__.Logger.Info(`Data channel cannot send yet, skipping sending message: ${messageType} - ${new Uint8Array(data.buffer)}`);
            return;
        }
        this.dataChannelSender.sendData(data.buffer);
    }
}
//# sourceMappingURL=SendMessageController.js.map

/***/ }),

/***/ 180:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MessageDirection": () => (/* binding */ MessageDirection),
/* harmony export */   "StreamMessageController": () => (/* binding */ StreamMessageController),
/* harmony export */   "ToStreamerMessage": () => (/* binding */ ToStreamerMessage)
/* harmony export */ });
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7800);
// Copyright Epic Games, Inc. All Rights Reserved.

class ToStreamerMessage {
}
class StreamMessageController {
    constructor() {
        this.toStreamerHandlers = new Map();
        this.fromStreamerHandlers = new Map();
        this.toStreamerMessages = new Map();
        this.fromStreamerMessages = new Map();
    }
    /**
     * Populate the Default message protocol
     */
    populateDefaultProtocol() {
        /*
         * Control Messages. Range = 0..49.
         */
        this.toStreamerMessages.set('IFrameRequest', {
            id: 0,
            structure: []
        });
        this.toStreamerMessages.set('RequestQualityControl', {
            id: 1,
            structure: []
        });
        this.toStreamerMessages.set('FpsRequest', {
            id: 2,
            structure: []
        });
        this.toStreamerMessages.set('AverageBitrateRequest', {
            id: 3,
            structure: []
        });
        this.toStreamerMessages.set('StartStreaming', {
            id: 4,
            structure: []
        });
        this.toStreamerMessages.set('StopStreaming', {
            id: 5,
            structure: []
        });
        this.toStreamerMessages.set('LatencyTest', {
            id: 6,
            structure: ['string']
        });
        this.toStreamerMessages.set('RequestInitialSettings', {
            id: 7,
            structure: []
        });
        this.toStreamerMessages.set('TestEcho', {
            id: 8,
            structure: []
        });
        this.toStreamerMessages.set('DataChannelLatencyTest', {
            id: 9,
            structure: []
        });
        /*
         * Input Messages. Range = 50..89.
         */
        // Generic Input Messages. Range = 50..59.
        this.toStreamerMessages.set('UIInteraction', {
            id: 50,
            structure: ['string']
        });
        this.toStreamerMessages.set('Command', {
            id: 51,
            structure: ['string']
        });
        this.toStreamerMessages.set('TextboxEntry', {
            id: 52,
            structure: ['string']
        });
        // Keyboard Input Message. Range = 60..69.
        this.toStreamerMessages.set('KeyDown', {
            id: 60,
            //            keyCode  isRepeat
            structure: ['uint8', 'uint8']
        });
        this.toStreamerMessages.set('KeyUp', {
            id: 61,
            //            keyCode
            structure: ['uint8']
        });
        this.toStreamerMessages.set('KeyPress', {
            id: 62,
            //            charcode
            structure: ['uint16']
        });
        // Mouse Input Messages. Range = 70..79.
        this.toStreamerMessages.set('MouseEnter', {
            id: 70,
            structure: []
        });
        this.toStreamerMessages.set('MouseLeave', {
            id: 71,
            structure: []
        });
        this.toStreamerMessages.set('MouseDown', {
            id: 72,
            //              button     x         y
            structure: ['uint8', 'uint16', 'uint16']
        });
        this.toStreamerMessages.set('MouseUp', {
            id: 73,
            //              button     x         y
            structure: ['uint8', 'uint16', 'uint16']
        });
        this.toStreamerMessages.set('MouseMove', {
            id: 74,
            //              x           y      deltaX    deltaY
            structure: ['uint16', 'uint16', 'int16', 'int16']
        });
        this.toStreamerMessages.set('MouseWheel', {
            id: 75,
            //              delta       x        y
            structure: ['int16', 'uint16', 'uint16']
        });
        this.toStreamerMessages.set('MouseDouble', {
            id: 76,
            //              button     x         y
            structure: ['uint8', 'uint16', 'uint16']
        });
        // Touch Input Messages. Range = 80..89.
        this.toStreamerMessages.set('TouchStart', {
            id: 80,
            //          numtouches(1)   x       y        idx     force     valid
            structure: ['uint8', 'uint16', 'uint16', 'uint8', 'uint8', 'uint8']
        });
        this.toStreamerMessages.set('TouchEnd', {
            id: 81,
            //          numtouches(1)   x       y        idx     force     valid
            structure: ['uint8', 'uint16', 'uint16', 'uint8', 'uint8', 'uint8']
        });
        this.toStreamerMessages.set('TouchMove', {
            id: 82,
            //          numtouches(1)   x       y       idx      force     valid
            structure: ['uint8', 'uint16', 'uint16', 'uint8', 'uint8', 'uint8']
        });
        // Gamepad Input Messages. Range = 90..99
        this.toStreamerMessages.set('GamepadConnected', {
            id: 93,
            structure: []
        });
        this.toStreamerMessages.set('GamepadButtonPressed', {
            id: 90,
            //         ctrlerId   button  isRepeat
            structure: ['uint8', 'uint8', 'uint8']
        });
        this.toStreamerMessages.set('GamepadButtonReleased', {
            id: 91,
            //         ctrlerId   button  isRepeat(0)
            structure: ['uint8', 'uint8', 'uint8']
        });
        this.toStreamerMessages.set('GamepadAnalog', {
            id: 92,
            //         ctrlerId   button  analogValue
            structure: ['uint8', 'uint8', 'double']
        });
        this.toStreamerMessages.set('GamepadDisconnected', {
            id: 94,
            //          ctrlerId
            structure: ['uint8']
        });
        this.fromStreamerMessages.set(0, 'QualityControlOwnership');
        this.fromStreamerMessages.set(1, 'Response');
        this.fromStreamerMessages.set(2, 'Command');
        this.fromStreamerMessages.set(3, 'FreezeFrame');
        this.fromStreamerMessages.set(4, 'UnfreezeFrame');
        this.fromStreamerMessages.set(5, 'VideoEncoderAvgQP');
        this.fromStreamerMessages.set(6, 'LatencyTest');
        this.fromStreamerMessages.set(7, 'InitialSettings');
        this.fromStreamerMessages.set(8, 'FileExtension');
        this.fromStreamerMessages.set(9, 'FileMimeType');
        this.fromStreamerMessages.set(10, 'FileContents');
        this.fromStreamerMessages.set(11, 'TestEcho');
        this.fromStreamerMessages.set(12, 'InputControlOwnership');
        this.fromStreamerMessages.set(13, 'GamepadResponse');
        this.fromStreamerMessages.set(14, 'DataChannelLatencyTest');
        this.fromStreamerMessages.set(255, 'Protocol');
    }
    /**
     * Register a message handler
     * @param messageDirection - the direction of the message; toStreamer or fromStreamer
     * @param messageType - the type of the message
     * @param messageHandler - the function or method to be executed when this handler is called
     */
    registerMessageHandler(messageDirection, messageType, messageHandler) {
        switch (messageDirection) {
            case MessageDirection.ToStreamer:
                this.toStreamerHandlers.set(messageType, messageHandler);
                break;
            case MessageDirection.FromStreamer:
                this.fromStreamerHandlers.set(messageType, messageHandler);
                break;
            default:
                _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_0__.Logger.Info(`Unknown message direction ${messageDirection}`);
        }
    }
}
/**
 * The enum for message directions
 */
var MessageDirection;
(function (MessageDirection) {
    MessageDirection[MessageDirection["ToStreamer"] = 0] = "ToStreamer";
    MessageDirection[MessageDirection["FromStreamer"] = 1] = "FromStreamer";
})(MessageDirection || (MessageDirection = {}));
//# sourceMappingURL=StreamMessageController.js.map

/***/ }),

/***/ 9983:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ToStreamerMessagesController": () => (/* binding */ ToStreamerMessagesController)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
class ToStreamerMessagesController {
    /**
     * @param sendMessageController - Stream message controller instance
     */
    constructor(sendMessageController) {
        this.sendMessageController = sendMessageController;
    }
    /**
     * Send Request to Take Quality Control to the UE Instance
     */
    SendRequestQualityControl() {
        this.sendMessageController.sendMessageToStreamer('RequestQualityControl');
    }
    /**
     * Send Max FPS Request to the UE Instance
     */
    SendMaxFpsRequest() {
        this.sendMessageController.sendMessageToStreamer('FpsRequest');
    }
    /**
     * Send Average Bitrate Request to the UE Instance
     */
    SendAverageBitrateRequest() {
        this.sendMessageController.sendMessageToStreamer('AverageBitrateRequest');
    }
    /**
     * Send a Start Streaming Message to the UE Instance
     */
    SendStartStreaming() {
        this.sendMessageController.sendMessageToStreamer('StartStreaming');
    }
    /**
     * Send a Stop Streaming Message to the UE Instance
     */
    SendStopStreaming() {
        this.sendMessageController.sendMessageToStreamer('StopStreaming');
    }
    /**
     * Send a Request Initial Settings to the UE Instance
     */
    SendRequestInitialSettings() {
        this.sendMessageController.sendMessageToStreamer('RequestInitialSettings');
    }
}
//# sourceMappingURL=ToStreamerMessagesController.js.map

/***/ }),

/***/ 7617:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BrowserUtils": () => (/* binding */ BrowserUtils)
/* harmony export */ });
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7800);
// Copyright Epic Games, Inc. All Rights Reserved.

class BrowserUtils {
    static getSupportedVideoCodecs() {
        const browserSupportedCodecs = [];
        // Try get the info needed from the RTCRtpReceiver. This is only available on chrome
        if (!RTCRtpReceiver.getCapabilities) {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_0__.Logger.Warning('RTCRtpReceiver.getCapabilities API is not available in your browser, defaulting to guess that we support H.264.');
            browserSupportedCodecs.push('H264 level-asymmetry-allowed=1;packetization-mode=1;profile-level-id=42e01f');
            return browserSupportedCodecs;
        }
        const matcher = /(VP\d|H26\d|AV1).*/;
        const capabilities = RTCRtpReceiver.getCapabilities('video');
        if (!capabilities) {
            browserSupportedCodecs.push('H264 level-asymmetry-allowed=1;packetization-mode=1;profile-level-id=42e01f');
            return browserSupportedCodecs;
        }
        capabilities.codecs.forEach((codec) => {
            const str = codec.mimeType.split('/')[1] + ' ' + (codec.sdpFmtpLine || '');
            const match = matcher.exec(str);
            if (match !== null) {
                browserSupportedCodecs.push(str);
            }
        });
        return browserSupportedCodecs;
    }
}
//# sourceMappingURL=BrowserUtils.js.map

/***/ }),

/***/ 5391:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AfkTimedOutEvent": () => (/* binding */ AfkTimedOutEvent),
/* harmony export */   "AfkWarningActivateEvent": () => (/* binding */ AfkWarningActivateEvent),
/* harmony export */   "AfkWarningDeactivateEvent": () => (/* binding */ AfkWarningDeactivateEvent),
/* harmony export */   "AfkWarningUpdateEvent": () => (/* binding */ AfkWarningUpdateEvent),
/* harmony export */   "DataChannelCloseEvent": () => (/* binding */ DataChannelCloseEvent),
/* harmony export */   "DataChannelErrorEvent": () => (/* binding */ DataChannelErrorEvent),
/* harmony export */   "DataChannelLatencyTestResponseEvent": () => (/* binding */ DataChannelLatencyTestResponseEvent),
/* harmony export */   "DataChannelLatencyTestResultEvent": () => (/* binding */ DataChannelLatencyTestResultEvent),
/* harmony export */   "DataChannelOpenEvent": () => (/* binding */ DataChannelOpenEvent),
/* harmony export */   "HideFreezeFrameEvent": () => (/* binding */ HideFreezeFrameEvent),
/* harmony export */   "InitialSettingsEvent": () => (/* binding */ InitialSettingsEvent),
/* harmony export */   "LatencyCalculatedEvent": () => (/* binding */ LatencyCalculatedEvent),
/* harmony export */   "LatencyTestResultEvent": () => (/* binding */ LatencyTestResultEvent),
/* harmony export */   "LoadFreezeFrameEvent": () => (/* binding */ LoadFreezeFrameEvent),
/* harmony export */   "PixelStreamingEventEmitter": () => (/* binding */ PixelStreamingEventEmitter),
/* harmony export */   "PlayStreamErrorEvent": () => (/* binding */ PlayStreamErrorEvent),
/* harmony export */   "PlayStreamEvent": () => (/* binding */ PlayStreamEvent),
/* harmony export */   "PlayStreamRejectedEvent": () => (/* binding */ PlayStreamRejectedEvent),
/* harmony export */   "PlayerCountEvent": () => (/* binding */ PlayerCountEvent),
/* harmony export */   "SettingsChangedEvent": () => (/* binding */ SettingsChangedEvent),
/* harmony export */   "ShowOnScreenKeyboardEvent": () => (/* binding */ ShowOnScreenKeyboardEvent),
/* harmony export */   "StatsReceivedEvent": () => (/* binding */ StatsReceivedEvent),
/* harmony export */   "StreamLoadingEvent": () => (/* binding */ StreamLoadingEvent),
/* harmony export */   "StreamPreConnectEvent": () => (/* binding */ StreamPreConnectEvent),
/* harmony export */   "StreamPreDisconnectEvent": () => (/* binding */ StreamPreDisconnectEvent),
/* harmony export */   "StreamReconnectEvent": () => (/* binding */ StreamReconnectEvent),
/* harmony export */   "StreamerIDChangedMessageEvent": () => (/* binding */ StreamerIDChangedMessageEvent),
/* harmony export */   "StreamerListMessageEvent": () => (/* binding */ StreamerListMessageEvent),
/* harmony export */   "SubscribeFailedEvent": () => (/* binding */ SubscribeFailedEvent),
/* harmony export */   "VideoEncoderAvgQPEvent": () => (/* binding */ VideoEncoderAvgQPEvent),
/* harmony export */   "VideoInitializedEvent": () => (/* binding */ VideoInitializedEvent),
/* harmony export */   "WebRtcAutoConnectEvent": () => (/* binding */ WebRtcAutoConnectEvent),
/* harmony export */   "WebRtcConnectedEvent": () => (/* binding */ WebRtcConnectedEvent),
/* harmony export */   "WebRtcConnectingEvent": () => (/* binding */ WebRtcConnectingEvent),
/* harmony export */   "WebRtcDisconnectedEvent": () => (/* binding */ WebRtcDisconnectedEvent),
/* harmony export */   "WebRtcFailedEvent": () => (/* binding */ WebRtcFailedEvent),
/* harmony export */   "WebRtcSdpAnswerEvent": () => (/* binding */ WebRtcSdpAnswerEvent),
/* harmony export */   "WebRtcSdpEvent": () => (/* binding */ WebRtcSdpEvent),
/* harmony export */   "WebRtcSdpOfferEvent": () => (/* binding */ WebRtcSdpOfferEvent),
/* harmony export */   "WebRtcTCPRelayDetectedEvent": () => (/* binding */ WebRtcTCPRelayDetectedEvent),
/* harmony export */   "XrFrameEvent": () => (/* binding */ XrFrameEvent),
/* harmony export */   "XrSessionEndedEvent": () => (/* binding */ XrSessionEndedEvent),
/* harmony export */   "XrSessionStartedEvent": () => (/* binding */ XrSessionStartedEvent)
/* harmony export */ });
/**
 * An event that is emitted when AFK disconnect is about to happen.
 * Can be cancelled by calling the callback function provided as part of the event.
 */
class AfkWarningActivateEvent extends Event {
    constructor(data) {
        super('afkWarningActivate');
        this.data = data;
    }
}
/**
 * An event that is emitted when the AFK disconnect countdown is updated.
 */
class AfkWarningUpdateEvent extends Event {
    constructor(data) {
        super('afkWarningUpdate');
        this.data = data;
    }
}
/**
 * An event that is emitted when AFK warning is deactivated.
 */
class AfkWarningDeactivateEvent extends Event {
    constructor() {
        super('afkWarningDeactivate');
    }
}
/**
 * An event that is emitted when AFK countdown reaches 0 and the user is disconnected.
 */
class AfkTimedOutEvent extends Event {
    constructor() {
        super('afkTimedOut');
    }
}
/**
 * An event that is emitted when we receive new video quality value.
 */
class VideoEncoderAvgQPEvent extends Event {
    constructor(data) {
        super('videoEncoderAvgQP');
        this.data = data;
    }
}
/**
 * An event that is emitted after a WebRtc connection has been negotiated.
 */
class WebRtcSdpEvent extends Event {
    constructor() {
        super('webRtcSdp');
    }
}
/**
 * An event that is emitted after the SDP answer is set.
 */
class WebRtcSdpAnswerEvent extends Event {
    constructor(data) {
        super('webRtcSdpAnswer');
        this.data = data;
    }
}
/**
 * An event that is emitted after the SDP offer is set.
 */
class WebRtcSdpOfferEvent extends Event {
    constructor(data) {
        super('webRtcSdpOffer');
        this.data = data;
    }
}
/**
 * An event that is emitted when auto connecting.
 */
class WebRtcAutoConnectEvent extends Event {
    constructor() {
        super('webRtcAutoConnect');
    }
}
/**
 * An event that is emitted when sending a WebRtc offer.
 */
class WebRtcConnectingEvent extends Event {
    constructor() {
        super('webRtcConnecting');
    }
}
/**
 * An event that is emitted when WebRtc connection has been established.
 */
class WebRtcConnectedEvent extends Event {
    constructor() {
        super('webRtcConnected');
    }
}
/**
 * An event that is emitted if WebRtc connection has failed.
 */
class WebRtcFailedEvent extends Event {
    constructor() {
        super('webRtcFailed');
    }
}
/**
 * An event that is emitted if WebRtc connection is disconnected.
 */
class WebRtcDisconnectedEvent extends Event {
    constructor(data) {
        super('webRtcDisconnected');
        this.data = data;
    }
}
/**
 * An event that is emitted when RTCDataChannel is opened.
 */
class DataChannelOpenEvent extends Event {
    constructor(data) {
        super('dataChannelOpen');
        this.data = data;
    }
}
/**
 * An event that is emitted when RTCDataChannel is closed.
 */
class DataChannelCloseEvent extends Event {
    constructor(data) {
        super('dataChannelClose');
        this.data = data;
    }
}
/**
 * An event that is emitted on RTCDataChannel errors.
 */
class DataChannelErrorEvent extends Event {
    constructor(data) {
        super('dataChannelError');
        this.data = data;
    }
}
/**
 * An event that is emitted when the video stream has been initialized.
 */
class VideoInitializedEvent extends Event {
    constructor() {
        super('videoInitialized');
    }
}
/**
 * An event that is emitted when video stream loading starts.
 */
class StreamLoadingEvent extends Event {
    constructor() {
        super('streamLoading');
    }
}
/**
 * An event that is emitted when video stream loading has finished.
 */
class StreamPreConnectEvent extends Event {
    constructor() {
        super('streamConnect');
    }
}
/**
 * An event that is emitted when video stream has stopped.
 */
class StreamPreDisconnectEvent extends Event {
    constructor() {
        super('streamDisconnect');
    }
}
/**
 * An event that is emitted when video stream is reconnecting.
 */
class StreamReconnectEvent extends Event {
    constructor() {
        super('streamReconnect');
    }
}
/**
 * An event that is emitted if there are errors loading the video stream.
 */
class PlayStreamErrorEvent extends Event {
    constructor(data) {
        super('playStreamError');
        this.data = data;
    }
}
/**
 * An event that is emitted before trying to start video playback.
 */
class PlayStreamEvent extends Event {
    constructor() {
        super('playStream');
    }
}
/**
 * An event that is emitted if the browser rejects video playback. Can happen for example if
 * video auto-play without user interaction is refused by the browser.
 */
class PlayStreamRejectedEvent extends Event {
    constructor(data) {
        super('playStreamRejected');
        this.data = data;
    }
}
/**
 * An event that is emitted when receiving a full FreezeFrame image from UE.
 */
class LoadFreezeFrameEvent extends Event {
    constructor(data) {
        super('loadFreezeFrame');
        this.data = data;
    }
}
/**
 * An event that is emitted when receiving UnfreezeFrame message from UE and video playback is about to be resumed.
 */
class HideFreezeFrameEvent extends Event {
    constructor() {
        super('hideFreezeFrame');
    }
}
/**
 * An event that is emitted when receiving WebRTC statistics.
 */
class StatsReceivedEvent extends Event {
    constructor(data) {
        super('statsReceived');
        this.data = data;
    }
}
/**
 * An event that is emitted when streamer list changes.
 */
class StreamerListMessageEvent extends Event {
    constructor(data) {
        super('streamerListMessage');
        this.data = data;
    }
}
/**
 * An event that is emitted when a subscribed to streamer's id changes.
 */
class StreamerIDChangedMessageEvent extends Event {
    constructor(data) {
        super('StreamerIDChangedMessage');
        this.data = data;
    }
}
/**
 * An event that is emitted when receiving latency test results.
 */
class LatencyTestResultEvent extends Event {
    constructor(data) {
        super('latencyTestResult');
        this.data = data;
    }
}
/**
 * An event that is emitted everytime latency is calculated using the WebRTC stats API.
 */
class LatencyCalculatedEvent extends Event {
    constructor(data) {
        super('latencyCalculated');
        this.data = data;
    }
}
/**
 * An event that is emitted when we receive the "onScreenKeyboard" command from UE.
 */
class ShowOnScreenKeyboardEvent extends Event {
    constructor(data) {
        super('showOnScreenKeyboard');
        this.data = data;
    }
}
/**
 * An event that is emitted when receiving data channel latency test response from server.
 * This event is handled by DataChannelLatencyTestController
 */
class DataChannelLatencyTestResponseEvent extends Event {
    constructor(data) {
        super('dataChannelLatencyTestResponse');
        this.data = data;
    }
}
/**
 * An event that is emitted when data channel latency test results are ready.
 */
class DataChannelLatencyTestResultEvent extends Event {
    constructor(data) {
        super('dataChannelLatencyTestResult');
        this.data = data;
    }
}
class SubscribeFailedEvent extends Event {
    constructor(data) {
        super('subscribeFailed');
        this.data = data;
    }
}
/**
 * An event that is emitted when receiving initial settings from UE.
 */
class InitialSettingsEvent extends Event {
    constructor(data) {
        super('initialSettings');
        this.data = data;
    }
}
/**
 * An event that is emitted when PixelStreaming settings change.
 */
class SettingsChangedEvent extends Event {
    constructor(data) {
        super('settingsChanged');
        this.data = data;
    }
}
/**
 * Event emitted when an XR Session starts
 */
class XrSessionStartedEvent extends Event {
    constructor() {
        super('xrSessionStarted');
    }
}
/**
 * Event emitted when an XR Session ends
 */
class XrSessionEndedEvent extends Event {
    constructor() {
        super('xrSessionEnded');
    }
}
/**
 * Event emitted when an XR Frame is complete
 */
class XrFrameEvent extends Event {
    constructor(data) {
        super('xrFrame');
        this.data = data;
    }
}
/**
 * An event that is emitted when receiving a player count from the signalling server
 */
class PlayerCountEvent extends Event {
    constructor(data) {
        super('playerCount');
        this.data = data;
    }
}
/**
 * An event that is emitted when the webRTC connections is relayed over TCP.
 */
class WebRtcTCPRelayDetectedEvent extends Event {
    constructor() {
        super('webRtcTCPRelayDetected');
    }
}
class PixelStreamingEventEmitter extends EventTarget {
    /**
     * Dispatch a new event.
     * @param e event
     * @returns
     */
    dispatchEvent(e) {
        return super.dispatchEvent(e);
    }
    /**
     * Register an event handler.
     * @param type event name
     * @param listener event handler function
     */
    addEventListener(type, listener) {
        super.addEventListener(type, listener);
    }
    /**
     * Remove an event handler.
     * @param type event name
     * @param listener event handler function
     */
    removeEventListener(type, listener) {
        super.removeEventListener(type, listener);
    }
}
//# sourceMappingURL=EventEmitter.js.map

/***/ }),

/***/ 535:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FileTemplate": () => (/* binding */ FileTemplate),
/* harmony export */   "FileUtil": () => (/* binding */ FileUtil)
/* harmony export */ });
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7800);
// Copyright Epic Games, Inc. All Rights Reserved.

/**
 * Utility function for populate file information from byte buffers.
 */
class FileUtil {
    /**
     * Processes a files extension when received over data channel
     * @param view - the file extension data
     */
    static setExtensionFromBytes(view, file) {
        // Reset file if we got a file message and we are not "receiving" it yet
        if (!file.receiving) {
            file.mimetype = '';
            file.extension = '';
            file.receiving = true;
            file.valid = false;
            file.chunks = 0;
            file.data = [];
            file.timestampStart = new Date().getTime();
            _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_0__.Logger.Info('Received first chunk of file');
        }
        const extensionAsString = new TextDecoder('utf-16').decode(view.slice(1));
        _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_0__.Logger.Info(extensionAsString);
        file.extension = extensionAsString;
    }
    /**
     * Processes a files mime type when received over data channel
     * @param view - the file mime type data
     */
    static setMimeTypeFromBytes(view, file) {
        // Reset file if we got a file message and we are not "receiving" it yet
        if (!file.receiving) {
            file.mimetype = '';
            file.extension = '';
            file.receiving = true;
            file.valid = false;
            file.chunks = 0;
            file.data = [];
            file.timestampStart = new Date().getTime();
            _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_0__.Logger.Info('Received first chunk of file');
        }
        const mimeAsString = new TextDecoder('utf-16').decode(view.slice(1));
        _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_0__.Logger.Info(mimeAsString);
        file.mimetype = mimeAsString;
    }
    /**
     * Processes a files contents when received over data channel
     * @param view - the file contents data
     */
    static setContentsFromBytes(view, file) {
        // If we haven't received the initial setup instructions, return
        if (!file.receiving)
            return;
        const typeSize = 1;
        const intSize = 4;
        const maxMessageSize = 16 * 1024;
        const headerSize = typeSize + intSize;
        const maxPayloadSize = maxMessageSize - headerSize;
        // Calculate total number of chunks from the total file size
        file.chunks = Math.ceil(new DataView(view.slice(typeSize, headerSize).buffer).getInt32(0, true) / maxPayloadSize);
        // Get the file part of the payload
        const fileBytes = view.slice(headerSize);
        // Append to existing data that holds the file
        file.data.push(fileBytes);
        // Uncomment for debug
        _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_0__.Logger.Info(`Received file chunk: ${file.data.length}/${file.chunks}`);
        if (file.data.length === file.chunks) {
            file.receiving = false;
            file.valid = true;
            _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_0__.Logger.Info('Received complete file');
            const transferDuration = new Date().getTime() - file.timestampStart;
            const transferBitrate = Math.round((file.chunks * maxMessageSize) / transferDuration);
            _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_0__.Logger.Info(`Average transfer bitrate: ${transferBitrate}kb/s over ${transferDuration / 1000} seconds`);
            // File reconstruction
            /**
             * Example code to reconstruct the file
             *
             * This code reconstructs the received data into the original file based on the mime type and extension provided and then downloads the reconstructed file
             */
            const received = new Blob(file.data, { type: file.mimetype });
            const a = document.createElement('a');
            a.setAttribute('href', URL.createObjectURL(received));
            a.setAttribute('download', `transfer.${file.extension}`);
            document.body.append(a);
            // if you are so inclined to make it auto-download, do something like: a.click();
            a.remove();
        }
        else if (file.data.length > file.chunks) {
            file.receiving = false;
            _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_0__.Logger.Error(`Received bigger file than advertised: ${file.data.length}/${file.chunks}`);
        }
    }
}
/**
 * A class that represents a template for a downloaded file
 */
class FileTemplate {
    constructor() {
        this.mimetype = '';
        this.extension = '';
        this.receiving = false;
        this.chunks = 0;
        this.data = [];
        this.valid = false;
    }
}
//# sourceMappingURL=FileUtil.js.map

/***/ }),

/***/ 7429:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "IURLSearchParams": () => (/* binding */ IURLSearchParams)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
/**
 * A case insensitive, partial implementation of URLSearchParams
 */
class IURLSearchParams {
    constructor(search) {
        this._urlParams = {};
        const urlParams = new URLSearchParams(search);
        for (const [name, value] of urlParams) {
            this._urlParams[name.toLowerCase()] = value;
        }
    }
    has(name) {
        return name.toLowerCase() in this._urlParams;
    }
    get(name) {
        if (this.has(name)) {
            return this._urlParams[name.toLowerCase()];
        }
        return null;
    }
}
//# sourceMappingURL=IURLSearchParams.js.map

/***/ }),

/***/ 3754:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "InputCoordTranslator": () => (/* binding */ InputCoordTranslator)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
/**
 * Converts coordinates from element relative coordinates to values normalized within the value range of a short (and back again)
 */
class InputCoordTranslator {
    // we dont use a constructor here because the object is created and passed around to various locations
    // possibly before this method is called.
    reconfigure(playerSize, videoSize) {
        const playerAspectRatio = playerSize.height / playerSize.width;
        const videoAspectRatio = videoSize.height / videoSize.width;
        this.playerIsLarger = playerAspectRatio > videoAspectRatio;
        this.playerSize = playerSize;
        this.ratio = this.playerIsLarger
            ? playerAspectRatio / videoAspectRatio
            : videoAspectRatio / playerAspectRatio;
    }
    translateUnsigned(x, y) {
        const normalizedX = this.playerIsLarger
            ? x / this.playerSize.width
            : this.ratio * (x / this.playerSize.width - 0.5) + 0.5;
        const normalizedY = this.playerIsLarger
            ? this.ratio * (y / this.playerSize.height - 0.5) + 0.5
            : y / this.playerSize.height;
        if (normalizedX < 0.0 || normalizedX > 1.0 || normalizedY < 0.0 || normalizedY > 1.0) {
            return { inRange: false, x: 65535, y: 65535 };
        }
        else {
            return { inRange: true, x: normalizedX * 65536, y: normalizedY * 65536 };
        }
    }
    translateSigned(x, y) {
        const normalizedX = this.playerIsLarger
            ? x / (0.5 * this.playerSize.width)
            : (this.ratio * x) / (0.5 * this.playerSize.width);
        const normalizedY = this.playerIsLarger
            ? (this.ratio * y) / (0.5 * this.playerSize.height)
            : y / (0.5 * this.playerSize.height);
        return { x: normalizedX * 32767, y: normalizedY * 32767 };
    }
    untranslateUnsigned(x, y) {
        const normalizedX = this.playerIsLarger ? x / 65536 : (x / 65536 - 0.5) / this.ratio + 0.5;
        const normalizedY = this.playerIsLarger ? (y / 65536 - 0.5) / this.ratio + 0.5 : y / 65536;
        return { x: normalizedX * this.playerSize.width, y: normalizedY * this.playerSize.height };
    }
}
//# sourceMappingURL=InputCoordTranslator.js.map

/***/ }),

/***/ 4412:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RTCUtils": () => (/* binding */ RTCUtils)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
class RTCUtils {
    static isVideoTransceiver(transceiver) {
        return this.canTransceiverReceiveVideo(transceiver) || this.canTransceiverSendVideo(transceiver);
    }
    static canTransceiverReceiveVideo(transceiver) {
        return (!!transceiver &&
            (transceiver.direction === 'sendrecv' || transceiver.direction === 'recvonly') &&
            transceiver.receiver &&
            transceiver.receiver.track &&
            transceiver.receiver.track.kind === 'video');
    }
    static canTransceiverSendVideo(transceiver) {
        return (!!transceiver &&
            (transceiver.direction === 'sendrecv' || transceiver.direction === 'sendonly') &&
            transceiver.sender &&
            transceiver.sender.track &&
            transceiver.sender.track.kind === 'video');
    }
    static isAudioTransceiver(transceiver) {
        return this.canTransceiverReceiveAudio(transceiver) || this.canTransceiverSendAudio(transceiver);
    }
    static canTransceiverReceiveAudio(transceiver) {
        return (!!transceiver &&
            (transceiver.direction === 'sendrecv' || transceiver.direction === 'recvonly') &&
            transceiver.receiver &&
            transceiver.receiver.track &&
            transceiver.receiver.track.kind === 'audio');
    }
    static canTransceiverSendAudio(transceiver) {
        return (!!transceiver &&
            (transceiver.direction === 'sendrecv' || transceiver.direction === 'sendonly') &&
            transceiver.sender &&
            transceiver.sender.track &&
            transceiver.sender.track.kind === 'audio');
    }
}
//# sourceMappingURL=RTCUtils.js.map

/***/ }),

/***/ 1362:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "StreamController": () => (/* binding */ StreamController)
/* harmony export */ });
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7800);
// Copyright Epic Games, Inc. All Rights Reserved.

/**
 * Video Player Controller handles the creation of the video HTML element and all handlers
 */
class StreamController {
    /**
     * @param videoElementProvider Video Player instance
     */
    constructor(videoElementProvider) {
        this.videoElementProvider = videoElementProvider;
        this.audioElement = document.createElement('Audio');
        this.videoElementProvider.setAudioElement(this.audioElement);
    }
    /**
     * Handles when the Peer connection has a track event
     * @param rtcTrackEvent - RTC Track Event
     */
    handleOnTrack(rtcTrackEvent) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_0__.Logger.Info('handleOnTrack ' + JSON.stringify(rtcTrackEvent.streams));
        // Do not add the track if the ID is `probator` as this is special track created by mediasoup for bitrate probing.
        // Refer to https://github.com/EpicGamesExt/PixelStreamingInfrastructure/pull/86 for more details.
        if (rtcTrackEvent.streams.length < 1 || rtcTrackEvent.streams[0].id == 'probator') {
            return;
        }
        const videoElement = this.videoElementProvider.getVideoElement();
        if (rtcTrackEvent.track) {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_0__.Logger.Info('Got track - ' +
                rtcTrackEvent.track.kind +
                ' id=' +
                rtcTrackEvent.track.id +
                ' readyState=' +
                rtcTrackEvent.track.readyState);
        }
        if (rtcTrackEvent.track.kind == 'audio') {
            this.CreateAudioTrack(rtcTrackEvent.streams[0]);
            return;
        }
        else if (rtcTrackEvent.track.kind == 'video' &&
            videoElement.srcObject !== rtcTrackEvent.streams[0]) {
            videoElement.srcObject = rtcTrackEvent.streams[0];
            _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_0__.Logger.Info('Set video source from video track ontrack.');
            return;
        }
    }
    /**
     * Creates the audio device when receiving an RTCTrackEvent with the kind of "audio"
     * @param audioMediaStream - Audio Media stream track
     */
    CreateAudioTrack(audioMediaStream) {
        const videoElement = this.videoElementProvider.getVideoElement();
        // do nothing the video has the same media stream as the audio track we have here (they are linked)
        if (videoElement.srcObject == audioMediaStream) {
            return;
        }
        // video element has some other media stream that is not associated with this audio track
        else if (videoElement.srcObject && videoElement.srcObject !== audioMediaStream) {
            // create a new audio element
            this.audioElement.srcObject = audioMediaStream;
            _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_0__.Logger.Info('Created new audio element to play separate audio stream.');
        }
    }
}
//# sourceMappingURL=StreamController.js.map

/***/ }),

/***/ 9499:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "VideoPlayer": () => (/* binding */ VideoPlayer)
/* harmony export */ });
/* harmony import */ var _Config_Config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7463);
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7800);
// Copyright Epic Games, Inc. All Rights Reserved.


/**
 * The video player html element
 */
class VideoPlayer {
    /**
     * @param videoElementParent the html div the the video player will be injected into
     * @param config the applications configuration. We're interested in the startVideoMuted flag
     */
    constructor(videoElementParent, config) {
        this.lastTimeResized = new Date().getTime();
        this.videoElement = document.createElement('video');
        this.config = config;
        this.videoElement.id = 'streamingVideo';
        this.videoElement.disablePictureInPicture = true;
        this.videoElement.playsInline = true;
        this.videoElement.style.width = '100%';
        this.videoElement.style.height = '100%';
        this.videoElement.style.position = 'absolute';
        this.videoElement.style.pointerEvents = 'all';
        videoElementParent.appendChild(this.videoElement);
        this.onResizePlayerCallback = () => {
            console.log('Resolution changed, restyling player, did you forget to override this function?');
        };
        this.onMatchViewportResolutionCallback = () => {
            console.log('Resolution changed and match viewport resolution is turned on, did you forget to override this function?');
        };
        // set play for video (and audio)
        this.videoElement.onclick = () => {
            if (this.audioElement != undefined && this.audioElement.paused) {
                this.audioElement.play();
            }
            if (this.videoElement.paused) {
                this.videoElement.play();
            }
        };
        this.videoElement.onloadedmetadata = () => {
            this.onVideoInitialized();
        };
        // set resize events to the windows if it is resized or its orientation is changed
        window.addEventListener('resize', () => this.resizePlayerStyle(), true);
        window.addEventListener('orientationchange', () => this.onOrientationChange());
    }
    destroy() {
        this.videoElement.src = '';
        this.videoElement.srcObject = null;
        this.videoElement.remove();
        if (this.audioElement) {
            this.audioElement.src = '';
            this.audioElement.srcObject = null;
            this.audioElement.remove();
        }
    }
    setAudioElement(audioElement) {
        this.audioElement = audioElement;
    }
    /**
     * Sets up the video element with any application config and plays the video element.
     * @returns A promise for if playing the video was successful or not.
     */
    play() {
        this.videoElement.muted = this.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_0__.Flags.StartVideoMuted);
        this.videoElement.autoplay = this.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_0__.Flags.AutoPlayVideo);
        return this.videoElement.play();
    }
    /**
     * @returns True if the video element is paused.
     */
    isPaused() {
        return this.videoElement.paused;
    }
    /**
     * @returns - whether the video element is playing.
     */
    isVideoReady() {
        return this.videoElement.readyState !== undefined && this.videoElement.readyState > 0;
    }
    /**
     * @returns True if the video element has a valid video source (srcObject).
     */
    hasVideoSource() {
        return this.videoElement.srcObject !== undefined && this.videoElement.srcObject !== null;
    }
    /**
     * Get the current context of the html video element
     * @returns - the current context of the video element
     */
    getVideoElement() {
        return this.videoElement;
    }
    /**
     * Get the current context of the html video elements parent
     * @returns - the current context of the video elements parent
     */
    getVideoParentElement() {
        var _a;
        return (_a = this.videoElement.parentElement) !== null && _a !== void 0 ? _a : undefined;
    }
    /**
     * Set the Video Elements src object tracks to enable
     * @param enabled - Enable Tracks on the Src Object
     */
    setVideoEnabled(enabled) {
        // this is a temporary hack until type scripts video element is updated to reflect the need for tracks on a html video element
        const videoElement = this.videoElement;
        videoElement.srcObject
            .getTracks()
            .forEach((track) => (track.enabled = enabled));
    }
    /**
     * An override for when the video has been initialized with a srcObject
     */
    onVideoInitialized() {
        // Default Functionality: Do Nothing
    }
    /**
     * On the orientation change of a window clear the timeout
     */
    onOrientationChange() {
        clearTimeout(this.orientationChangeTimeout);
        this.orientationChangeTimeout = window.setTimeout(() => {
            this.resizePlayerStyle();
        }, 500);
    }
    /**
     * Resizes the player style based on the window height and width
     * @returns - nil if requirements are satisfied
     */
    resizePlayerStyle() {
        const videoElementParent = this.getVideoParentElement();
        if (!videoElementParent) {
            return;
        }
        this.updateVideoStreamSize();
        if (videoElementParent.classList.contains('fixed-size')) {
            this.onResizePlayerCallback();
            return;
        }
        // controls for resizing the player
        this.resizePlayerStyleToFillParentElement();
        this.onResizePlayerCallback();
    }
    /**
     * Resizes the player element to fill the parent element
     */
    resizePlayerStyleToFillParentElement() {
        const videoElementParent = this.getVideoParentElement();
        //Video is not initialized yet so set videoElementParent to size of parent element
        const styleWidth = '100%';
        const styleHeight = '100%';
        const styleTop = 0;
        const styleLeft = 0;
        videoElementParent.setAttribute('style', 'top: ' +
            styleTop +
            'px; left: ' +
            styleLeft +
            'px; width: ' +
            styleWidth +
            '; height: ' +
            styleHeight +
            '; cursor: default;');
    }
    updateVideoStreamSize() {
        if (!this.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_0__.Flags.MatchViewportResolution)) {
            return;
        }
        const now = new Date().getTime();
        if (now - this.lastTimeResized > 300) {
            const videoElementParent = this.getVideoParentElement();
            if (!videoElementParent) {
                return;
            }
            this.onMatchViewportResolutionCallback(videoElementParent.clientWidth, videoElementParent.clientHeight);
            this.lastTimeResized = new Date().getTime();
        }
        else {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_1__.Logger.Info('Resizing too often - skipping');
            clearTimeout(this.resizeTimeoutHandle);
            this.resizeTimeoutHandle = window.setTimeout(() => this.updateVideoStreamSize(), 100);
        }
    }
}
//# sourceMappingURL=VideoPlayer.js.map

/***/ }),

/***/ 5750:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "WebRtcPlayerController": () => (/* binding */ WebRtcPlayerController)
/* harmony export */ });
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(3457);
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(9761);
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(7610);
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(3665);
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(7800);
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(6292);
/* harmony import */ var _VideoPlayer_StreamController__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(1362);
/* harmony import */ var _FreezeFrame_FreezeFrameController__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(742);
/* harmony import */ var _AFK_AFKController__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(295);
/* harmony import */ var _DataChannel_DataChannelController__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(7748);
/* harmony import */ var _PeerConnectionController_PeerConnectionController__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(6024);
/* harmony import */ var _Config_Config__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(7463);
/* harmony import */ var _DataChannel_InitialSettings__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(877);
/* harmony import */ var _DataChannel_LatencyTestResults__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(7942);
/* harmony import */ var _Util_FileUtil__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(535);
/* harmony import */ var _Inputs_InputClassesFactory__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(1523);
/* harmony import */ var _VideoPlayer_VideoPlayer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(9499);
/* harmony import */ var _UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(180);
/* harmony import */ var _UeInstanceMessage_ResponseController__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6456);
/* harmony import */ var _UeInstanceMessage_SendMessageController__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(4477);
/* harmony import */ var _UeInstanceMessage_ToStreamerMessagesController__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(9983);
/* harmony import */ var _DataChannel_DataChannelSender__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(8156);
/* harmony import */ var _Util_InputCoordTranslator__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(3754);
/* harmony import */ var _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(5391);
/* harmony import */ var _Util_IURLSearchParams__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(7429);
/* harmony import */ var _Util_BrowserUtils__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(7617);
// Copyright Epic Games, Inc. All Rights Reserved.





















/**
 * Entry point for the WebRTC Player
 */
class WebRtcPlayerController {
    /**
     *
     * @param config - the frontend config object
     * @param pixelStreaming - the PixelStreaming object
     */
    constructor(config, pixelStreaming) {
        this.shouldShowPlayOverlay = true;
        this.autoJoinTimer = undefined;
        this.config = config;
        this.pixelStreaming = pixelStreaming;
        this.responseController = new _UeInstanceMessage_ResponseController__WEBPACK_IMPORTED_MODULE_0__.ResponseController();
        this.file = new _Util_FileUtil__WEBPACK_IMPORTED_MODULE_1__.FileTemplate();
        this.sdpConstraints = {
            offerToReceiveAudio: true,
            offerToReceiveVideo: true
        };
        // set up the afk logic class and connect up its method for closing the signaling server
        this.afkController = new _AFK_AFKController__WEBPACK_IMPORTED_MODULE_2__.AFKController(this.config, this.pixelStreaming, this.onAfkTriggered.bind(this));
        this.afkController.onAFKTimedOutCallback = () => {
            this.closeSignalingServer('You have been disconnected due to inactivity.', false);
        };
        this.freezeFrameController = new _FreezeFrame_FreezeFrameController__WEBPACK_IMPORTED_MODULE_3__.FreezeFrameController(this.pixelStreaming.videoElementParent);
        this.videoPlayer = new _VideoPlayer_VideoPlayer__WEBPACK_IMPORTED_MODULE_4__.VideoPlayer(this.pixelStreaming.videoElementParent, this.config);
        this.videoPlayer.onVideoInitialized = () => this.handleVideoInitialized();
        // When in match viewport resolution mode, when the browser viewport is resized we send a resize command back to UE.
        this.videoPlayer.onMatchViewportResolutionCallback = (width, height) => {
            const descriptor = {
                'Resolution.Width': width,
                'Resolution.Height': height
            };
            this.streamMessageController.toStreamerHandlers.get('Command')([JSON.stringify(descriptor)]);
        };
        // Every time video player is resized in browser we need to reinitialize the mouse coordinate conversion and freeze frame sizing logic.
        this.videoPlayer.onResizePlayerCallback = () => {
            this.setUpMouseAndFreezeFrame();
        };
        this.streamController = new _VideoPlayer_StreamController__WEBPACK_IMPORTED_MODULE_5__.StreamController(this.videoPlayer);
        this.coordinateConverter = new _Util_InputCoordTranslator__WEBPACK_IMPORTED_MODULE_6__.InputCoordTranslator();
        this.sendrecvDataChannelController = new _DataChannel_DataChannelController__WEBPACK_IMPORTED_MODULE_7__.DataChannelController();
        this.recvDataChannelController = new _DataChannel_DataChannelController__WEBPACK_IMPORTED_MODULE_7__.DataChannelController();
        this.registerDataChannelEventEmitters(this.sendrecvDataChannelController);
        this.registerDataChannelEventEmitters(this.recvDataChannelController);
        this.dataChannelSender = new _DataChannel_DataChannelSender__WEBPACK_IMPORTED_MODULE_8__.DataChannelSender(this.sendrecvDataChannelController);
        this.dataChannelSender.resetAfkWarningTimerOnDataSend = () => this.afkController.resetAfkWarningTimer();
        this.streamMessageController = new _UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.StreamMessageController();
        // set up websocket methods
        this.transport = new _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_10__.WebSocketTransport(config.webSocketProtocols);
        this.protocol = new _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_11__.SignallingProtocol(this.transport);
        this.protocol.addListener(_epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_12__.config.typeName, (msg) => this.handleOnConfigMessage(msg));
        this.protocol.addListener(_epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_12__.ping.typeName, (msg) => this.handlePingMessage(msg));
        this.protocol.addListener(_epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_12__.streamerList.typeName, (msg) => this.handleStreamerListMessage(msg));
        this.protocol.addListener(_epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_12__.subscribeFailed.typeName, (msg) => this.handleSubscribeFailedMessage(msg));
        this.protocol.addListener(_epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_12__.streamerIdChanged.typeName, (msg) => this.handleStreamerIDChangedMessage(msg));
        this.protocol.addListener(_epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_12__.playerCount.typeName, (msg) => {
            const playerCountMessage = msg;
            this.pixelStreaming._onPlayerCount(playerCountMessage.count);
        });
        this.protocol.addListener(_epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_12__.answer.typeName, (msg) => this.handleWebRtcAnswer(msg));
        this.protocol.addListener(_epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_12__.offer.typeName, (msg) => this.handleWebRtcOffer(msg));
        this.protocol.addListener(_epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_12__.peerDataChannels.typeName, (msg) => this.handleWebRtcSFUPeerDatachannels(msg));
        this.protocol.addListener(_epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_12__.iceCandidate.typeName, (msg) => {
            const iceCandidateMessage = msg;
            this.handleIceCandidate(iceCandidateMessage.candidate);
        });
        this.protocol.transport.addListener('open', () => {
            const message = _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_13__.createMessage(_epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_12__.listStreamers);
            this.protocol.sendMessage(message);
            this.reconnectAttempt = 0;
            this.isReconnecting = false;
        });
        this.protocol.transport.addListener('error', () => {
            // dont really need to do anything here since the close event should follow.
            _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_14__.Logger.Error(`Got a transport error.`);
        });
        this.protocol.transport.addListener('close', (event) => {
            // when we refresh the page during a stream we get the going away code.
            // in that case we don't want to reconnect since we're navigating away.
            // https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent/code
            // lists all the codes.
            const CODE_GOING_AWAY = 1001;
            const maxReconnectAttempts = this.config.getNumericSettingValue(_Config_Config__WEBPACK_IMPORTED_MODULE_15__.NumericParameters.MaxReconnectAttempts);
            const attemptsLeft = this.reconnectAttempt < maxReconnectAttempts;
            const reconnectEnabled = this.forceReconnect || (this.enableAutoReconnect && maxReconnectAttempts > 0 && attemptsLeft);
            const willTryReconnect = reconnectEnabled && event.code != CODE_GOING_AWAY;
            const allowClickToReconnect = !willTryReconnect;
            const disconnectMessage = this.disconnectMessage ? this.disconnectMessage : event.reason;
            this.forceReconnect = false;
            // Reset the list of all possible codecs on disconnect so that if the next connection has "NegotiateCodecs" on
            // then all codecs can be negotiated
            this.config.getSettingOption(_Config_Config__WEBPACK_IMPORTED_MODULE_15__.OptionParameters.PreferredCodec).options =
                _Util_BrowserUtils__WEBPACK_IMPORTED_MODULE_16__.BrowserUtils.getSupportedVideoCodecs();
            this.pixelStreaming._onDisconnect(disconnectMessage, allowClickToReconnect);
            this.afkController.stopAfkWarningTimer();
            // stop sending stats on interval if we have closed our connection
            if (this.statsTimerHandle && this.statsTimerHandle !== undefined) {
                window.clearInterval(this.statsTimerHandle);
            }
            // reset the stream quality icon.
            this.setVideoEncoderAvgQP(0);
            // unregister all input device event handlers on disconnect
            this.setTouchInputEnabled(false);
            this.setMouseInputEnabled(false);
            this.setKeyboardInputEnabled(false);
            this.setGamePadInputEnabled(false);
            if (willTryReconnect) {
                // need a small delay here to prevent reconnect spamming
                setTimeout(() => {
                    this.reconnectAttempt++;
                    this.doReconnect(event.reason);
                }, 2000);
            }
        });
        // set up the final webRtc player controller methods from within our application so a connection can be activated
        this.sendMessageController = new _UeInstanceMessage_SendMessageController__WEBPACK_IMPORTED_MODULE_17__.SendMessageController(this.dataChannelSender, this.streamMessageController);
        this.toStreamerMessagesController = new _UeInstanceMessage_ToStreamerMessagesController__WEBPACK_IMPORTED_MODULE_18__.ToStreamerMessagesController(this.sendMessageController);
        this.registerMessageHandlers();
        this.streamMessageController.populateDefaultProtocol();
        this.inputClassesFactory = new _Inputs_InputClassesFactory__WEBPACK_IMPORTED_MODULE_19__.InputClassesFactory(this.streamMessageController, this.videoPlayer, this.coordinateConverter);
        this.isUsingSFU = false;
        this.isUsingSVC = false;
        this.isQualityController = false;
        this.preferredCodec = '';
        this.enableAutoReconnect = true;
        this.forceReconnect = false;
        this.reconnectAttempt = 0;
        this.isReconnecting = false;
        this.config._addOnOptionSettingChangedListener(_Config_Config__WEBPACK_IMPORTED_MODULE_15__.OptionParameters.StreamerId, (streamerid) => {
            if (streamerid === undefined || streamerid === '') {
                return;
            }
            // close the current peer connection and create a new one
            this.peerConnectionController.peerConnection.close();
            this.peerConnectionController.createPeerConnection(this.peerConfig, this.preferredCodec);
            this.subscribedStream = streamerid;
            const message = _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_13__.createMessage(_epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_12__.subscribe, { streamerId: streamerid });
            this.protocol.sendMessage(message);
        });
        this.config._addOnOptionSettingChangedListener(_Config_Config__WEBPACK_IMPORTED_MODULE_15__.OptionParameters.PreferredQuality, (preferredQuality) => {
            if (preferredQuality === undefined || preferredQuality === '') {
                return;
            }
            let message;
            if (this.isUsingSVC) {
                // User is using SVC so selected quality will be of the form SxTy(h). Just extract the x and y numbers
                message = _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_13__.createMessage(_epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_12__.layerPreference, {
                    spatialLayer: +preferredQuality[1] - 1,
                    temporalLayer: +preferredQuality[3] - 1
                });
            }
            else {
                // User is not using SVC so the selected quality will be either Low, Medium or High so we extract the appropriate spatial layer index
                const allQualities = this.config.getSettingOption(_Config_Config__WEBPACK_IMPORTED_MODULE_15__.OptionParameters.PreferredQuality).options;
                const qualityIndex = allQualities.indexOf(preferredQuality);
                message = _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_13__.createMessage(_epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_12__.layerPreference, {
                    spatialLayer: qualityIndex,
                    temporalLayer: 0
                });
            }
            this.protocol.sendMessage(message);
        });
        this.setVideoEncoderAvgQP(-1);
        this.signallingUrlBuilder = () => {
            const signallingServerUrl = this.config.getTextSettingValue(_Config_Config__WEBPACK_IMPORTED_MODULE_15__.TextParameters.SignallingServerUrl);
            return signallingServerUrl;
        };
    }
    /**
     * Destroys the video player and makes sure resources are freed. This helps to prevent the issue in chrome
     * where it refuses to make new video players.
     */
    destroyVideoPlayer() {
        this.videoPlayer.destroy();
    }
    /**
     * Handles when a message is received
     * @param event - Message Event
     */
    handleOnMessage(event) {
        const message = new Uint8Array(event.data);
        _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_14__.Logger.Info('Message incoming:' + message);
        //try {
        const messageType = this.streamMessageController.fromStreamerMessages.get(message[0]);
        this.streamMessageController.fromStreamerHandlers.get(messageType)(event.data);
        //} catch (e) {
        //Logger.Error(Logger.GetStackTrace(), `Custom data channel message with message type that is unknown to the Pixel Streaming protocol. Does your PixelStreamingProtocol need updating? The message type was: ${message[0]}`);
        //}
    }
    /**
     * Register message all handlers
     */
    registerMessageHandlers() {
        // From Streamer
        // Message events from the streamer have a data type of ArrayBuffer as we force this type in the DatachannelController
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.FromStreamer, 'QualityControlOwnership', (data) => this.onQualityControlOwnership(data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.FromStreamer, 'Response', (data) => this.responseController.onResponse(data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.FromStreamer, 'Command', (data) => {
            this.onCommand(data);
        });
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.FromStreamer, 'FreezeFrame', (data) => this.onFreezeFrameMessage(data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.FromStreamer, 'UnfreezeFrame', () => this.invalidateFreezeFrameAndEnableVideo());
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.FromStreamer, 'VideoEncoderAvgQP', (data) => this.handleVideoEncoderAvgQP(data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.FromStreamer, 'LatencyTest', (data) => this.handleLatencyTestResult(data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.FromStreamer, 'DataChannelLatencyTest', (data) => this.handleDataChannelLatencyTestResponse(data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.FromStreamer, 'InitialSettings', (data) => this.handleInitialSettings(data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.FromStreamer, 'FileExtension', (data) => this.onFileExtension(data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.FromStreamer, 'FileMimeType', (data) => this.onFileMimeType(data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.FromStreamer, 'FileContents', (data) => this.onFileContents(data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.FromStreamer, 'TestEcho', () => {
            /* Do nothing */
        });
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.FromStreamer, 'InputControlOwnership', (data) => this.onInputControlOwnership(data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.FromStreamer, 'GamepadResponse', (data) => this.onGamepadResponse(data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.FromStreamer, 'Multiplexed', () => {
            /* Do nothing as this message type is used only by the SFU */
        });
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.FromStreamer, 'Protocol', (data) => this.onProtocolMessage(data));
        // To Streamer
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'IFrameRequest', () => this.sendMessageController.sendMessageToStreamer('IFrameRequest'));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'RequestQualityControl', () => this.sendMessageController.sendMessageToStreamer('RequestQualityControl'));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'FpsRequest', () => this.sendMessageController.sendMessageToStreamer('FpsRequest'));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'AverageBitrateRequest', () => this.sendMessageController.sendMessageToStreamer('AverageBitrateRequest'));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'StartStreaming', () => this.sendMessageController.sendMessageToStreamer('StartStreaming'));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'StopStreaming', () => this.sendMessageController.sendMessageToStreamer('StopStreaming'));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'LatencyTest', (data) => this.sendMessageController.sendMessageToStreamer('LatencyTest', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'RequestInitialSettings', () => this.sendMessageController.sendMessageToStreamer('RequestInitialSettings'));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'TestEcho', () => {
            /* Do nothing */
        });
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'UIInteraction', (data) => this.sendMessageController.sendMessageToStreamer('UIInteraction', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'Command', (data) => this.sendMessageController.sendMessageToStreamer('Command', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'TextboxEntry', (data) => this.sendMessageController.sendMessageToStreamer('TextboxEntry', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'KeyDown', (data) => this.sendMessageController.sendMessageToStreamer('KeyDown', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'KeyUp', (data) => this.sendMessageController.sendMessageToStreamer('KeyUp', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'KeyPress', (data) => this.sendMessageController.sendMessageToStreamer('KeyPress', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'MouseEnter', (data) => this.sendMessageController.sendMessageToStreamer('MouseEnter', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'MouseLeave', (data) => this.sendMessageController.sendMessageToStreamer('MouseLeave', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'MouseDown', (data) => this.sendMessageController.sendMessageToStreamer('MouseDown', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'MouseUp', (data) => this.sendMessageController.sendMessageToStreamer('MouseUp', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'MouseMove', (data) => this.sendMessageController.sendMessageToStreamer('MouseMove', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'MouseWheel', (data) => this.sendMessageController.sendMessageToStreamer('MouseWheel', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'MouseDouble', (data) => this.sendMessageController.sendMessageToStreamer('MouseDouble', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'TouchStart', (data) => this.sendMessageController.sendMessageToStreamer('TouchStart', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'TouchEnd', (data) => this.sendMessageController.sendMessageToStreamer('TouchEnd', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'TouchMove', (data) => this.sendMessageController.sendMessageToStreamer('TouchMove', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'GamepadConnected', () => this.sendMessageController.sendMessageToStreamer('GamepadConnected'));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'GamepadButtonPressed', (data) => this.sendMessageController.sendMessageToStreamer('GamepadButtonPressed', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'GamepadButtonReleased', (data) => this.sendMessageController.sendMessageToStreamer('GamepadButtonReleased', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'GamepadAnalog', (data) => this.sendMessageController.sendMessageToStreamer('GamepadAnalog', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'GamepadDisconnected', (data) => this.sendMessageController.sendMessageToStreamer('GamepadDisconnected', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'XREyeViews', (data) => this.sendMessageController.sendMessageToStreamer('XREyeViews', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'XRHMDTransform', (data) => this.sendMessageController.sendMessageToStreamer('XRHMDTransform', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'XRControllerTransform', (data) => this.sendMessageController.sendMessageToStreamer('XRControllerTransform', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'XRSystem', (data) => this.sendMessageController.sendMessageToStreamer('XRSystem', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'XRButtonTouched', (data) => this.sendMessageController.sendMessageToStreamer('XRButtonTouched', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'XRButtonTouchReleased', (data) => this.sendMessageController.sendMessageToStreamer('XRButtonTouchReleased', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'XRButtonPressed', (data) => this.sendMessageController.sendMessageToStreamer('XRButtonPressed', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'XRButtonReleased', (data) => this.sendMessageController.sendMessageToStreamer('XRButtonReleased', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'XRAnalog', (data) => this.sendMessageController.sendMessageToStreamer('XRAnalog', data));
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'ChannelRelayStatus', () => {
            /* Do nothing as this message type is used only by the SFU */
        });
        this.streamMessageController.registerMessageHandler(_UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer, 'Multiplexed', () => {
            /* Do nothing as this message type is used only by the SFU */
        });
    }
    /**
     * Activate the logic associated with a command from UE
     * @param message
     */
    onCommand(message) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_14__.Logger.Info('DataChannelReceiveMessageType.Command');
        const commandAsString = new TextDecoder('utf-16').decode(message.slice(1));
        _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_14__.Logger.Info('Data Channel Command: ' + commandAsString);
        const command = JSON.parse(commandAsString);
        // Handle "onScreenKeyboard" event
        if (command.command === 'onScreenKeyboard') {
            this.handleOnScreenKeyboardCommand(command);
        }
    }
    handleOnScreenKeyboardCommand(command) {
        var _a, _b, _c, _d;
        const data = {
            showOnScreenKeyboard: (_a = command.showOnScreenKeyboard) !== null && _a !== void 0 ? _a : true,
            x: (_b = command.x) !== null && _b !== void 0 ? _b : 0,
            y: (_c = command.y) !== null && _c !== void 0 ? _c : 0,
            contents: (_d = command.contents) !== null && _d !== void 0 ? _d : ''
        };
        this.pixelStreaming.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_20__.ShowOnScreenKeyboardEvent(data));
    }
    /**
     * Handles a protocol message received from the streamer
     * @param message the message data from the streamer
     */
    onProtocolMessage(message) {
        try {
            const protocolString = new TextDecoder('utf-16').decode(message.slice(1));
            const protocolJSON = JSON.parse(protocolString);
            if (!Object.prototype.hasOwnProperty.call(protocolJSON, 'Direction')) {
                _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_14__.Logger.Error('Malformed protocol received. Ensure the protocol message contains a direction');
            }
            const direction = protocolJSON.Direction;
            delete protocolJSON.Direction;
            _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_14__.Logger.Info(`Received new ${direction == _UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.FromStreamer ? 'FromStreamer' : 'ToStreamer'} protocol. Updating existing protocol...`);
            Object.keys(protocolJSON).forEach((messageType) => {
                const message = protocolJSON[messageType];
                switch (direction) {
                    case _UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer:
                        // Check that the message contains all the relevant params
                        if (!Object.prototype.hasOwnProperty.call(message, 'id')) {
                            _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_14__.Logger.Error(`ToStreamer->${messageType} protocol definition was malformed as it didn't contain at least an id\n
                                           Definition was: ${JSON.stringify(message, null, 2)}`);
                            // return in a forEach is equivalent to a continue in a normal for loop
                            return;
                        }
                        // UE5.1 and UE5.2 don't send a structure for these message types, but they actually do have a structure so ignore updating them
                        if (messageType === 'UIInteraction' ||
                            messageType === 'Command' ||
                            messageType === 'LatencyTest') {
                            return;
                        }
                        if (this.streamMessageController.toStreamerHandlers.get(messageType)) {
                            // If we've registered a handler for this message type we can add it to our supported messages. ie registerMessageHandler(...)
                            this.streamMessageController.toStreamerMessages.set(messageType, message);
                        }
                        else {
                            _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_14__.Logger.Error(`There was no registered handler for "${messageType}" - try adding one using registerMessageHandler(MessageDirection.ToStreamer, "${messageType}", myHandler)`);
                        }
                        break;
                    case _UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.FromStreamer:
                        // Check that the message contains all the relevant params
                        if (!Object.prototype.hasOwnProperty.call(message, 'id')) {
                            _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_14__.Logger.Error(`FromStreamer->${messageType} protocol definition was malformed as it didn't contain at least an id\n
                            Definition was: ${JSON.stringify(message, null, 2)}`);
                            // return in a forEach is equivalent to a continue in a normal for loop
                            return;
                        }
                        if (this.streamMessageController.fromStreamerHandlers.get(messageType)) {
                            // If we've registered a handler for this message type. ie registerMessageHandler(...)
                            this.streamMessageController.fromStreamerMessages.set(message.id, messageType);
                        }
                        else {
                            _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_14__.Logger.Error(`There was no registered handler for "${message}" - try adding one using registerMessageHandler(MessageDirection.FromStreamer, "${messageType}", myHandler)`);
                        }
                        break;
                    default:
                        _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_14__.Logger.Error(`Unknown direction: ${direction}`);
                }
            });
            // Once the protocol has been received, we can send our control messages
            this.toStreamerMessagesController.SendRequestInitialSettings();
            this.toStreamerMessagesController.SendRequestQualityControl();
        }
        catch (e) {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_14__.Logger.Info(e);
        }
    }
    /**
     * Handles an input control message when it is received from the streamer
     * @param message The input control message
     */
    onInputControlOwnership(message) {
        const view = new Uint8Array(message);
        _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_14__.Logger.Info('DataChannelReceiveMessageType.InputControlOwnership');
        const inputControlOwnership = new Boolean(view[1]).valueOf();
        _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_14__.Logger.Info(`Received input controller message - will your input control the stream: ${inputControlOwnership}`);
        this.pixelStreaming._onInputControlOwnership(inputControlOwnership);
    }
    /**
     *
     * @param message
     */
    onGamepadResponse(message) {
        const responseString = new TextDecoder('utf-16').decode(message.slice(1));
        const responseJSON = JSON.parse(responseString);
        this.gamePadController.onGamepadResponseReceived(responseJSON.controllerId);
    }
    onAfkTriggered() {
        this.afkController.onAfkClick();
        // if the stream is paused play it, if we can
        if (this.videoPlayer.isPaused() && this.videoPlayer.hasVideoSource()) {
            this.playStream();
        }
    }
    /**
     * Set whether we should timeout when afk.
     * @param afkEnabled If true we timeout when idle for some given amount of time.
     */
    setAfkEnabled(afkEnabled) {
        if (afkEnabled) {
            this.onAfkTriggered();
        }
        else {
            this.afkController.stopAfkWarningTimer();
        }
    }
    /**
     * Attempt a reconnection to the signalling server. Manual trigger
     */
    tryReconnect(message) {
        this.forceReconnect = true;
        this.doReconnect(message);
    }
    /**
     * Does the actual reconnect work. Used by the auto reconnect feature to skip the manual flag.
     */
    doReconnect(message) {
        // if there is no webSocketController return immediately or this will not work
        if (!this.protocol) {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_14__.Logger.Info('This player has no protocol connection.');
            return;
        }
        this.isReconnecting = true;
        // if the connection is open, first close it and force a reconnect.
        if (this.protocol.isConnected()) {
            if (!this.forceReconnect) {
                this.disconnectMessage = `${message} Reconnecting.`;
            }
            this.closeSignalingServer(message, true);
        }
        else {
            this.pixelStreaming._onWebRtcAutoConnect();
            this.connectToSignallingServer();
        }
    }
    /**
     * Loads a freeze frame if it is required otherwise shows the play overlay
     */
    loadFreezeFrameOrShowPlayOverlay() {
        this.pixelStreaming.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_20__.LoadFreezeFrameEvent({
            shouldShowPlayOverlay: this.shouldShowPlayOverlay,
            isValid: this.freezeFrameController.valid,
            jpegData: this.freezeFrameController.jpeg
        }));
        if (this.shouldShowPlayOverlay === true) {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_14__.Logger.Info('showing play overlay');
            this.resizePlayerStyle();
        }
        else {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_14__.Logger.Info('showing freeze frame');
            this.freezeFrameController.showFreezeFrame();
        }
        setTimeout(() => {
            this.videoPlayer.setVideoEnabled(false);
        }, this.freezeFrameController.freezeFrameDelay);
    }
    /**
     * Process the freeze frame and load it
     * @param message The freeze frame data in bytes
     */
    onFreezeFrameMessage(message) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_14__.Logger.Info('DataChannelReceiveMessageType.FreezeFrame');
        const view = new Uint8Array(message);
        this.freezeFrameController.processFreezeFrameMessage(view, () => this.loadFreezeFrameOrShowPlayOverlay());
    }
    /**
     * Enable the video after hiding a freeze frame
     */
    invalidateFreezeFrameAndEnableVideo() {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_14__.Logger.Info('DataChannelReceiveMessageType.FreezeFrame');
        setTimeout(() => {
            this.pixelStreaming.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_20__.HideFreezeFrameEvent());
            this.freezeFrameController.hideFreezeFrame();
        }, this.freezeFrameController.freezeFrameDelay);
        if (this.videoPlayer.getVideoElement()) {
            this.videoPlayer.setVideoEnabled(true);
        }
    }
    /**
     * Prep datachannel data for processing file extension
     * @param data the file extension data
     */
    onFileExtension(data) {
        const view = new Uint8Array(data);
        _Util_FileUtil__WEBPACK_IMPORTED_MODULE_1__.FileUtil.setExtensionFromBytes(view, this.file);
    }
    /**
     * Prep datachannel data for processing the file mime type
     * @param data the file mime type data
     */
    onFileMimeType(data) {
        const view = new Uint8Array(data);
        _Util_FileUtil__WEBPACK_IMPORTED_MODULE_1__.FileUtil.setMimeTypeFromBytes(view, this.file);
    }
    /**
     * Prep datachannel data for processing the file contents
     * @param data the file contents data
     */
    onFileContents(data) {
        const view = new Uint8Array(data);
        _Util_FileUtil__WEBPACK_IMPORTED_MODULE_1__.FileUtil.setContentsFromBytes(view, this.file);
    }
    /**
     * Plays the stream audio and video source and sets up other pieces while the stream starts
     */
    playStream() {
        if (!this.videoPlayer.getVideoElement()) {
            const message = 'Could not play video stream because the video player was not initialized correctly.';
            this.pixelStreaming.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_20__.PlayStreamErrorEvent({ message }));
            _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_14__.Logger.Error(message);
            // close the connection
            this.closeSignalingServer('Stream not initialized correctly', false);
            return;
        }
        if (!this.videoPlayer.hasVideoSource()) {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_14__.Logger.Warning('Cannot play stream, the video element has no srcObject to play.');
            return;
        }
        this.setTouchInputEnabled(this.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_15__.Flags.TouchInput));
        this.pixelStreaming.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_20__.PlayStreamEvent());
        if (this.streamController.audioElement.srcObject) {
            const startMuted = this.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_15__.Flags.StartVideoMuted);
            this.streamController.audioElement.muted = startMuted;
            if (startMuted) {
                this.playVideo();
            }
            else {
                this.streamController.audioElement
                    .play()
                    .then(() => {
                    this.playVideo();
                })
                    .catch((onRejectedReason) => {
                    _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_14__.Logger.Info(onRejectedReason);
                    _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_14__.Logger.Info('Browser does not support autoplaying video without interaction - to resolve this we are going to show the play button overlay.');
                    this.pixelStreaming.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_20__.PlayStreamRejectedEvent({
                        reason: onRejectedReason
                    }));
                });
            }
        }
        else {
            this.playVideo();
        }
        this.shouldShowPlayOverlay = false;
        this.freezeFrameController.showFreezeFrame();
    }
    /**
     * Plays the video stream
     */
    playVideo() {
        // handle play() with promise as it is an asynchronous call
        this.videoPlayer.play().catch((onRejectedReason) => {
            if (this.streamController.audioElement.srcObject) {
                this.streamController.audioElement.pause();
            }
            _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_14__.Logger.Info(onRejectedReason);
            _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_14__.Logger.Info('Browser does not support autoplaying video without interaction - to resolve this we are going to show the play button overlay.');
            this.pixelStreaming.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_20__.PlayStreamRejectedEvent({ reason: onRejectedReason }));
        });
    }
    /**
     * Enable the video to play automatically if enableAutoplay is true
     */
    autoPlayVideoOrSetUpPlayOverlay() {
        if (this.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_15__.Flags.AutoPlayVideo)) {
            // attempt to play the video
            this.playStream();
        }
        this.resizePlayerStyle();
    }
    /**
     * Connect to the Signaling server
     */
    connectToSignallingServer() {
        this.locallyClosed = false;
        this.enableAutoReconnect = true;
        this.disconnectMessage = null;
        const signallingUrl = this.signallingUrlBuilder();
        this.protocol.connect(signallingUrl);
        const keepaliveDelay = this.config.getNumericSettingValue(_Config_Config__WEBPACK_IMPORTED_MODULE_15__.NumericParameters.KeepaliveDelay);
        if (keepaliveDelay > 0) {
            this.keepalive = new _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_21__.KeepaliveMonitor(this.protocol, keepaliveDelay);
            this.keepalive.onTimeout = () => {
                // if the ping fails just disconnect
                _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_14__.Logger.Error(`Protocol timeout`);
                this.protocol.disconnect();
            };
        }
    }
    /**
     * This will start the handshake to the signalling server
     * @param peerConfig  - RTC Configuration Options from the Signaling server
     * @remark RTC Peer Connection on Ice Candidate event have it handled by handle Send Ice Candidate
     */
    startSession(peerConfig) {
        this.peerConfig = peerConfig;
        // check for forcing turn
        if (this.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_15__.Flags.ForceTURN)) {
            // check for a turn server
            const hasTurnServer = this.checkTurnServerAvailability(peerConfig);
            // close and error if turn is forced and there is no turn server
            if (!hasTurnServer) {
                _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_14__.Logger.Info('No turn server was found in the Peer Connection Options. TURN cannot be forced, closing connection. Please use STUN instead');
                this.closeSignalingServer('TURN cannot be forced, closing connection. Please use STUN instead.', false);
                return;
            }
        }
        // set up the peer connection controller
        this.peerConnectionController = new _PeerConnectionController_PeerConnectionController__WEBPACK_IMPORTED_MODULE_22__.PeerConnectionController(this.peerConfig, this.config, this.preferredCodec);
        // set up peer connection controller video stats
        this.peerConnectionController.onVideoStats = (event) => {
            this.handleVideoStats(event);
        };
        /* Set event handler for latency information is calculated, handle the event by propogating to the PixelStreaming API */
        this.peerConnectionController.onLatencyCalculated = (latencyInfo) => {
            this.pixelStreaming._onLatencyCalculated(latencyInfo);
        };
        /* When the Peer Connection wants to send an offer have it handled */
        this.peerConnectionController.onSendWebRTCOffer = (offer) => {
            this.handleSendWebRTCOffer(offer);
        };
        /* Set event handler for when local answer description is set */
        this.peerConnectionController.onSetLocalDescription = (answer) => {
            this.handleSendWebRTCAnswer(answer);
        };
        /* Set event handler for when remote offer description is set */
        this.peerConnectionController.onSetRemoteDescription = (offer) => {
            this.pixelStreaming._onWebRtcSdpOffer(offer);
        };
        /* When the Peer Connection ice candidate is added have it handled */
        this.peerConnectionController.onPeerIceCandidate = (peerConnectionIceEvent) => this.handleSendIceCandidate(peerConnectionIceEvent);
        /* When the Peer Connection has a data channel created for it by the browser, handle it */
        this.peerConnectionController.onDataChannel = (datachannelEvent) => this.handleDataChannel(datachannelEvent);
        // set up webRtc text overlays
        this.peerConnectionController.showTextOverlayConnecting = () => this.pixelStreaming._onWebRtcConnecting();
        this.peerConnectionController.showTextOverlaySetupFailure = () => this.pixelStreaming._onWebRtcFailed();
        let webRtcConnectedSent = false;
        this.peerConnectionController.onIceConnectionStateChange = () => {
            // Browsers emit "connected" when getting first connection and "completed" when finishing
            // candidate checking. However, sometimes browsers can skip "connected" and only emit "completed".
            // Therefore need to check both cases and emit onWebRtcConnected only once on the first hit.
            if (!webRtcConnectedSent &&
                ['connected', 'completed'].includes(this.peerConnectionController.peerConnection.iceConnectionState)) {
                this.pixelStreaming._onWebRtcConnected();
                webRtcConnectedSent = true;
            }
        };
        /* RTC Peer Connection on Track event -> handle on track */
        this.peerConnectionController.onTrack = (trackEvent) => this.streamController.handleOnTrack(trackEvent);
    }
    /**
     * Checks the peer connection options for a turn server and returns true or false
     */
    checkTurnServerAvailability(options) {
        // if iceServers is empty return false this should not be the general use case but is here incase
        if (!options.iceServers) {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_14__.Logger.Info('A turn sever was not found');
            return false;
        }
        // loop through the ice servers to check for a turn url
        for (const iceServer of options.iceServers) {
            for (const url of iceServer.urls) {
                if (url.includes('turn')) {
                    _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_14__.Logger.Info(`A turn sever was found at ${url}`);
                    return true;
                }
            }
        }
        _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_14__.Logger.Info('A turn sever was not found');
        return false;
    }
    /**
     * Handles when a Config Message is received contains the Peer Connection Options required (STUN and TURN Server Info)
     * @param messageConfig - Config Message received from the signaling server
     */
    handleOnConfigMessage(messageConfig) {
        this.resizePlayerStyle();
        // Tell the WebRtcController to start a session with the peer options sent from the signaling server
        this.startSession(messageConfig.peerConnectionOptions);
    }
    handlePingMessage(pingMessage) {
        this.protocol.sendMessage(_epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_13__.createMessage(_epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_12__.pong, { time: pingMessage.time }));
    }
    /**
     * Handles when the signalling server gives us the list of streamer ids.
     */
    handleStreamerListMessage(messageStreamerList) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_14__.Logger.Info(`Got streamer list ${messageStreamerList.ids}`);
        let wantedStreamerId = '';
        // get the current selected streamer id option
        const streamerIDOption = this.config.getSettingOption(_Config_Config__WEBPACK_IMPORTED_MODULE_15__.OptionParameters.StreamerId);
        const existingSelection = streamerIDOption.selected.toString().trim();
        if (existingSelection) {
            // default to selected option if it exists
            wantedStreamerId = streamerIDOption.selected;
        }
        // add the streamers to the UI
        const settingOptions = [...messageStreamerList.ids]; // copy the original messageStreamerList.ids
        settingOptions.unshift(''); // add an empty option at the top
        this.config.setOptionSettingOptions(_Config_Config__WEBPACK_IMPORTED_MODULE_15__.OptionParameters.StreamerId, settingOptions);
        let autoSelectedStreamerId = '';
        const waitForStreamer = this.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_15__.Flags.WaitForStreamer);
        const reconnectLimit = this.config.getNumericSettingValue(_Config_Config__WEBPACK_IMPORTED_MODULE_15__.NumericParameters.MaxReconnectAttempts);
        const reconnectDelay = this.config.getNumericSettingValue(_Config_Config__WEBPACK_IMPORTED_MODULE_15__.NumericParameters.StreamerAutoJoinInterval);
        // first we figure out a wanted streamer id through various means
        const useUrlParams = this.config.useUrlParams;
        const urlParams = new _Util_IURLSearchParams__WEBPACK_IMPORTED_MODULE_23__.IURLSearchParams(window.location.search);
        if (useUrlParams && urlParams.has(_Config_Config__WEBPACK_IMPORTED_MODULE_15__.OptionParameters.StreamerId)) {
            // if we've set the streamer id on the url we only want that streamer id
            wantedStreamerId = urlParams.get(_Config_Config__WEBPACK_IMPORTED_MODULE_15__.OptionParameters.StreamerId);
        }
        else if (this.subscribedStream) {
            // we were previously subscribed to a streamer, we want that
            wantedStreamerId = this.subscribedStream;
        }
        // now lets see if we can pick it.
        if (wantedStreamerId && messageStreamerList.ids.includes(wantedStreamerId)) {
            // if the wanted stream is in the list. we pick that
            autoSelectedStreamerId = wantedStreamerId;
        }
        else if ((!wantedStreamerId || !waitForStreamer) && messageStreamerList.ids.length == 1) {
            // otherwise, if we're not waiting for the wanted streamer and there's only one streamer, connect to it
            autoSelectedStreamerId = messageStreamerList.ids[0];
        }
        // if we found a streamer id to auto select, select it
        if (autoSelectedStreamerId) {
            this.reconnectAttempt = 0;
            this.isReconnecting = false;
            this.config.setOptionSettingValue(_Config_Config__WEBPACK_IMPORTED_MODULE_15__.OptionParameters.StreamerId, autoSelectedStreamerId);
        }
        else {
            // no auto selected streamer.
            // if we're waiting for a streamer then try reconnecting
            if (waitForStreamer) {
                if (this.reconnectAttempt < reconnectLimit) {
                    // still reconnects available
                    this.reconnectAttempt++;
                    this.isReconnecting = true;
                    setTimeout(() => {
                        this.protocol.sendMessage(_epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_13__.createMessage(_epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_12__.listStreamers));
                    }, reconnectDelay);
                }
                else {
                    // We've exhausted our reconnect attempts, return to main screen
                    this.reconnectAttempt = 0;
                    this.isReconnecting = false;
                    this.enableAutoReconnect = false;
                }
            }
        }
        // dispatch this event finally
        this.pixelStreaming.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_20__.StreamerListMessageEvent({
            messageStreamerList,
            autoSelectedStreamerId,
            wantedStreamerId
        }));
    }
    handleSubscribeFailedMessage(subscribeFailedMessage) {
        this.reconnectAttempt = 0;
        this.isReconnecting = false;
        this.enableAutoReconnect = false;
        this.pixelStreaming._onSubscribeFailed(subscribeFailedMessage.message);
    }
    handleStreamerIDChangedMessage(streamerIDChangedMessage) {
        const newID = streamerIDChangedMessage.newID;
        // need to edit the selected streamer in the settings list
        const streamerListOptions = this.config.getSettingOption(_Config_Config__WEBPACK_IMPORTED_MODULE_15__.OptionParameters.StreamerId);
        // temporarily prevent onChange from firing (it would try to subscribe to the streamer again)
        const oldOnChange = streamerListOptions.onChange;
        streamerListOptions.onChange = () => { };
        // change the selected entry.
        const streamerList = streamerListOptions.options;
        for (let i = 0; i < streamerList.length; ++i) {
            if (streamerList[i] == this.subscribedStream) {
                streamerList[i] = newID;
                break;
            }
        }
        // update the list
        streamerListOptions.options = streamerList;
        // update the selected entry
        streamerListOptions.selected = newID;
        // restore the old change notifier.
        streamerListOptions.onChange = oldOnChange;
        // remember which stream we're subscribe to
        this.subscribedStream = streamerIDChangedMessage.newID;
        // notify any listeners
        this.pixelStreaming.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_20__.StreamerIDChangedMessageEvent({
            newID
        }));
    }
    /**
     * Handle the RTC Answer from the signaling server
     * @param Answer - Answer SDP from the peer.
     */
    handleWebRtcAnswer(Answer) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_14__.Logger.Info(`Got answer sdp ${Answer.sdp}`);
        const sdpAnswer = {
            sdp: Answer.sdp,
            type: 'answer'
        };
        this.peerConnectionController.receiveAnswer(sdpAnswer);
        this.handlePostWebrtcNegotiation();
    }
    /**
     * Handle the RTC offer from a WebRTC peer (received through the signalling server).
     * @param Offer - Offer SDP from the peer.
     */
    handleWebRtcOffer(Offer) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_14__.Logger.Info(`Got offer sdp ${Offer.sdp}`);
        this.isUsingSFU = Offer.sfu ? Offer.sfu : false;
        this.isUsingSVC = Offer.scalabilityMode ? Offer.scalabilityMode != 'L1T1' : false;
        if (this.isUsingSFU || this.isUsingSVC) {
            // Disable negotiating with the sfu as the sfu only supports one codec at a time
            this.peerConnectionController.preferredCodec = '';
        }
        // NOTE: These two settings configurations are done outside of an if(this.isUsingSFU) so that users
        // can switch between a default and SFU stream and have the settings reconfigure appropriately
        const scalabilityMode = Offer.scalabilityMode ? Offer.scalabilityMode : 'L1T1';
        let availableQualities = ['Default'];
        if (this.isUsingSFU) {
            if (!this.isUsingSVC) {
                // User is using an SFU without any temporal scalability. Just offer easily readable names
                availableQualities = ['Low', 'Medium', 'High'];
            }
            else {
                // User is using SVC. Generate all available options.
                availableQualities = [];
                const maxSpatialLayers = +scalabilityMode[1];
                const maxTemporalLayers = +scalabilityMode[3];
                for (let s = 1; s <= maxSpatialLayers; s++) {
                    for (let t = 1; t <= maxTemporalLayers; t++) {
                        availableQualities.push(`S${s}T${t}`);
                    }
                }
            }
        }
        // Update the possible video quality options
        this.config.setOptionSettingOptions(_Config_Config__WEBPACK_IMPORTED_MODULE_15__.OptionParameters.PreferredQuality, availableQualities);
        // Update the selected video quality with the highest possible resolution
        this.config.setOptionSettingValue(_Config_Config__WEBPACK_IMPORTED_MODULE_15__.OptionParameters.PreferredQuality, availableQualities.slice(-1)[0]);
        const sdpOffer = {
            sdp: Offer.sdp,
            type: 'offer'
        };
        this.peerConnectionController.receiveOffer(sdpOffer, this.config);
        this.handlePostWebrtcNegotiation();
    }
    /**
     * Handle when the SFU provides the peer with its data channels
     * @param DataChannels - The message from the SFU containing the data channels ids
     */
    handleWebRtcSFUPeerDatachannels(DataChannels) {
        const SendOptions = {
            ordered: true,
            negotiated: true,
            id: DataChannels.sendStreamId
        };
        const unidirectional = DataChannels.sendStreamId != DataChannels.recvStreamId;
        this.sendrecvDataChannelController.createDataChannel(this.peerConnectionController.peerConnection, unidirectional ? 'send-datachannel' : 'datachannel', SendOptions);
        if (unidirectional) {
            const RecvOptions = {
                ordered: true,
                negotiated: true,
                id: DataChannels.recvStreamId
            };
            this.recvDataChannelController.createDataChannel(this.peerConnectionController.peerConnection, 'recv-datachannel', RecvOptions);
            this.recvDataChannelController.handleOnOpen = () => this.protocol.sendMessage(_epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_13__.createMessage(_epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_12__.peerDataChannelsReady));
            // If we're uni-directional, only the recv data channel should handle incoming messages
            this.recvDataChannelController.handleOnMessage = (ev) => this.handleOnMessage(ev);
        }
        else {
            // else our primary datachannel is send/recv so it can handle incoming messages
            this.sendrecvDataChannelController.handleOnMessage = (ev) => this.handleOnMessage(ev);
        }
    }
    handlePostWebrtcNegotiation() {
        // start the afk warning timer as PS is now running
        this.afkController.startAfkWarningTimer();
        // show the overlay that we have negotiated a connection
        this.pixelStreaming._onWebRtcSdp();
        if (this.statsTimerHandle && this.statsTimerHandle !== undefined) {
            window.clearInterval(this.statsTimerHandle);
        }
        this.statsTimerHandle = window.setInterval(() => this.getStats(), 1000);
        /*  */
        this.setMouseInputEnabled(this.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_15__.Flags.MouseInput));
        this.setKeyboardInputEnabled(this.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_15__.Flags.KeyboardInput));
        this.setGamePadInputEnabled(this.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_15__.Flags.GamepadInput));
    }
    /**
     * When an ice Candidate is received from the Signaling server add it to the Peer Connection Client
     * @param iceCandidate - Ice Candidate from Server
     */
    handleIceCandidate(iceCandidate) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_14__.Logger.Info('Web RTC Controller: onWebRtcIce');
        const candidate = new RTCIceCandidate(iceCandidate);
        this.peerConnectionController.handleOnIce(candidate);
    }
    /**
     * Send the ice Candidate to the signaling server via websocket
     * @param iceEvent - RTC Peer ConnectionIceEvent) {
     */
    handleSendIceCandidate(iceEvent) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_14__.Logger.Info('OnIceCandidate');
        if (iceEvent.candidate && iceEvent.candidate.candidate) {
            this.protocol.sendMessage(_epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_13__.createMessage(_epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_12__.iceCandidate, { candidate: iceEvent.candidate }));
        }
    }
    /**
     * Send the ice Candidate to the signaling server via websocket
     * @param iceEvent - RTC Peer ConnectionIceEvent) {
     */
    handleDataChannel(datachannelEvent) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_14__.Logger.Info('Data channel created for us by browser as we are a receiving peer.');
        this.sendrecvDataChannelController.dataChannel = datachannelEvent.channel;
        // Data channel was created for us, so we just need to setup its callbacks and array type
        this.sendrecvDataChannelController.setupDataChannel();
        this.sendrecvDataChannelController.handleOnMessage = (ev) => this.handleOnMessage(ev);
    }
    /**
     * Send the RTC Offer Session to the Signaling server via websocket
     * @param offer - RTC Session Description
     */
    handleSendWebRTCOffer(offer) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_14__.Logger.Info('Sending the offer to the Server');
        const extraParams = {
            sdp: offer.sdp,
            minBitrateBps: 1000 * this.config.getNumericSettingValue(_Config_Config__WEBPACK_IMPORTED_MODULE_15__.NumericParameters.WebRTCMinBitrate),
            maxBitrateBps: 1000 * this.config.getNumericSettingValue(_Config_Config__WEBPACK_IMPORTED_MODULE_15__.NumericParameters.WebRTCMaxBitrate)
        };
        this.protocol.sendMessage(_epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_13__.createMessage(_epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_12__.offer, extraParams));
    }
    /**
     * Send the RTC Offer Session to the Signaling server via websocket
     * @param answer - RTC Session Description
     */
    handleSendWebRTCAnswer(answer) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_14__.Logger.Info('Sending the answer to the Server');
        const extraParams = {
            sdp: answer.sdp,
            minBitrateBps: 1000 * this.config.getNumericSettingValue(_Config_Config__WEBPACK_IMPORTED_MODULE_15__.NumericParameters.WebRTCMinBitrate),
            maxBitrateBps: 1000 * this.config.getNumericSettingValue(_Config_Config__WEBPACK_IMPORTED_MODULE_15__.NumericParameters.WebRTCMaxBitrate)
        };
        this.protocol.sendMessage(_epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_13__.createMessage(_epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_12__.answer, extraParams));
        if (this.isUsingSFU) {
            this.protocol.sendMessage(_epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_13__.createMessage(_epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_12__.dataChannelRequest));
        }
        // Send answer back to Pixel Streaming main class for event dispatch
        this.pixelStreaming._onWebRtcSdpAnswer(answer);
    }
    /**
     * Set the freeze frame overlay to the player div
     */
    setUpMouseAndFreezeFrame() {
        // Calculating and normalizing positions depends on the width and height of the player.
        const playerElement = this.videoPlayer.getVideoParentElement();
        const videoElement = this.videoPlayer.getVideoElement();
        this.coordinateConverter.reconfigure({ width: playerElement.clientWidth, height: playerElement.clientHeight }, { width: videoElement.videoWidth, height: videoElement.videoHeight });
        this.freezeFrameController.freezeFrame.resize();
    }
    /**
     * Close the Connection to the signaling server
     */
    closeSignalingServer(message, allowReconnect) {
        var _a;
        this.locallyClosed = true;
        this.enableAutoReconnect = allowReconnect;
        this.disconnectMessage = message;
        (_a = this.protocol) === null || _a === void 0 ? void 0 : _a.disconnect(1000, message);
    }
    /**
     * Close the peer connection
     */
    closePeerConnection() {
        var _a;
        (_a = this.peerConnectionController) === null || _a === void 0 ? void 0 : _a.close();
    }
    /**
     * Close all connections
     */
    close() {
        this.closeSignalingServer('', false);
        this.closePeerConnection();
    }
    /**
     * Fires a Video Stats Event in the RTC Peer Connection
     */
    getStats() {
        this.peerConnectionController.generateStats();
    }
    /**
     * Send a Latency Test Request to the UE Instance
     */
    sendLatencyTest() {
        this.latencyStartTime = Date.now();
        this.streamMessageController.toStreamerHandlers.get('LatencyTest')([
            JSON.stringify({
                StartTime: this.latencyStartTime
            })
        ]);
    }
    /**
     * Send a Data Channel Latency Test Request to the UE Instance
     */
    sendDataChannelLatencyTest(descriptor) {
        this.streamMessageController.toStreamerHandlers.get('DataChannelLatencyTest')([
            JSON.stringify(descriptor)
        ]);
    }
    /**
     * Send the MinQP encoder setting to the UE Instance.
     * @param minQP - The lower bound for QP when encoding
     * valid values are (1-51) where:
     * 1 = Best quality but highest bitrate.
     * 51 = Worst quality but lowest bitrate.
     * By default the minQP is 1 meaning the encoder is free
     * to aim for the best quality it can on the given network link.
     */
    sendEncoderMinQP(minQP) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_14__.Logger.Info(`MinQP=${minQP}\n`);
        if (minQP != null) {
            this.streamMessageController.toStreamerHandlers.get('Command')([
                JSON.stringify({
                    'Encoder.MinQP': minQP
                })
            ]);
        }
    }
    /**
     * Send the MaxQP encoder setting to the UE Instance.
     * @param maxQP - The upper bound for QP when encoding
     * valid values are (1-51) where:
     * 1 = Best quality but highest bitrate.
     * 51 = Worst quality but lowest bitrate.
     * By default the maxQP is 51 meaning the encoder is free
     * to drop quality as low as needed on the given network link.
     */
    sendEncoderMaxQP(maxQP) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_14__.Logger.Info(`MaxQP=${maxQP}\n`);
        if (maxQP != null) {
            this.streamMessageController.toStreamerHandlers.get('Command')([
                JSON.stringify({
                    'Encoder.MaxQP': maxQP
                })
            ]);
        }
    }
    /**
     * Send the MinQuality encoder setting to the UE Instance.
     * @param minQuality - The lower bound for quality when encoding
     * valid values are (0-100) where:
     * 0 = Worst quality.
     * 100 = Best quality.
     */
    sendEncoderMinQuality(minQuality) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_14__.Logger.Info(`MinQuality=${minQuality}\n`);
        if (minQuality != null) {
            this.streamMessageController.toStreamerHandlers.get('Command')([
                JSON.stringify({
                    'Encoder.MinQuality': minQuality
                })
            ]);
        }
    }
    /**
     * Send the MaxQuality encoder setting to the UE Instance.
     * @param maxQuality - The upper bound for quality when encoding
     * valid values are (0-100) where:
     * 0 = Worst quality.
     * 100 = Best quality.
     */
    sendEncoderMaxQuality(maxQuality) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_14__.Logger.Info(`MaxQuality=${maxQuality}\n`);
        if (maxQuality != null) {
            this.streamMessageController.toStreamerHandlers.get('Command')([
                JSON.stringify({
                    'Encoder.MaxQuality': maxQuality
                })
            ]);
        }
    }
    /**
     * Send the { WebRTC.MinBitrate: SomeNumber }} command to UE to set
     * the minimum bitrate that we allow WebRTC to use
     * (note setting this too high in poor networks can be problematic).
     * @param minBitrate - The minimum bitrate we would like WebRTC to not fall below.
     */
    sendWebRTCMinBitrate(minBitrate) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_14__.Logger.Info(`WebRTC Min Bitrate=${minBitrate}`);
        if (minBitrate != null) {
            this.streamMessageController.toStreamerHandlers.get('Command')([
                JSON.stringify({
                    'WebRTC.MinBitrate': minBitrate
                })
            ]);
        }
    }
    /**
     * Send the { WebRTC.MaxBitrate: SomeNumber }} command to UE to set
     * the minimum bitrate that we allow WebRTC to use
     * (note setting this too low could result in blocky video).
     * @param minBitrate - The minimum bitrate we would like WebRTC to not fall below.
     */
    sendWebRTCMaxBitrate(maxBitrate) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_14__.Logger.Info(`WebRTC Max Bitrate=${maxBitrate}`);
        if (maxBitrate != null) {
            this.streamMessageController.toStreamerHandlers.get('Command')([
                JSON.stringify({
                    'WebRTC.MaxBitrate': maxBitrate
                })
            ]);
        }
    }
    /**
     * Send the { WebRTC.Fps: SomeNumber }} UE 5.0+
     * and { WebRTC.MaxFps } UE 4.27 command to set
     * the maximum fps we would like WebRTC to stream at.
     * @param fps - The maximum stream fps.
     */
    sendWebRTCFps(fps) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_14__.Logger.Info(`WebRTC FPS=${fps}`);
        if (fps != null) {
            this.streamMessageController.toStreamerHandlers.get('Command')([
                JSON.stringify({ 'WebRTC.Fps': fps })
            ]);
            /* TODO: Remove when UE 4.27 unsupported. */
            this.streamMessageController.toStreamerHandlers.get('Command')([
                JSON.stringify({ 'WebRTC.MaxFps': fps })
            ]);
        }
    }
    /**
     * Sends the UI Descriptor `stat fps` to the UE Instance
     */
    sendShowFps() {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_14__.Logger.Info('----   Sending show stat to UE   ----');
        this.streamMessageController.toStreamerHandlers.get('Command')([JSON.stringify({ 'stat.fps': '' })]);
    }
    /**
     * Send an Iframe request to the streamer
     */
    sendIframeRequest() {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_14__.Logger.Info('----   Sending Request for an IFrame  ----');
        this.streamMessageController.toStreamerHandlers.get('IFrameRequest')();
    }
    /**
     * Send a UIInteraction message
     */
    emitUIInteraction(descriptor) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_14__.Logger.Info('----   Sending custom UIInteraction message   ----');
        this.streamMessageController.toStreamerHandlers.get('UIInteraction')([JSON.stringify(descriptor)]);
    }
    /**
     * Send a Command message
     */
    emitCommand(descriptor) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_14__.Logger.Info('----   Sending custom Command message   ----');
        this.streamMessageController.toStreamerHandlers.get('Command')([JSON.stringify(descriptor)]);
    }
    /**
     * Send a console command message
     */
    emitConsoleCommand(command) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_14__.Logger.Info('----   Sending custom Command:ConsoleCommand message   ----');
        this.streamMessageController.toStreamerHandlers.get('Command')([
            JSON.stringify({
                ConsoleCommand: command
            })
        ]);
    }
    /**
     * Sends a request to the UE Instance to have ownership of Quality
     */
    sendRequestQualityControlOwnership() {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_14__.Logger.Info('----   Sending Request to Control Quality  ----');
        this.toStreamerMessagesController.SendRequestQualityControl();
    }
    /**
     * Send a `TextBoxEntry` message back to UE.
     * @param contents The new contents of the UE side text box.
     */
    sendTextboxEntry(contents) {
        var _a;
        _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_14__.Logger.Info('----   Sending TextboxEntry message  ----');
        (_a = this.streamMessageController.toStreamerHandlers.get('TextboxEntry')) === null || _a === void 0 ? void 0 : _a([contents]);
    }
    /**
     * Handles when a Latency Test Result are received from the UE Instance
     * @param message - Latency Test Timings
     */
    handleLatencyTestResult(message) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_14__.Logger.Info('DataChannelReceiveMessageType.latencyTest');
        const latencyAsString = new TextDecoder('utf-16').decode(message.slice(1));
        const latencyTestResults = new _DataChannel_LatencyTestResults__WEBPACK_IMPORTED_MODULE_24__.LatencyTestResults();
        Object.assign(latencyTestResults, JSON.parse(latencyAsString));
        latencyTestResults.processFields();
        latencyTestResults.testStartTimeMs = this.latencyStartTime;
        latencyTestResults.browserReceiptTimeMs = Date.now();
        latencyTestResults.latencyExcludingDecode = ~~(latencyTestResults.browserReceiptTimeMs - latencyTestResults.testStartTimeMs);
        latencyTestResults.testDuration = ~~(latencyTestResults.TransmissionTimeMs - latencyTestResults.ReceiptTimeMs);
        latencyTestResults.networkLatency = ~~(latencyTestResults.latencyExcludingDecode - latencyTestResults.testDuration);
        if (latencyTestResults.frameDisplayDeltaTimeMs && latencyTestResults.browserReceiptTimeMs) {
            latencyTestResults.endToEndLatency = ~~(latencyTestResults.frameDisplayDeltaTimeMs +
                latencyTestResults.networkLatency,
                +latencyTestResults.CaptureToSendMs);
        }
        this.pixelStreaming._onLatencyTestResult(latencyTestResults);
    }
    /**
     * Handles when a Data Channel Latency Test Response is received from the UE Instance
     * @param message - Data Channel Latency Test Response
     */
    handleDataChannelLatencyTestResponse(message) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_14__.Logger.Info('DataChannelReceiveMessageType.dataChannelLatencyResponse');
        const responseAsString = new TextDecoder('utf-16').decode(message.slice(1));
        const latencyTestResponse = JSON.parse(responseAsString);
        this.pixelStreaming._onDataChannelLatencyTestResponse(latencyTestResponse);
    }
    /**
     * Handles when the Encoder and Web RTC Settings are received from the UE Instance
     * @param message - Initial Encoder and Web RTC Settings
     */
    handleInitialSettings(message) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_14__.Logger.Info('DataChannelReceiveMessageType.InitialSettings');
        const payloadAsString = new TextDecoder('utf-16').decode(message.slice(1));
        const parsedInitialSettings = JSON.parse(payloadAsString);
        const initialSettings = new _DataChannel_InitialSettings__WEBPACK_IMPORTED_MODULE_25__.InitialSettings();
        if (parsedInitialSettings.Encoder) {
            initialSettings.EncoderSettings = parsedInitialSettings.Encoder;
        }
        if (parsedInitialSettings.WebRTC) {
            initialSettings.WebRTCSettings = parsedInitialSettings.WebRTC;
        }
        if (parsedInitialSettings.PixelStreaming) {
            initialSettings.PixelStreamingSettings = parsedInitialSettings.PixelStreaming;
        }
        if (parsedInitialSettings.ConfigOptions &&
            parsedInitialSettings.ConfigOptions.DefaultToHover !== undefined) {
            this.config.setFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_15__.Flags.HoveringMouseMode, !!parsedInitialSettings.ConfigOptions.DefaultToHover);
        }
        initialSettings.ueCompatible();
        _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_14__.Logger.Info(payloadAsString);
        this.pixelStreaming._onInitialSettings(initialSettings);
    }
    /**
     * Handles when the Quantization Parameter are received from the UE Instance
     * @param message - Encoders Quantization Parameter
     */
    handleVideoEncoderAvgQP(message) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_14__.Logger.Info('DataChannelReceiveMessageType.VideoEncoderAvgQP');
        const AvgQP = Number(new TextDecoder('utf-16').decode(message.slice(1)));
        this.setVideoEncoderAvgQP(AvgQP);
    }
    /**
     * Handles when the video element has been loaded with a srcObject
     */
    handleVideoInitialized() {
        this.pixelStreaming._onVideoInitialized();
        // either autoplay the video or set up the play overlay
        this.autoPlayVideoOrSetUpPlayOverlay();
        this.resizePlayerStyle();
        this.videoPlayer.updateVideoStreamSize();
    }
    /**
     * Flag set if the user has Quality Ownership
     * @param message - Does the current client have Quality Ownership
     */
    onQualityControlOwnership(message) {
        const view = new Uint8Array(message);
        _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_14__.Logger.Info('DataChannelReceiveMessageType.QualityControlOwnership');
        this.isQualityController = new Boolean(view[1]).valueOf();
        _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_14__.Logger.Info(`Received quality controller message, will control quality: ${this.isQualityController}`);
        this.pixelStreaming._onQualityControlOwnership(this.isQualityController);
    }
    /**
     * Handles when the Aggregated stats are Collected
     * @param stats - Aggregated Stats
     */
    handleVideoStats(stats) {
        this.pixelStreaming._onVideoStats(stats);
    }
    /**
     * To Resize the Video Player element
     */
    resizePlayerStyle() {
        this.videoPlayer.resizePlayerStyle();
    }
    setPreferredCodec(codec) {
        this.preferredCodec = codec;
        if (this.peerConnectionController) {
            this.peerConnectionController.preferredCodec = codec;
            this.peerConnectionController.updateCodecSelection = false;
        }
    }
    setVideoEncoderAvgQP(avgQP) {
        this.videoAvgQp = avgQP;
        this.pixelStreaming._onVideoEncoderAvgQP(this.videoAvgQp);
    }
    /**
     * enables/disables keyboard event listeners
     */
    setKeyboardInputEnabled(isEnabled) {
        var _a;
        (_a = this.keyboardController) === null || _a === void 0 ? void 0 : _a.unregister();
        if (isEnabled) {
            this.keyboardController = this.inputClassesFactory.registerKeyBoard(this.config);
        }
    }
    /**
     * enables/disables mouse event listeners
     */
    setMouseInputEnabled(isEnabled) {
        var _a;
        (_a = this.mouseController) === null || _a === void 0 ? void 0 : _a.unregister();
        if (isEnabled) {
            const mouseMode = this.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_15__.Flags.HoveringMouseMode)
                ? _Config_Config__WEBPACK_IMPORTED_MODULE_15__.ControlSchemeType.HoveringMouse
                : _Config_Config__WEBPACK_IMPORTED_MODULE_15__.ControlSchemeType.LockedMouse;
            this.mouseController = this.inputClassesFactory.registerMouse(mouseMode);
        }
    }
    /**
     * enables/disables touch event listeners
     */
    setTouchInputEnabled(isEnabled) {
        var _a;
        (_a = this.touchController) === null || _a === void 0 ? void 0 : _a.unregister();
        if (isEnabled) {
            this.touchController = this.inputClassesFactory.registerTouch(this.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_15__.Flags.FakeMouseWithTouches));
        }
    }
    /**
     * enables/disables game pad event listeners
     */
    setGamePadInputEnabled(isEnabled) {
        var _a;
        (_a = this.gamePadController) === null || _a === void 0 ? void 0 : _a.unregister();
        if (isEnabled) {
            this.gamePadController = this.inputClassesFactory.registerGamePad();
        }
    }
    registerDataChannelEventEmitters(dataChannel) {
        dataChannel.onOpen = (label, event) => this.pixelStreaming.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_20__.DataChannelOpenEvent({ label, event }));
        dataChannel.onClose = (label, event) => this.pixelStreaming.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_20__.DataChannelCloseEvent({ label, event }));
        dataChannel.onError = (label, event) => this.pixelStreaming.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_20__.DataChannelErrorEvent({ label, event }));
    }
    registerMessageHandler(name, direction, handler) {
        if (direction === _UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.FromStreamer && typeof handler === 'undefined') {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_14__.Logger.Warning(`Unable to register handler for ${name} as no handler was passed`);
        }
        this.streamMessageController.registerMessageHandler(direction, name, (data) => typeof handler === 'undefined' && direction === _UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_9__.MessageDirection.ToStreamer
            ? this.sendMessageController.sendMessageToStreamer(name, data)
            : handler(data));
    }
}
//# sourceMappingURL=WebRtcPlayerController.js.map

/***/ }),

/***/ 9581:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "WebXRController": () => (/* binding */ WebXRController)
/* harmony export */ });
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7800);
/* harmony import */ var _Inputs_XRGamepadController__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9835);
/* harmony import */ var _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(5391);
/* harmony import */ var _Config_Config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7463);
// Copyright Epic Games, Inc. All Rights Reserved.




class WebXRController {
    constructor(webRtcPlayerController) {
        this.xrViewerPose = null;
        // Used for comparisons to ensure two numbers are close enough.
        this.EPSILON = 0.0000001;
        this.videoTexture = null;
        this.prevVideoWidth = 0;
        this.prevVideoHeight = 0;
        this.leftView = null;
        this.rightView = null;
        // Store the HMD data we have last sent (not all of it is needed every frame unless it changes)
        this.lastSentLeftEyeProj = null;
        this.lastSentRightEyeProj = null;
        this.lastSentRelativeLeftEyePos = null;
        this.lastSentRelativeRightEyePos = null;
        this.xrSession = null;
        this.webRtcController = webRtcPlayerController;
        this.xrGamepadController = new _Inputs_XRGamepadController__WEBPACK_IMPORTED_MODULE_0__.XRGamepadController(this.webRtcController.streamMessageController);
        this.onSessionEnded = new EventTarget();
        this.onSessionStarted = new EventTarget();
        this.onFrame = new EventTarget();
    }
    xrClicked() {
        if (!this.xrSession) {
            if (!navigator.xr) {
                _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_1__.Logger.Error('This browser does not support XR.');
                return;
            }
            navigator.xr
                /* Request immersive-vr session without any optional features. */
                .requestSession('immersive-vr', { optionalFeatures: [] })
                .then((session) => {
                this.onXrSessionStarted(session);
            });
        }
        else {
            this.xrSession.end();
        }
    }
    onXrSessionEnded() {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_1__.Logger.Info('XR Session ended');
        this.xrSession = null;
        this.onSessionEnded.dispatchEvent(new Event('xrSessionEnded'));
    }
    initGL() {
        if (this.gl) {
            return;
        }
        const canvas = document.createElement('canvas');
        this.gl = canvas.getContext('webgl2', {
            xrCompatible: true
        });
        // Set our clear color
        this.gl.clearColor(0.0, 0.0, 0.0, 1);
    }
    initShaders() {
        // shader source code
        const vertexShaderSource = `
        attribute vec2 a_position;
        attribute vec2 a_texCoord;

        // varyings
        varying vec2 v_texCoord;

        void main() {
           gl_Position = vec4(a_position.x, a_position.y, 0, 1);
           // pass the texCoord to the fragment shader
           // The GPU will interpolate this value between points.
           v_texCoord = a_texCoord;
        }
        `;
        const fragmentShaderSource = `
        precision mediump float;

        // our texture
        uniform sampler2D u_image;

        // the texCoords passed in from the vertex shader.
        varying vec2 v_texCoord;

        void main() {
           gl_FragColor = texture2D(u_image, v_texCoord);
        }
        `;
        // setup vertex shader
        const vertexShader = this.gl.createShader(this.gl.VERTEX_SHADER);
        this.gl.shaderSource(vertexShader, vertexShaderSource);
        this.gl.compileShader(vertexShader);
        // setup fragment shader
        const fragmentShader = this.gl.createShader(this.gl.FRAGMENT_SHADER);
        this.gl.shaderSource(fragmentShader, fragmentShaderSource);
        this.gl.compileShader(fragmentShader);
        // setup GLSL program
        const shaderProgram = this.gl.createProgram();
        this.gl.attachShader(shaderProgram, vertexShader);
        this.gl.attachShader(shaderProgram, fragmentShader);
        this.gl.linkProgram(shaderProgram);
        this.gl.useProgram(shaderProgram);
        // look up where vertex data needs to go
        this.positionLocation = this.gl.getAttribLocation(shaderProgram, 'a_position');
        this.texcoordLocation = this.gl.getAttribLocation(shaderProgram, 'a_texCoord');
    }
    updateVideoTexture() {
        if (!this.videoTexture) {
            // Create our texture that we use in our shader
            // and bind it once because we never use any other texture.
            this.videoTexture = this.gl.createTexture();
            this.gl.bindTexture(this.gl.TEXTURE_2D, this.videoTexture);
            // Set the parameters so we can render any size image.
            this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
            this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);
            this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);
            this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);
        }
        const videoHeight = this.webRtcController.videoPlayer.getVideoElement().videoHeight;
        const videoWidth = this.webRtcController.videoPlayer.getVideoElement().videoWidth;
        if (this.prevVideoHeight != videoHeight || this.prevVideoWidth != videoWidth) {
            // Do full update of texture if dimensions do not match
            this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, videoWidth, videoHeight, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, this.webRtcController.videoPlayer.getVideoElement());
        }
        else {
            // If dimensions match just update the sub region
            this.gl.texSubImage2D(this.gl.TEXTURE_2D, 0, 0, 0, videoWidth, videoHeight, this.gl.RGBA, this.gl.UNSIGNED_BYTE, this.webRtcController.videoPlayer.getVideoElement());
        }
        // Update prev video width/height
        this.prevVideoHeight = videoHeight;
        this.prevVideoWidth = videoWidth;
    }
    initBuffers() {
        // Create out position buffer and its vertex shader attribute
        {
            // Create a buffer to put the the vertices of the plane we will draw the video stream onto
            this.positionBuffer = this.gl.createBuffer();
            // Bind the position buffer
            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.positionBuffer);
            // Enable `positionLocation` to be used as vertex shader attribute
            this.gl.enableVertexAttribArray(this.positionLocation);
            // Note: positions are passed in clip-space coordinates [-1..1] so no need to convert in-shader
            // prettier-ignore
            this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array([
                -1.0, 1.0,
                1.0, 1.0,
                -1.0, -1.0,
                -1.0, -1.0,
                1.0, 1.0,
                1.0, -1.0
            ]), this.gl.STATIC_DRAW);
            // Tell position attribute of the vertex shader how to get data out of the bound buffer (the positionBuffer)
            this.gl.vertexAttribPointer(this.positionLocation, 2 /*size*/, this.gl.FLOAT /*type*/, false /*normalize*/, 0 /*stride*/, 0 /*offset*/);
        }
        // Create our texture coordinate buffers for accessing our texture
        {
            this.texcoordBuffer = this.gl.createBuffer();
            // Bind the texture coordinate buffer
            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.texcoordBuffer);
            // Enable `texcoordLocation` to be used as a vertex shader attribute
            this.gl.enableVertexAttribArray(this.texcoordLocation);
            // The texture coordinates to apply for rectangle we are drawing
            this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array([0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 1.0]), this.gl.STATIC_DRAW);
            // Tell texture coordinate attribute of the vertex shader how to get data out of the bound buffer (the texcoordBuffer)
            this.gl.vertexAttribPointer(this.texcoordLocation, 2 /*size*/, this.gl.FLOAT /*type*/, false /*normalize*/, 0 /*stride*/, 0 /*offset*/);
        }
    }
    onXrSessionStarted(session) {
        _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_1__.Logger.Info('XR Session started');
        this.xrSession = session;
        this.xrSession.addEventListener('end', () => {
            this.onXrSessionEnded();
        });
        // Initialization
        this.initGL();
        this.initShaders();
        this.initBuffers();
        session.requestReferenceSpace('local').then((refSpace) => {
            this.xrRefSpace = refSpace;
            // Set up our base layer (i.e. a projection layer that fills the entire XR viewport).
            this.xrSession.updateRenderState({
                baseLayer: new XRWebGLLayer(this.xrSession, this.gl)
            });
            // Update target framerate to 90 fps if 90 fps is supported in this XR device
            if (this.xrSession.supportedFrameRates) {
                for (const frameRate of this.xrSession.supportedFrameRates) {
                    if (frameRate == 90) {
                        session.updateTargetFrameRate(90);
                    }
                }
            }
            // Binding to each new frame to get latest XR updates
            this.xrSession.requestAnimationFrame(this.onXrFrame.bind(this));
        });
        this.onSessionStarted.dispatchEvent(new Event('xrSessionStarted'));
    }
    areArraysEqual(a, b) {
        return (a.length === b.length && a.every((element, index) => Math.abs(element - b[index]) <= this.EPSILON));
    }
    arePointsEqual(a, b) {
        return (Math.abs(a.x - b.x) >= this.EPSILON &&
            Math.abs(a.y - b.y) >= this.EPSILON &&
            Math.abs(a.z - b.z) >= this.EPSILON);
    }
    sendXRDataToUE() {
        if (this.leftView == null || this.rightView == null) {
            return;
        }
        // We selectively send either the `XREyeViews` or `XRHMDTransform`
        // messages over the datachannel. The reason for this selective sending is that
        // the `XREyeViews` is a much larger message and changes infrequently (e.g. only when user changes headset IPD).
        // Therefore, we only need to send it once on startup and then any time it changes.
        // The rest of the time we can send the `XRHMDTransform` message.
        let shouldSendEyeViews = this.lastSentLeftEyeProj == null ||
            this.lastSentRightEyeProj == null ||
            this.lastSentRelativeLeftEyePos == null ||
            this.lastSentRelativeRightEyePos == null;
        const leftEyeTrans = this.leftView.transform.matrix;
        const leftEyeProj = this.leftView.projectionMatrix;
        const rightEyeTrans = this.rightView.transform.matrix;
        const rightEyeProj = this.rightView.projectionMatrix;
        const hmdTrans = this.xrViewerPose.transform.matrix;
        // Check if projection matrices have changed
        if (!shouldSendEyeViews && this.lastSentLeftEyeProj != null && this.lastSentRightEyeProj != null) {
            const leftEyeProjUnchanged = this.areArraysEqual(leftEyeProj, this.lastSentLeftEyeProj);
            const rightEyeProjUnchanged = this.areArraysEqual(rightEyeProj, this.lastSentRightEyeProj);
            shouldSendEyeViews = leftEyeProjUnchanged == false || rightEyeProjUnchanged == false;
        }
        const leftEyeRelativePos = new DOMPointReadOnly(this.leftView.transform.position.x - this.xrViewerPose.transform.position.x, this.leftView.transform.position.y - this.xrViewerPose.transform.position.y, this.leftView.transform.position.z - this.xrViewerPose.transform.position.z, 1.0);
        const rightEyeRelativePos = new DOMPointReadOnly(this.leftView.transform.position.x - this.xrViewerPose.transform.position.x, this.leftView.transform.position.y - this.xrViewerPose.transform.position.y, this.leftView.transform.position.z - this.xrViewerPose.transform.position.z, 1.0);
        // Check if relative eye pos has changed (e.g IPD changed)
        if (!shouldSendEyeViews &&
            this.lastSentRelativeLeftEyePos != null &&
            this.lastSentRelativeRightEyePos != null) {
            const leftEyePosUnchanged = this.arePointsEqual(leftEyeRelativePos, this.lastSentRelativeLeftEyePos);
            const rightEyePosUnchanged = this.arePointsEqual(rightEyeRelativePos, this.lastSentRelativeRightEyePos);
            shouldSendEyeViews = leftEyePosUnchanged == false || rightEyePosUnchanged == false;
            // Note: We are not checking if EyeView rotation changes (as far as I know no HMD supports changing this value at runtime).
        }
        if (shouldSendEyeViews) {
            // send transform (4x4) and projection matrix (4x4) data for each eye (left first, then right)
            // prettier-ignore
            this.webRtcController.streamMessageController.toStreamerHandlers.get('XREyeViews')([
                // Left eye 4x4 transform matrix
                leftEyeTrans[0], leftEyeTrans[4], leftEyeTrans[8], leftEyeTrans[12],
                leftEyeTrans[1], leftEyeTrans[5], leftEyeTrans[9], leftEyeTrans[13],
                leftEyeTrans[2], leftEyeTrans[6], leftEyeTrans[10], leftEyeTrans[14],
                leftEyeTrans[3], leftEyeTrans[7], leftEyeTrans[11], leftEyeTrans[15],
                // Left eye 4x4 projection matrix
                leftEyeProj[0], leftEyeProj[4], leftEyeProj[8], leftEyeProj[12],
                leftEyeProj[1], leftEyeProj[5], leftEyeProj[9], leftEyeProj[13],
                leftEyeProj[2], leftEyeProj[6], leftEyeProj[10], leftEyeProj[14],
                leftEyeProj[3], leftEyeProj[7], leftEyeProj[11], leftEyeProj[15],
                // Right eye 4x4 transform matrix
                rightEyeTrans[0], rightEyeTrans[4], rightEyeTrans[8], rightEyeTrans[12],
                rightEyeTrans[1], rightEyeTrans[5], rightEyeTrans[9], rightEyeTrans[13],
                rightEyeTrans[2], rightEyeTrans[6], rightEyeTrans[10], rightEyeTrans[14],
                rightEyeTrans[3], rightEyeTrans[7], rightEyeTrans[11], rightEyeTrans[15],
                // right eye 4x4 projection matrix
                rightEyeProj[0], rightEyeProj[4], rightEyeProj[8], rightEyeProj[12],
                rightEyeProj[1], rightEyeProj[5], rightEyeProj[9], rightEyeProj[13],
                rightEyeProj[2], rightEyeProj[6], rightEyeProj[10], rightEyeProj[14],
                rightEyeProj[3], rightEyeProj[7], rightEyeProj[11], rightEyeProj[15],
                // HMD 4x4 transform
                hmdTrans[0], hmdTrans[4], hmdTrans[8], hmdTrans[12],
                hmdTrans[1], hmdTrans[5], hmdTrans[9], hmdTrans[13],
                hmdTrans[2], hmdTrans[6], hmdTrans[10], hmdTrans[14],
                hmdTrans[3], hmdTrans[7], hmdTrans[11], hmdTrans[15],
            ]);
            this.lastSentLeftEyeProj = leftEyeProj;
            this.lastSentRightEyeProj = rightEyeProj;
            this.lastSentRelativeLeftEyePos = leftEyeRelativePos;
            this.lastSentRelativeRightEyePos = rightEyeRelativePos;
        }
        else {
            // If we don't need to the entire eye views being sent just send the HMD transform
            this.webRtcController.streamMessageController.toStreamerHandlers.get('XRHMDTransform')([
                // HMD 4x4 transform
                hmdTrans[0],
                hmdTrans[4],
                hmdTrans[8],
                hmdTrans[12],
                hmdTrans[1],
                hmdTrans[5],
                hmdTrans[9],
                hmdTrans[13],
                hmdTrans[2],
                hmdTrans[6],
                hmdTrans[10],
                hmdTrans[14],
                hmdTrans[3],
                hmdTrans[7],
                hmdTrans[11],
                hmdTrans[15]
            ]);
        }
    }
    onXrFrame(time, frame) {
        this.xrViewerPose = frame.getViewerPose(this.xrRefSpace);
        if (this.xrViewerPose) {
            this.updateViews();
            if (this.leftView == null || this.rightView == null) {
                return;
            }
            this.sendXRDataToUE();
            this.updateVideoTexture();
            this.render();
        }
        if (this.webRtcController.config.isFlagEnabled(_Config_Config__WEBPACK_IMPORTED_MODULE_2__.Flags.XRControllerInput)) {
            this.xrSession.inputSources.forEach((source, _index, _array) => {
                this.xrGamepadController.updateStatus(source, frame, this.xrRefSpace);
            }, this);
        }
        this.xrSession.requestAnimationFrame((time, frame) => this.onXrFrame(time, frame));
        this.onFrame.dispatchEvent(new _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_3__.XrFrameEvent({ time, frame }));
    }
    updateViews() {
        if (!this.xrViewerPose) {
            return;
        }
        for (const view of this.xrViewerPose.views) {
            if (view.eye === 'left') {
                this.leftView = view;
            }
            else if (view.eye === 'right') {
                this.rightView = view;
            }
        }
    }
    render() {
        if (!this.gl) {
            return;
        }
        // Bind the framebuffer to the base layer's framebuffer
        const glLayer = this.xrSession.renderState.baseLayer;
        this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, glLayer.framebuffer);
        // Set the relevant portion of clip space
        this.gl.viewport(0, 0, glLayer.framebufferWidth, glLayer.framebufferHeight);
        // Draw the rectangle we will show the video stream texture on
        this.gl.drawArrays(this.gl.TRIANGLES /*primitiveType*/, 0 /*offset*/, 6 /*count*/);
    }
    static isSessionSupported(mode) {
        if (location.protocol !== 'https:') {
            _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_1__.Logger.Info('WebXR requires https, if you want WebXR use https.');
        }
        if (navigator.xr) {
            return navigator.xr.isSessionSupported(mode);
        }
        else {
            return new Promise(() => {
                return false;
            });
        }
    }
}
//# sourceMappingURL=WebXRController.js.map

/***/ }),

/***/ 693:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AfkLogic": () => (/* reexport safe */ _AFK_AFKController__WEBPACK_IMPORTED_MODULE_9__.AFKController),
/* harmony export */   "AfkTimedOutEvent": () => (/* reexport safe */ _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_22__.AfkTimedOutEvent),
/* harmony export */   "AfkWarningActivateEvent": () => (/* reexport safe */ _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_22__.AfkWarningActivateEvent),
/* harmony export */   "AfkWarningDeactivateEvent": () => (/* reexport safe */ _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_22__.AfkWarningDeactivateEvent),
/* harmony export */   "AfkWarningUpdateEvent": () => (/* reexport safe */ _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_22__.AfkWarningUpdateEvent),
/* harmony export */   "AggregatedStats": () => (/* reexport safe */ _PeerConnectionController_AggregatedStats__WEBPACK_IMPORTED_MODULE_12__.AggregatedStats),
/* harmony export */   "CandidatePairStats": () => (/* reexport safe */ _PeerConnectionController_CandidatePairStats__WEBPACK_IMPORTED_MODULE_15__.CandidatePairStats),
/* harmony export */   "CandidateStat": () => (/* reexport safe */ _PeerConnectionController_CandidateStat__WEBPACK_IMPORTED_MODULE_16__.CandidateStat),
/* harmony export */   "Config": () => (/* reexport safe */ _Config_Config__WEBPACK_IMPORTED_MODULE_2__.Config),
/* harmony export */   "ControlSchemeType": () => (/* reexport safe */ _Config_Config__WEBPACK_IMPORTED_MODULE_2__.ControlSchemeType),
/* harmony export */   "DataChannelCloseEvent": () => (/* reexport safe */ _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_22__.DataChannelCloseEvent),
/* harmony export */   "DataChannelErrorEvent": () => (/* reexport safe */ _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_22__.DataChannelErrorEvent),
/* harmony export */   "DataChannelLatencyTestRecord": () => (/* reexport safe */ _DataChannel_DataChannelLatencyTestResults__WEBPACK_IMPORTED_MODULE_21__.DataChannelLatencyTestRecord),
/* harmony export */   "DataChannelLatencyTestResponseEvent": () => (/* reexport safe */ _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_22__.DataChannelLatencyTestResponseEvent),
/* harmony export */   "DataChannelLatencyTestResultEvent": () => (/* reexport safe */ _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_22__.DataChannelLatencyTestResultEvent),
/* harmony export */   "DataChannelOpenEvent": () => (/* reexport safe */ _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_22__.DataChannelOpenEvent),
/* harmony export */   "DataChannelStats": () => (/* reexport safe */ _PeerConnectionController_DataChannelStats__WEBPACK_IMPORTED_MODULE_17__.DataChannelStats),
/* harmony export */   "EncoderSettings": () => (/* reexport safe */ _DataChannel_InitialSettings__WEBPACK_IMPORTED_MODULE_11__.EncoderSettings),
/* harmony export */   "EventEmitter": () => (/* reexport safe */ _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_23__.EventEmitter),
/* harmony export */   "Flags": () => (/* reexport safe */ _Config_Config__WEBPACK_IMPORTED_MODULE_2__.Flags),
/* harmony export */   "FrameTimingInfo": () => (/* reexport safe */ _PeerConnectionController_LatencyCalculator__WEBPACK_IMPORTED_MODULE_20__.FrameTimingInfo),
/* harmony export */   "HideFreezeFrameEvent": () => (/* reexport safe */ _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_22__.HideFreezeFrameEvent),
/* harmony export */   "InboundAudioStats": () => (/* reexport safe */ _PeerConnectionController_InboundRTPStats__WEBPACK_IMPORTED_MODULE_18__.InboundAudioStats),
/* harmony export */   "InboundVideoStats": () => (/* reexport safe */ _PeerConnectionController_InboundRTPStats__WEBPACK_IMPORTED_MODULE_18__.InboundVideoStats),
/* harmony export */   "InitialSettings": () => (/* reexport safe */ _DataChannel_InitialSettings__WEBPACK_IMPORTED_MODULE_11__.InitialSettings),
/* harmony export */   "InitialSettingsEvent": () => (/* reexport safe */ _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_22__.InitialSettingsEvent),
/* harmony export */   "InputCoordTranslator": () => (/* reexport safe */ _Util_InputCoordTranslator__WEBPACK_IMPORTED_MODULE_13__.InputCoordTranslator),
/* harmony export */   "KeepaliveMonitor": () => (/* reexport safe */ _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_23__.KeepaliveMonitor),
/* harmony export */   "LatencyCalculatedEvent": () => (/* reexport safe */ _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_22__.LatencyCalculatedEvent),
/* harmony export */   "LatencyCalculator": () => (/* reexport safe */ _PeerConnectionController_LatencyCalculator__WEBPACK_IMPORTED_MODULE_20__.LatencyCalculator),
/* harmony export */   "LatencyInfo": () => (/* reexport safe */ _PeerConnectionController_LatencyCalculator__WEBPACK_IMPORTED_MODULE_20__.LatencyInfo),
/* harmony export */   "LatencyTestResultEvent": () => (/* reexport safe */ _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_22__.LatencyTestResultEvent),
/* harmony export */   "LatencyTestResults": () => (/* reexport safe */ _DataChannel_LatencyTestResults__WEBPACK_IMPORTED_MODULE_10__.LatencyTestResults),
/* harmony export */   "LoadFreezeFrameEvent": () => (/* reexport safe */ _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_22__.LoadFreezeFrameEvent),
/* harmony export */   "LogLevel": () => (/* reexport safe */ _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_23__.LogLevel),
/* harmony export */   "Logger": () => (/* reexport safe */ _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_23__.Logger),
/* harmony export */   "MessageDirection": () => (/* reexport safe */ _UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_14__.MessageDirection),
/* harmony export */   "MessageHelpers": () => (/* reexport safe */ _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_23__.MessageHelpers),
/* harmony export */   "MessageRegistry": () => (/* reexport safe */ _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_23__.MessageRegistry),
/* harmony export */   "Messages": () => (/* reexport safe */ _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_23__.Messages),
/* harmony export */   "NumericParameters": () => (/* reexport safe */ _Config_Config__WEBPACK_IMPORTED_MODULE_2__.NumericParameters),
/* harmony export */   "OptionParameters": () => (/* reexport safe */ _Config_Config__WEBPACK_IMPORTED_MODULE_2__.OptionParameters),
/* harmony export */   "OutboundRTPStats": () => (/* reexport safe */ _PeerConnectionController_OutBoundRTPStats__WEBPACK_IMPORTED_MODULE_19__.OutboundRTPStats),
/* harmony export */   "PixelStreaming": () => (/* reexport safe */ _PixelStreaming_PixelStreaming__WEBPACK_IMPORTED_MODULE_8__.PixelStreaming),
/* harmony export */   "PixelStreamingEventEmitter": () => (/* reexport safe */ _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_22__.PixelStreamingEventEmitter),
/* harmony export */   "PixelStreamingSettings": () => (/* reexport safe */ _DataChannel_InitialSettings__WEBPACK_IMPORTED_MODULE_11__.PixelStreamingSettings),
/* harmony export */   "PlayStreamErrorEvent": () => (/* reexport safe */ _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_22__.PlayStreamErrorEvent),
/* harmony export */   "PlayStreamEvent": () => (/* reexport safe */ _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_22__.PlayStreamEvent),
/* harmony export */   "PlayStreamRejectedEvent": () => (/* reexport safe */ _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_22__.PlayStreamRejectedEvent),
/* harmony export */   "PlayerCountEvent": () => (/* reexport safe */ _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_22__.PlayerCountEvent),
/* harmony export */   "RemoteOutboundRTPStats": () => (/* reexport safe */ _PeerConnectionController_OutBoundRTPStats__WEBPACK_IMPORTED_MODULE_19__.RemoteOutboundRTPStats),
/* harmony export */   "SDPUtils": () => (/* reexport safe */ _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_23__.SDPUtils),
/* harmony export */   "SettingBase": () => (/* reexport safe */ _Config_SettingBase__WEBPACK_IMPORTED_MODULE_3__.SettingBase),
/* harmony export */   "SettingFlag": () => (/* reexport safe */ _Config_SettingFlag__WEBPACK_IMPORTED_MODULE_4__.SettingFlag),
/* harmony export */   "SettingNumber": () => (/* reexport safe */ _Config_SettingNumber__WEBPACK_IMPORTED_MODULE_5__.SettingNumber),
/* harmony export */   "SettingOption": () => (/* reexport safe */ _Config_SettingOption__WEBPACK_IMPORTED_MODULE_6__.SettingOption),
/* harmony export */   "SettingText": () => (/* reexport safe */ _Config_SettingText__WEBPACK_IMPORTED_MODULE_7__.SettingText),
/* harmony export */   "SettingsChangedEvent": () => (/* reexport safe */ _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_22__.SettingsChangedEvent),
/* harmony export */   "ShowOnScreenKeyboardEvent": () => (/* reexport safe */ _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_22__.ShowOnScreenKeyboardEvent),
/* harmony export */   "SignallingProtocol": () => (/* reexport safe */ _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_23__.SignallingProtocol),
/* harmony export */   "StatsReceivedEvent": () => (/* reexport safe */ _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_22__.StatsReceivedEvent),
/* harmony export */   "StreamLoadingEvent": () => (/* reexport safe */ _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_22__.StreamLoadingEvent),
/* harmony export */   "StreamPreConnectEvent": () => (/* reexport safe */ _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_22__.StreamPreConnectEvent),
/* harmony export */   "StreamPreDisconnectEvent": () => (/* reexport safe */ _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_22__.StreamPreDisconnectEvent),
/* harmony export */   "StreamReconnectEvent": () => (/* reexport safe */ _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_22__.StreamReconnectEvent),
/* harmony export */   "StreamerIDChangedMessageEvent": () => (/* reexport safe */ _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_22__.StreamerIDChangedMessageEvent),
/* harmony export */   "StreamerListMessageEvent": () => (/* reexport safe */ _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_22__.StreamerListMessageEvent),
/* harmony export */   "SubscribeFailedEvent": () => (/* reexport safe */ _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_22__.SubscribeFailedEvent),
/* harmony export */   "TextParameters": () => (/* reexport safe */ _Config_Config__WEBPACK_IMPORTED_MODULE_2__.TextParameters),
/* harmony export */   "VideoEncoderAvgQPEvent": () => (/* reexport safe */ _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_22__.VideoEncoderAvgQPEvent),
/* harmony export */   "VideoInitializedEvent": () => (/* reexport safe */ _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_22__.VideoInitializedEvent),
/* harmony export */   "WebRTCSettings": () => (/* reexport safe */ _DataChannel_InitialSettings__WEBPACK_IMPORTED_MODULE_11__.WebRTCSettings),
/* harmony export */   "WebRtcAutoConnectEvent": () => (/* reexport safe */ _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_22__.WebRtcAutoConnectEvent),
/* harmony export */   "WebRtcConnectedEvent": () => (/* reexport safe */ _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_22__.WebRtcConnectedEvent),
/* harmony export */   "WebRtcConnectingEvent": () => (/* reexport safe */ _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_22__.WebRtcConnectingEvent),
/* harmony export */   "WebRtcDisconnectedEvent": () => (/* reexport safe */ _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_22__.WebRtcDisconnectedEvent),
/* harmony export */   "WebRtcFailedEvent": () => (/* reexport safe */ _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_22__.WebRtcFailedEvent),
/* harmony export */   "WebRtcPlayerController": () => (/* reexport safe */ _WebRtcPlayer_WebRtcPlayerController__WEBPACK_IMPORTED_MODULE_0__.WebRtcPlayerController),
/* harmony export */   "WebRtcSdpAnswerEvent": () => (/* reexport safe */ _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_22__.WebRtcSdpAnswerEvent),
/* harmony export */   "WebRtcSdpEvent": () => (/* reexport safe */ _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_22__.WebRtcSdpEvent),
/* harmony export */   "WebRtcSdpOfferEvent": () => (/* reexport safe */ _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_22__.WebRtcSdpOfferEvent),
/* harmony export */   "WebRtcTCPRelayDetectedEvent": () => (/* reexport safe */ _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_22__.WebRtcTCPRelayDetectedEvent),
/* harmony export */   "WebSocketTransport": () => (/* reexport safe */ _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_23__.WebSocketTransport),
/* harmony export */   "WebSocketTransportNJS": () => (/* reexport safe */ _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_23__.WebSocketTransportNJS),
/* harmony export */   "WebXRController": () => (/* reexport safe */ _WebXR_WebXRController__WEBPACK_IMPORTED_MODULE_1__.WebXRController),
/* harmony export */   "XrFrameEvent": () => (/* reexport safe */ _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_22__.XrFrameEvent),
/* harmony export */   "XrSessionEndedEvent": () => (/* reexport safe */ _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_22__.XrSessionEndedEvent),
/* harmony export */   "XrSessionStartedEvent": () => (/* reexport safe */ _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_22__.XrSessionStartedEvent),
/* harmony export */   "isFlagId": () => (/* reexport safe */ _Config_Config__WEBPACK_IMPORTED_MODULE_2__.isFlagId),
/* harmony export */   "isNumericId": () => (/* reexport safe */ _Config_Config__WEBPACK_IMPORTED_MODULE_2__.isNumericId),
/* harmony export */   "isOptionId": () => (/* reexport safe */ _Config_Config__WEBPACK_IMPORTED_MODULE_2__.isOptionId),
/* harmony export */   "isTextId": () => (/* reexport safe */ _Config_Config__WEBPACK_IMPORTED_MODULE_2__.isTextId),
/* harmony export */   "overrideLogger": () => (/* reexport safe */ _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_23__.overrideLogger)
/* harmony export */ });
/* harmony import */ var _WebRtcPlayer_WebRtcPlayerController__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5750);
/* harmony import */ var _WebXR_WebXRController__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9581);
/* harmony import */ var _Config_Config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7463);
/* harmony import */ var _Config_SettingBase__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(4638);
/* harmony import */ var _Config_SettingFlag__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(4506);
/* harmony import */ var _Config_SettingNumber__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(6915);
/* harmony import */ var _Config_SettingOption__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(4138);
/* harmony import */ var _Config_SettingText__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(9689);
/* harmony import */ var _PixelStreaming_PixelStreaming__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(516);
/* harmony import */ var _AFK_AFKController__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(295);
/* harmony import */ var _DataChannel_LatencyTestResults__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(7942);
/* harmony import */ var _DataChannel_InitialSettings__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(877);
/* harmony import */ var _PeerConnectionController_AggregatedStats__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(6136);
/* harmony import */ var _Util_InputCoordTranslator__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(3754);
/* harmony import */ var _UeInstanceMessage_StreamMessageController__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(180);
/* harmony import */ var _PeerConnectionController_CandidatePairStats__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(7167);
/* harmony import */ var _PeerConnectionController_CandidateStat__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(5239);
/* harmony import */ var _PeerConnectionController_DataChannelStats__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(3450);
/* harmony import */ var _PeerConnectionController_InboundRTPStats__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(7190);
/* harmony import */ var _PeerConnectionController_OutBoundRTPStats__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(4598);
/* harmony import */ var _PeerConnectionController_LatencyCalculator__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(7445);
/* harmony import */ var _DataChannel_DataChannelLatencyTestResults__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(2410);
/* harmony import */ var _Util_EventEmitter__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(5391);
/* harmony import */ var _epicgames_ps_lib_pixelstreamingcommon_ue5_5__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(2050);
// Copyright Epic Games, Inc. All Rights Reserved.
























//# sourceMappingURL=pixelstreamingfrontend.js.map

/***/ }),

/***/ 2092:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Application": () => (/* binding */ Application)
/* harmony export */ });
/* harmony import */ var _epicgames_ps_lib_pixelstreamingfrontend_ue5_5__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(7463);
/* harmony import */ var _epicgames_ps_lib_pixelstreamingfrontend_ue5_5__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(7800);
/* harmony import */ var _Overlay_ConnectOverlay__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(2256);
/* harmony import */ var _Overlay_DisconnectOverlay__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(3825);
/* harmony import */ var _Overlay_PlayOverlay__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(2475);
/* harmony import */ var _Overlay_InfoOverlay__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(3912);
/* harmony import */ var _Overlay_ErrorOverlay__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(3089);
/* harmony import */ var _Overlay_AFKOverlay__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(7484);
/* harmony import */ var _UI_Controls__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(9666);
/* harmony import */ var _UI_LabelledButton__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(9998);
/* harmony import */ var _UI_SettingsPanel__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(8611);
/* harmony import */ var _UI_StatsPanel__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(1088);
/* harmony import */ var _UI_VideoQpIndicator__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(8214);
/* harmony import */ var _Config_ConfigUI__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(489);
/* harmony import */ var _UI_EditTextModal__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(2525);
/* harmony import */ var _UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(58);
/* harmony import */ var _UI_FullscreenIcon__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(2713);
// Copyright Epic Games, Inc. All Rights Reserved.
















/**
 * An Application is a combination of UI elements to display and manage a WebRTC Pixel Streaming
 * connection. It includes features for controlling a stream with mouse and keyboard,
 * managing connection endpoints, as well as displaying stats and other information about it.
 */
class Application {
    /**
     * @param options - Initialization options
     */
    constructor(options) {
        this.editTextModal = null;
        this._options = options;
        this.stream = options.stream;
        // Explicitly create ui features now so creation time is known
        this._uiFeatureElement = this.createUIFeaturesElement();
        // Explicitly create root element now so creation time is known
        this._rootElement = this.createRootElement(this.stream, this._uiFeatureElement);
        this.onColorModeChanged = options.onColorModeChanged;
        this.configUI = new _Config_ConfigUI__WEBPACK_IMPORTED_MODULE_0__.ConfigUI(this.stream.config);
        this.createOverlays();
        if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_1__.isPanelEnabled)(options.statsPanelConfig)) {
            // Add stats panel
            this.statsPanel = new _UI_StatsPanel__WEBPACK_IMPORTED_MODULE_2__.StatsPanel(options.statsPanelConfig);
            this.uiFeaturesElement.appendChild(this.statsPanel.rootElement);
        }
        if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_1__.isPanelEnabled)(options.settingsPanelConfig)) {
            // Add settings panel
            this.settingsPanel = new _UI_SettingsPanel__WEBPACK_IMPORTED_MODULE_3__.SettingsPanel();
            this.uiFeaturesElement.appendChild(this.settingsPanel.rootElement);
            this.configureSettings();
        }
        if (!options.videoQpIndicatorConfig || !options.videoQpIndicatorConfig.disableIndicator) {
            // Add the video stream QP indicator
            this.videoQpIndicator = new _UI_VideoQpIndicator__WEBPACK_IMPORTED_MODULE_4__.VideoQpIndicator(options.videoQpIndicatorConfig);
            this.uiFeaturesElement.appendChild(this.videoQpIndicator.rootElement);
        }
        this.createButtons();
        this.registerCallbacks();
        this.showConnectOrAutoConnectOverlays();
        this.setColorMode(this.configUI.isCustomFlagEnabled(_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_1__.ExtraFlags.LightMode));
        this.stream.config._addOnSettingChangedListener(_epicgames_ps_lib_pixelstreamingfrontend_ue5_5__WEBPACK_IMPORTED_MODULE_5__.Flags.HideUI, (isEnabled) => {
            this._uiFeatureElement.style.visibility = isEnabled ? 'hidden' : 'visible';
        });
        if (this.stream.config.isFlagEnabled(_epicgames_ps_lib_pixelstreamingfrontend_ue5_5__WEBPACK_IMPORTED_MODULE_5__.Flags.HideUI)) {
            this._uiFeatureElement.style.visibility = 'hidden';
        }
    }
    createOverlays() {
        // build all of the overlays
        this.disconnectOverlay = new _Overlay_DisconnectOverlay__WEBPACK_IMPORTED_MODULE_6__.DisconnectOverlay(this.stream.videoElementParent);
        this.connectOverlay = new _Overlay_ConnectOverlay__WEBPACK_IMPORTED_MODULE_7__.ConnectOverlay(this.stream.videoElementParent);
        this.playOverlay = new _Overlay_PlayOverlay__WEBPACK_IMPORTED_MODULE_8__.PlayOverlay(this.stream.videoElementParent);
        this.infoOverlay = new _Overlay_InfoOverlay__WEBPACK_IMPORTED_MODULE_9__.InfoOverlay(this.stream.videoElementParent);
        this.errorOverlay = new _Overlay_ErrorOverlay__WEBPACK_IMPORTED_MODULE_10__.ErrorOverlay(this.stream.videoElementParent);
        this.afkOverlay = new _Overlay_AFKOverlay__WEBPACK_IMPORTED_MODULE_11__.AFKOverlay(this.stream.videoElementParent);
        this.disconnectOverlay.onAction(() => this.stream.reconnect());
        // Build the webRtc connect overlay Event Listener and show the connect overlay
        this.connectOverlay.onAction(() => this.stream.connect());
        // set up the play overlays action
        this.playOverlay.onAction(() => this.stream.play());
    }
    /**
     * Set up button click functions and button functionality
     */
    createButtons() {
        const isIphone = /iPhone/.test(navigator.userAgent);
        const isIpad = /iPad/.test(navigator.userAgent) ||
            (/Macintosh/.test(navigator.userAgent) && 'ontouchend' in document);
        const isSafari = navigator.vendor &&
            navigator.vendor.indexOf('Apple') > -1 &&
            navigator.userAgent &&
            navigator.userAgent.indexOf('CriOS') == -1 &&
            navigator.userAgent.indexOf('FxiOS') == -1;
        // In some cases we want to disable fullscreen button if it is not explicitly requested:
        // IPhone does not support fullscreen API as at 28th July 2024 (see: https://caniuse.com/fullscreen) so if
        // we are on IPhone and user has not specified explicitly configured UI config for
        // fullscreen button then we should disable this button as it doesn't work.
        // Additionally iPad on non-Safari browsers doesn't really allow touch inputs and fullscreen video at the same time.
        // If you do this the video gets dragged off back to normal non-fullscreen video and then the video is paused.
        // See: https://github.com/EpicGamesExt/PixelStreamingInfrastructure/issues/219
        const disableFullscreenButton = isIphone || (!isSafari && isIpad);
        if (this._options.fullScreenControlsConfig === undefined && disableFullscreenButton) {
            this._options.fullScreenControlsConfig = { creationMode: _UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_1__.UIElementCreationMode.Disable };
        }
        const controlsUIConfig = {
            statsButtonType: this._options.statsPanelConfig
                ? this._options.statsPanelConfig.visibilityButtonConfig
                : undefined,
            settingsButtonType: this._options.settingsPanelConfig
                ? this._options.settingsPanelConfig.visibilityButtonConfig
                : undefined,
            fullscreenButtonType: this._options.fullScreenControlsConfig,
            xrIconType: this._options.xrControlsConfig,
            hideControlsInFullscreen: this._options.hideControlsInFullscreen
        };
        // Setup controls
        const controls = new _UI_Controls__WEBPACK_IMPORTED_MODULE_12__.Controls(controlsUIConfig);
        this.uiFeaturesElement.appendChild(controls.rootElement);
        // When we fullscreen we want this element to be the root
        const fullScreenButton = 
        // Depending on if we're creating an internal button, or using an external one
        !!this._options.fullScreenControlsConfig &&
            this._options.fullScreenControlsConfig.creationMode === _UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_1__.UIElementCreationMode.UseCustomElement
            ? // Either create a fullscreen class based on the external button
                new _UI_FullscreenIcon__WEBPACK_IMPORTED_MODULE_13__.FullScreenIconExternal(this._options.fullScreenControlsConfig.customElement)
            : // Or use the one created by the Controls initializer earlier
                controls.fullscreenIcon;
        if (fullScreenButton) {
            fullScreenButton.fullscreenElement = /iPad|iPhone|iPod/.test(navigator.userAgent)
                ? this.stream.videoElementParent.getElementsByTagName('video')[0]
                : this.rootElement;
        }
        // Add settings button to controls
        const settingsButton = controls.settingsIcon
            ? controls.settingsIcon.rootElement
            : this._options.settingsPanelConfig.visibilityButtonConfig.customElement;
        if (settingsButton)
            settingsButton.onclick = () => this.settingsClicked();
        if (this.settingsPanel)
            this.settingsPanel.settingsCloseButton.onclick = () => this.settingsClicked();
        // Add WebXR button to controls
        const xrButton = controls.xrIcon
            ? controls.xrIcon.rootElement
            : this._options.xrControlsConfig.creationMode === _UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_1__.UIElementCreationMode.UseCustomElement
                ? this._options.xrControlsConfig.customElement
                : undefined;
        if (xrButton)
            xrButton.onclick = () => this.stream.toggleXR();
        // setup the stats/info button
        const statsButton = controls.statsIcon
            ? controls.statsIcon.rootElement
            : this._options.statsPanelConfig.visibilityButtonConfig.customElement;
        if (statsButton)
            statsButton.onclick = () => this.statsClicked();
        if (this.statsPanel) {
            this.statsPanel.statsCloseButton.onclick = () => this.statsClicked();
        }
        // Add command buttons (if we have somewhere to add them to)
        if (this.settingsPanel) {
            // Add button for toggle fps
            const showFPSButton = new _UI_LabelledButton__WEBPACK_IMPORTED_MODULE_14__.LabelledButton('Show FPS', 'Toggle');
            showFPSButton.addOnClickListener(() => {
                this.stream.requestShowFps();
            });
            // Add button for restart stream
            const restartStreamButton = new _UI_LabelledButton__WEBPACK_IMPORTED_MODULE_14__.LabelledButton('Restart Stream', 'Restart');
            restartStreamButton.addOnClickListener(() => {
                this.stream.reconnect();
            });
            // Add button for request keyframe
            const requestKeyframeButton = new _UI_LabelledButton__WEBPACK_IMPORTED_MODULE_14__.LabelledButton('Request keyframe', 'Request');
            requestKeyframeButton.addOnClickListener(() => {
                this.stream.requestIframe();
            });
            const commandsSectionElem = this.configUI.buildSectionWithHeading(this.settingsPanel.settingsContentElement, 'Commands');
            commandsSectionElem.appendChild(showFPSButton.rootElement);
            commandsSectionElem.appendChild(requestKeyframeButton.rootElement);
            commandsSectionElem.appendChild(restartStreamButton.rootElement);
        }
    }
    /**
     * Configure the settings with on change listeners and any additional per experience settings.
     */
    configureSettings() {
        // This builds all the settings sections and flags under this `settingsContent` element.
        this.configUI.populateSettingsElement(this.settingsPanel.settingsContentElement, this._options.settingsPanelConfig);
        this.configUI.addCustomFlagOnSettingChangedListener(_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_1__.ExtraFlags.LightMode, (isLightMode) => {
            this.configUI.setCustomFlagLabel(_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_1__.ExtraFlags.LightMode, `Color Scheme: ${isLightMode ? 'Light' : 'Dark'} Mode`);
            this.setColorMode(isLightMode);
        });
    }
    registerCallbacks() {
        this.stream.addEventListener('afkWarningActivate', ({ data: { countDown, dismissAfk } }) => this.showAfkOverlay(countDown, dismissAfk));
        this.stream.addEventListener('afkWarningUpdate', ({ data: { countDown } }) => this.afkOverlay.updateCountdown(countDown));
        this.stream.addEventListener('afkWarningDeactivate', () => this.afkOverlay.hide());
        this.stream.addEventListener('afkTimedOut', () => this.afkOverlay.hide());
        this.stream.addEventListener('videoEncoderAvgQP', ({ data: { avgQP } }) => this.onVideoEncoderAvgQP(avgQP));
        this.stream.addEventListener('webRtcSdp', () => this.onWebRtcSdp());
        this.stream.addEventListener('webRtcAutoConnect', () => this.onWebRtcAutoConnect());
        this.stream.addEventListener('webRtcConnecting', () => this.onWebRtcConnecting());
        this.stream.addEventListener('webRtcConnected', () => this.onWebRtcConnected());
        this.stream.addEventListener('webRtcFailed', () => this.onWebRtcFailed());
        this.stream.addEventListener('webRtcDisconnected', ({ data: { eventString, allowClickToReconnect } }) => this.onDisconnect(eventString, allowClickToReconnect));
        this.stream.addEventListener('videoInitialized', () => this.onVideoInitialized());
        this.stream.addEventListener('streamLoading', () => this.onStreamLoading());
        this.stream.addEventListener('playStreamError', ({ data: { message } }) => this.onPlayStreamError(message));
        this.stream.addEventListener('playStream', () => this.onPlayStream());
        this.stream.addEventListener('playStreamRejected', ({ data: { reason } }) => this.onPlayStreamRejected(reason));
        this.stream.addEventListener('loadFreezeFrame', ({ data: { shouldShowPlayOverlay } }) => this.onLoadFreezeFrame(shouldShowPlayOverlay));
        this.stream.addEventListener('statsReceived', ({ data: { aggregatedStats } }) => this.onStatsReceived(aggregatedStats));
        this.stream.addEventListener('latencyCalculated', ({ data: { latencyInfo } }) => this.onLatencyUpdate(latencyInfo));
        this.stream.addEventListener('latencyTestResult', ({ data: { latencyTimings } }) => this.onLatencyTestResults(latencyTimings));
        this.stream.addEventListener('dataChannelLatencyTestResult', ({ data: { result } }) => this.onDataChannelLatencyTestResults(result));
        this.stream.addEventListener('streamerListMessage', ({ data: { messageStreamerList, autoSelectedStreamerId, wantedStreamerId } }) => this.handleStreamerListMessage(messageStreamerList, autoSelectedStreamerId, wantedStreamerId));
        this.stream.addEventListener('subscribeFailed', ({ data: { message } }) => this.handleSubscribeFailedMessage(message));
        this.stream.addEventListener('settingsChanged', (event) => this.onSettingsChanged(event));
        this.stream.addEventListener('playerCount', ({ data: { count } }) => this.onPlayerCount(count));
        this.stream.addEventListener('webRtcTCPRelayDetected', () => _epicgames_ps_lib_pixelstreamingfrontend_ue5_5__WEBPACK_IMPORTED_MODULE_15__.Logger.Warning(`Stream quailty degraded due to network enviroment, stream is relayed over TCP.`));
        this.stream.addEventListener('showOnScreenKeyboard', (event) => {
            // Only show the edit text modal if the flag is enabled
            if (!this.stream.config.isFlagEnabled(_epicgames_ps_lib_pixelstreamingfrontend_ue5_5__WEBPACK_IMPORTED_MODULE_5__.Flags.UseModalForTextInput)) {
                return;
            }
            const evtData = event.data;
            if (evtData.showOnScreenKeyboard) {
                this.showEditTextModal(evtData.contents);
            }
        });
    }
    /**
     * Gets the rootElement of the application, video stream and all UI are children of this element.
     */
    get rootElement() {
        if (!this._rootElement) {
            this._rootElement = this.createRootElement(this.stream, this.uiFeaturesElement);
        }
        return this._rootElement;
    }
    /**
     * Creates the root element for the Pixel Streaming UI.
     * Note: This should be called before the Pixel Streaming object is created.
     * @param pixelstreaming - The Pixel Streaming object.
     * @param uiFeaturesElem - The element holding all the custom UI features.
     * @returns A div with the id #playerUI populated with videoElementParent and uiFeatureElement.
     */
    createRootElement(pixelstreaming, uiFeaturesElem) {
        const elem = document.createElement('div');
        elem.id = 'playerUI';
        elem.classList.add('noselect');
        if (pixelstreaming === undefined) {
            throw new Error('Could not create root element properly - pixelstreaming object was undefined. Are you calling this too early?');
        }
        if (pixelstreaming.videoElementParent === undefined) {
            throw new Error('Could not create root element properly - videoElementParent object was undefined. Are you calling this too early?');
        }
        if (uiFeaturesElem === undefined) {
            throw new Error('Could not create root element properly - uiFeaturesElement object was undefined. Are you calling this too early?');
        }
        elem.appendChild(pixelstreaming.videoElementParent);
        elem.appendChild(uiFeaturesElem);
        return elem;
    }
    /**
     * Gets the element that contains all the UI features, like the stats and settings panels.
     */
    get uiFeaturesElement() {
        if (!this._uiFeatureElement) {
            this._uiFeatureElement = this.createUIFeaturesElement();
        }
        return this._uiFeatureElement;
    }
    /**
     * Creates the UI features element for holding all the custom UI features.
     * @returns A div with the id #uiFeatures.
     */
    createUIFeaturesElement() {
        const elem = document.createElement('div');
        elem.id = 'uiFeatures';
        return elem;
    }
    /**
     * Shows the disconnect overlay
     * @param updateText - the text that will be displayed in the overlay
     */
    showDisconnectOverlay(updateText) {
        this.hideCurrentOverlay();
        this.updateDisconnectOverlay(updateText);
        this.disconnectOverlay.show();
        this.currentOverlay = this.disconnectOverlay;
    }
    /**
     * Update the disconnect overlays span text
     * @param updateText - the new countdown number
     */
    updateDisconnectOverlay(updateText) {
        this.disconnectOverlay.update(updateText);
    }
    /**
     * Activates the disconnect overlays action
     */
    onDisconnectionAction() {
        this.disconnectOverlay.activate();
    }
    /**
     * Hides the current overlay
     */
    hideCurrentOverlay() {
        if (this.currentOverlay != null) {
            this.currentOverlay.hide();
            this.currentOverlay = null;
        }
    }
    /**
     * Shows the connect overlay
     */
    showConnectOverlay() {
        this.hideCurrentOverlay();
        this.connectOverlay.show();
        this.currentOverlay = this.connectOverlay;
    }
    /**
     * Shows the play overlay
     */
    showPlayOverlay() {
        this.hideCurrentOverlay();
        this.playOverlay.show();
        this.currentOverlay = this.playOverlay;
    }
    /**
     * Shows the text overlay
     * @param text - the text that will be shown in the overlay
     */
    showTextOverlay(text) {
        this.hideCurrentOverlay();
        this.infoOverlay.update(text);
        this.infoOverlay.show();
        this.currentOverlay = this.infoOverlay;
    }
    /**
     * Shows the error overlay
     * @param text - the text that will be shown in the overlay
     */
    showErrorOverlay(text) {
        this.hideCurrentOverlay();
        this.errorOverlay.update(text);
        this.errorOverlay.show();
        this.currentOverlay = this.errorOverlay;
    }
    /**
     * Shows or hides the settings panel if clicked
     */
    settingsClicked() {
        var _a;
        (_a = this.statsPanel) === null || _a === void 0 ? void 0 : _a.hide();
        this.settingsPanel.toggleVisibility();
    }
    /**
     * Shows or hides the stats panel if clicked
     */
    statsClicked() {
        var _a;
        (_a = this.settingsPanel) === null || _a === void 0 ? void 0 : _a.hide();
        this.statsPanel.toggleVisibility();
    }
    /**
     * Activates the connect overlays action
     */
    onConnectAction() {
        this.connectOverlay.activate();
    }
    /**
     * Activates the play overlays action
     */
    onPlayAction() {
        this.playOverlay.activate();
    }
    /**
     * Shows the afk overlay
     * @param countDown - the countdown number for the afk countdown
     */
    showAfkOverlay(countDown, dismissAfk) {
        this.hideCurrentOverlay();
        this.afkOverlay.updateCountdown(countDown);
        this.afkOverlay.onAction(() => dismissAfk());
        this.afkOverlay.show();
        this.currentOverlay = this.afkOverlay;
    }
    /**
     * Show the Connect Overlay or auto connect
     */
    showConnectOrAutoConnectOverlays() {
        // set up if the auto play will be used or regular click to start
        if (!this.stream.config.isFlagEnabled(_epicgames_ps_lib_pixelstreamingfrontend_ue5_5__WEBPACK_IMPORTED_MODULE_5__.Flags.AutoConnect)) {
            this.showConnectOverlay();
        }
    }
    /**
     * Show the webRtcAutoConnect Overlay and connect
     */
    onWebRtcAutoConnect() {
        this.showTextOverlay('Auto Connecting Now');
    }
    /**
     * Set up functionality to happen when receiving a webRTC answer
     */
    onWebRtcSdp() {
        this.showTextOverlay('WebRTC Connection Negotiated');
    }
    /**
     * Shows a text overlay to alert the user the stream is currently loading
     */
    onStreamLoading() {
        // build the spinner span
        const spinnerSpan = document.createElement('span');
        spinnerSpan.className = 'visually-hidden';
        spinnerSpan.innerHTML = 'Loading...';
        // build the spinner div
        const spinnerDiv = document.createElement('div');
        spinnerDiv.id = 'loading-spinner';
        spinnerDiv.className = 'spinner-border ms-2';
        spinnerDiv.setAttribute('role', 'status');
        // append the spinner to the element
        spinnerDiv.appendChild(spinnerSpan);
        this.showTextOverlay('Loading Stream ' + spinnerDiv.outerHTML);
    }
    /**
     * Event fired when the video is disconnected - displays the error overlay and resets the buttons stream tools upon disconnect
     * @param eventString - the event text that will be shown in the overlay
     * @param allowClickToReconnect - true if we want to allow the user to click to reconnect. Otherwise it's just a message.
     */
    onDisconnect(eventString, allowClickToReconnect) {
        var _a;
        const overlayMessage = 'Disconnected' + (eventString ? `: ${eventString}` : '.');
        if (allowClickToReconnect) {
            this.showDisconnectOverlay(`${overlayMessage} Click To Restart.`);
        }
        else {
            this.showErrorOverlay(overlayMessage);
        }
        // disable starting a latency checks
        (_a = this.statsPanel) === null || _a === void 0 ? void 0 : _a.onDisconnect();
    }
    /**
     * Handles when Web Rtc is connecting
     */
    onWebRtcConnecting() {
        this.showTextOverlay('Starting connection to server, please wait');
    }
    /**
     * Handles when Web Rtc has connected
     */
    onWebRtcConnected() {
        this.showTextOverlay('WebRTC connected, waiting for video');
    }
    /**
     * Handles when Web Rtc fails to connect
     */
    onWebRtcFailed() {
        this.showErrorOverlay('Unable to setup video');
    }
    onLoadFreezeFrame(shouldShowPlayOverlay) {
        if (shouldShowPlayOverlay === true) {
            _epicgames_ps_lib_pixelstreamingfrontend_ue5_5__WEBPACK_IMPORTED_MODULE_15__.Logger.Info('showing play overlay');
            this.showPlayOverlay();
        }
    }
    onPlayStream() {
        this.hideCurrentOverlay();
    }
    onPlayStreamError(message) {
        this.showErrorOverlay(message);
    }
    /* eslint-disable-next-line @typescript-eslint/no-unused-vars */
    onPlayStreamRejected(onRejectedReason) {
        this.showPlayOverlay();
    }
    onVideoInitialized() {
        var _a;
        if (!this.stream.config.isFlagEnabled(_epicgames_ps_lib_pixelstreamingfrontend_ue5_5__WEBPACK_IMPORTED_MODULE_5__.Flags.AutoPlayVideo)) {
            this.showPlayOverlay();
        }
        (_a = this.statsPanel) === null || _a === void 0 ? void 0 : _a.onVideoInitialized(this.stream);
    }
    /**
     * Set up functionality to happen when calculating the average video encoder qp
     * @param QP - the quality number of the stream
     */
    onVideoEncoderAvgQP(QP) {
        // Update internal QP indicator if one is present
        if (this.videoQpIndicator) {
            this.videoQpIndicator.updateQpTooltip(QP);
        }
    }
    onInitialSettings(settings) {
        var _a;
        if (settings.PixelStreamingSettings) {
            (_a = this.statsPanel) === null || _a === void 0 ? void 0 : _a.configure(settings.PixelStreamingSettings);
        }
    }
    onStatsReceived(aggregatedStats) {
        var _a;
        // Grab all stats we can off the aggregated stats
        (_a = this.statsPanel) === null || _a === void 0 ? void 0 : _a.handleStats(aggregatedStats);
    }
    onLatencyUpdate(latencyInfo) {
        var _a;
        (_a = this.statsPanel) === null || _a === void 0 ? void 0 : _a.handleLatencyInfo(latencyInfo);
    }
    onLatencyTestResults(latencyTimings) {
        var _a;
        (_a = this.statsPanel) === null || _a === void 0 ? void 0 : _a.latencyTest.handleTestResult(latencyTimings);
    }
    onDataChannelLatencyTestResults(result) {
        var _a;
        (_a = this.statsPanel) === null || _a === void 0 ? void 0 : _a.dataChannelLatencyTest.handleTestResult(result);
    }
    onPlayerCount(playerCount) {
        var _a;
        (_a = this.statsPanel) === null || _a === void 0 ? void 0 : _a.handlePlayerCount(playerCount);
    }
    handleStreamerListMessage(messageStreamingList, autoSelectedStreamerId, wantedStreamerId) {
        const waitForStreamer = this.stream.config.isFlagEnabled(_epicgames_ps_lib_pixelstreamingfrontend_ue5_5__WEBPACK_IMPORTED_MODULE_5__.Flags.WaitForStreamer);
        const isReconnecting = this.stream.isReconnecting();
        let message = null;
        let allowRestart = true;
        if (!autoSelectedStreamerId) {
            if (waitForStreamer && wantedStreamerId) {
                if (isReconnecting) {
                    message = `Waiting for ${wantedStreamerId} to become available.`;
                    allowRestart = false;
                }
                else {
                    message = `Gave up waiting for ${wantedStreamerId} to become available. Click to try again`;
                    if (messageStreamingList.ids.length > 0) {
                        message += ` or select a streamer from the settings menu.`;
                    }
                    allowRestart = true;
                }
            }
            else if (messageStreamingList.ids.length == 0) {
                if (isReconnecting) {
                    message = `Waiting for a streamer to become available.`;
                    allowRestart = false;
                }
                else {
                    message = `No streamers available. Click to try again.`;
                    allowRestart = true;
                }
            }
            else {
                message = `Multiple streamers available. Select one from the settings menu.`;
                allowRestart = false;
            }
            if (allowRestart) {
                this.showDisconnectOverlay(message);
            }
            else {
                this.showTextOverlay(message);
            }
        }
    }
    handleSubscribeFailedMessage(message) {
        this.showDisconnectOverlay(`Subscribe failed: "${message}" Click to try again`);
    }
    /**
     * Set light/dark color mode
     * @param isLightMode - should we use a light or dark color scheme
     */
    setColorMode(isLightMode) {
        if (this.onColorModeChanged) {
            this.onColorModeChanged(isLightMode);
        }
    }
    showEditTextModal(ueTextboxContents) {
        var _a;
        // Remove any existing modal
        (_a = this.editTextModal) === null || _a === void 0 ? void 0 : _a.rootElement.remove();
        // Make a new modal for editing the UE textbox on the browser side
        this.editTextModal = new _UI_EditTextModal__WEBPACK_IMPORTED_MODULE_16__.EditTextModal();
        // Add it to the root of the Pixel Streaming application
        this.rootElement.append(this.editTextModal.rootElement);
        // Add the text content from UE side and summon on-screen keyboard
        this.editTextModal.showModal(ueTextboxContents);
        // Bind to the confirm event
        this.editTextModal.events.addEventListener('editConfirmed', (evt) => {
            const editTextEvent = evt;
            this.stream.sendTextboxEntry(editTextEvent.confirmedText);
        });
    }
    onSettingsChanged(event) {
        // Pass the event directly onto the configUI. This will do things like updating the possible values
        // as well as the selected value
        this.configUI.onSettingsChanged(event);
        const { 
        /* eslint-disable-next-line @typescript-eslint/no-unused-vars */
        data: { id, target, type } } = event;
        // Explicitly handle specific setting behaviour
        if (id == _epicgames_ps_lib_pixelstreamingfrontend_ue5_5__WEBPACK_IMPORTED_MODULE_5__.OptionParameters.PreferredQuality) {
            const preferredQualityOption = this.stream.config.getSettingOption(_epicgames_ps_lib_pixelstreamingfrontend_ue5_5__WEBPACK_IMPORTED_MODULE_5__.OptionParameters.PreferredQuality);
            if ([...preferredQualityOption.options].includes('Default')) {
                this.configUI.disableSetting(_epicgames_ps_lib_pixelstreamingfrontend_ue5_5__WEBPACK_IMPORTED_MODULE_5__.OptionParameters.PreferredQuality);
            }
            else {
                this.configUI.enableSetting(_epicgames_ps_lib_pixelstreamingfrontend_ue5_5__WEBPACK_IMPORTED_MODULE_5__.OptionParameters.PreferredQuality);
            }
        }
    }
}
//# sourceMappingURL=Application.js.map

/***/ }),

/***/ 489:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ConfigUI": () => (/* binding */ ConfigUI)
/* harmony export */ });
/* harmony import */ var _epicgames_ps_lib_pixelstreamingfrontend_ue5_5__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4506);
/* harmony import */ var _epicgames_ps_lib_pixelstreamingfrontend_ue5_5__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(7463);
/* harmony import */ var _epicgames_ps_lib_pixelstreamingfrontend_ue5_5__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(7800);
/* harmony import */ var _SettingUIFlag__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(2396);
/* harmony import */ var _SettingUINumber__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(768);
/* harmony import */ var _SettingUIText__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(3652);
/* harmony import */ var _SettingUIOption__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(6223);
/* harmony import */ var _UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(58);
// Copyright Epic Games, Inc. All Rights Reserved.






class ConfigUI {
    // ------------ Settings -----------------
    constructor(config) {
        this.customFlags = new Map();
        /* A map of flags that can be toggled - options that can be set in the application - e.g. Use Mic? */
        this.flagsUi = new Map();
        /* A map of numerical settings - options that can be in the application - e.g. MinBitrate */
        this.numericParametersUi = new Map();
        /* A map of text settings - e.g. signalling server url */
        this.textParametersUi = new Map();
        /* A map of enum based settings - e.g. preferred codec */
        this.optionParametersUi = new Map();
        this.createCustomUISettings(config.useUrlParams);
        this.registerSettingsUIComponents(config);
    }
    /**
     * Create custom UI settings that are not provided by the Pixel Streaming library.
     */
    createCustomUISettings(useUrlParams) {
        this.customFlags.set(_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.ExtraFlags.LightMode, new _epicgames_ps_lib_pixelstreamingfrontend_ue5_5__WEBPACK_IMPORTED_MODULE_1__.SettingFlag(_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.ExtraFlags.LightMode, 'Color Scheme: Dark Mode', 'Page styling will be either light or dark', false /*if want to use system pref: (window.matchMedia && window.matchMedia('(prefers-color-scheme: light)').matches)*/, useUrlParams, (isLightMode, setting) => {
            setting.label = `Color Scheme: ${isLightMode ? 'Light' : 'Dark'} Mode`;
        }));
    }
    /**
     * Creates UI wrapper components for each setting element in config.
     * @param config -
     */
    registerSettingsUIComponents(config) {
        for (const setting of config.getFlags()) {
            this.flagsUi.set(setting.id, new _SettingUIFlag__WEBPACK_IMPORTED_MODULE_2__.SettingUIFlag(setting));
        }
        for (const setting of Array.from(this.customFlags.values())) {
            this.flagsUi.set(setting.id, new _SettingUIFlag__WEBPACK_IMPORTED_MODULE_2__.SettingUIFlag(setting));
        }
        for (const setting of config.getTextSettings()) {
            this.textParametersUi.set(setting.id, new _SettingUIText__WEBPACK_IMPORTED_MODULE_3__.SettingUIText(setting));
        }
        for (const setting of config.getNumericSettings()) {
            this.numericParametersUi.set(setting.id, new _SettingUINumber__WEBPACK_IMPORTED_MODULE_4__.SettingUINumber(setting));
        }
        for (const setting of config.getOptionSettings()) {
            this.optionParametersUi.set(setting.id, new _SettingUIOption__WEBPACK_IMPORTED_MODULE_5__.SettingUIOption(setting));
        }
    }
    /**
     * Make DOM elements for a settings section with a heading.
     * @param settingsElem - The parent container for our DOM elements.
     * @param sectionHeading - The heading element to go into the section.
     * @returns The constructed DOM element for the section.
     */
    buildSectionWithHeading(settingsElem, sectionHeading) {
        // make section element
        const sectionElem = document.createElement('section');
        sectionElem.classList.add('settingsContainer');
        // make section heading
        const psSettingsHeader = document.createElement('div');
        psSettingsHeader.classList.add('settingsHeader');
        psSettingsHeader.classList.add('settings-text');
        psSettingsHeader.textContent = sectionHeading;
        // add section and heading to parent settings element
        sectionElem.appendChild(psSettingsHeader);
        settingsElem.appendChild(sectionElem);
        return sectionElem;
    }
    /**
     * Setup flags with their default values and add them to the `Config.flags` map.
     * @param settingsElem - - The element that contains all the individual settings sections, flags, and so on.
     */
    populateSettingsElement(settingsElem, settingsConfig) {
        if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSectionEnabled)(settingsConfig, _UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.SettingsSections.PixelStreaming)) {
            /* Setup all Pixel Streaming specific settings */
            const psSettingsSection = this.buildSectionWithHeading(settingsElem, _UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.SettingsSections.PixelStreaming);
            // make settings show up in DOM
            if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSettingEnabled)(settingsConfig, _epicgames_ps_lib_pixelstreamingfrontend_ue5_5__WEBPACK_IMPORTED_MODULE_6__.TextParameters.SignallingServerUrl))
                this.addSettingText(psSettingsSection, this.textParametersUi.get(_epicgames_ps_lib_pixelstreamingfrontend_ue5_5__WEBPACK_IMPORTED_MODULE_6__.TextParameters.SignallingServerUrl));
            if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSettingEnabled)(settingsConfig, _epicgames_ps_lib_pixelstreamingfrontend_ue5_5__WEBPACK_IMPORTED_MODULE_6__.OptionParameters.StreamerId))
                this.addSettingOption(psSettingsSection, this.optionParametersUi.get(_epicgames_ps_lib_pixelstreamingfrontend_ue5_5__WEBPACK_IMPORTED_MODULE_6__.OptionParameters.StreamerId));
            if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSettingEnabled)(settingsConfig, _epicgames_ps_lib_pixelstreamingfrontend_ue5_5__WEBPACK_IMPORTED_MODULE_6__.Flags.AutoConnect))
                this.addSettingFlag(psSettingsSection, this.flagsUi.get(_epicgames_ps_lib_pixelstreamingfrontend_ue5_5__WEBPACK_IMPORTED_MODULE_6__.Flags.AutoConnect));
            if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSettingEnabled)(settingsConfig, _epicgames_ps_lib_pixelstreamingfrontend_ue5_5__WEBPACK_IMPORTED_MODULE_6__.Flags.AutoPlayVideo))
                this.addSettingFlag(psSettingsSection, this.flagsUi.get(_epicgames_ps_lib_pixelstreamingfrontend_ue5_5__WEBPACK_IMPORTED_MODULE_6__.Flags.AutoPlayVideo));
            if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSettingEnabled)(settingsConfig, _epicgames_ps_lib_pixelstreamingfrontend_ue5_5__WEBPACK_IMPORTED_MODULE_6__.Flags.UseMic))
                this.addSettingFlag(psSettingsSection, this.flagsUi.get(_epicgames_ps_lib_pixelstreamingfrontend_ue5_5__WEBPACK_IMPORTED_MODULE_6__.Flags.UseMic));
            if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSettingEnabled)(settingsConfig, _epicgames_ps_lib_pixelstreamingfrontend_ue5_5__WEBPACK_IMPORTED_MODULE_6__.Flags.UseCamera))
                this.addSettingFlag(psSettingsSection, this.flagsUi.get(_epicgames_ps_lib_pixelstreamingfrontend_ue5_5__WEBPACK_IMPORTED_MODULE_6__.Flags.UseCamera));
            if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSettingEnabled)(settingsConfig, _epicgames_ps_lib_pixelstreamingfrontend_ue5_5__WEBPACK_IMPORTED_MODULE_6__.Flags.StartVideoMuted))
                this.addSettingFlag(psSettingsSection, this.flagsUi.get(_epicgames_ps_lib_pixelstreamingfrontend_ue5_5__WEBPACK_IMPORTED_MODULE_6__.Flags.StartVideoMuted));
            if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSettingEnabled)(settingsConfig, _epicgames_ps_lib_pixelstreamingfrontend_ue5_5__WEBPACK_IMPORTED_MODULE_6__.Flags.IsQualityController))
                this.addSettingFlag(psSettingsSection, this.flagsUi.get(_epicgames_ps_lib_pixelstreamingfrontend_ue5_5__WEBPACK_IMPORTED_MODULE_6__.Flags.IsQualityController));
            if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSettingEnabled)(settingsConfig, _epicgames_ps_lib_pixelstreamingfrontend_ue5_5__WEBPACK_IMPORTED_MODULE_6__.Flags.ForceMonoAudio))
                this.addSettingFlag(psSettingsSection, this.flagsUi.get(_epicgames_ps_lib_pixelstreamingfrontend_ue5_5__WEBPACK_IMPORTED_MODULE_6__.Flags.ForceMonoAudio));
            if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSettingEnabled)(settingsConfig, _epicgames_ps_lib_pixelstreamingfrontend_ue5_5__WEBPACK_IMPORTED_MODULE_6__.Flags.ForceTURN))
                this.addSettingFlag(psSettingsSection, this.flagsUi.get(_epicgames_ps_lib_pixelstreamingfrontend_ue5_5__WEBPACK_IMPORTED_MODULE_6__.Flags.ForceTURN));
            if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSettingEnabled)(settingsConfig, _epicgames_ps_lib_pixelstreamingfrontend_ue5_5__WEBPACK_IMPORTED_MODULE_6__.Flags.SuppressBrowserKeys))
                this.addSettingFlag(psSettingsSection, this.flagsUi.get(_epicgames_ps_lib_pixelstreamingfrontend_ue5_5__WEBPACK_IMPORTED_MODULE_6__.Flags.SuppressBrowserKeys));
            if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSettingEnabled)(settingsConfig, _epicgames_ps_lib_pixelstreamingfrontend_ue5_5__WEBPACK_IMPORTED_MODULE_6__.Flags.AFKDetection))
                this.addSettingFlag(psSettingsSection, this.flagsUi.get(_epicgames_ps_lib_pixelstreamingfrontend_ue5_5__WEBPACK_IMPORTED_MODULE_6__.Flags.AFKDetection));
            if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSettingEnabled)(settingsConfig, _epicgames_ps_lib_pixelstreamingfrontend_ue5_5__WEBPACK_IMPORTED_MODULE_6__.Flags.WaitForStreamer))
                this.addSettingFlag(psSettingsSection, this.flagsUi.get(_epicgames_ps_lib_pixelstreamingfrontend_ue5_5__WEBPACK_IMPORTED_MODULE_6__.Flags.WaitForStreamer));
            if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSettingEnabled)(settingsConfig, _epicgames_ps_lib_pixelstreamingfrontend_ue5_5__WEBPACK_IMPORTED_MODULE_6__.NumericParameters.AFKTimeoutSecs))
                this.addSettingNumeric(psSettingsSection, this.numericParametersUi.get(_epicgames_ps_lib_pixelstreamingfrontend_ue5_5__WEBPACK_IMPORTED_MODULE_6__.NumericParameters.AFKTimeoutSecs));
            if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSettingEnabled)(settingsConfig, _epicgames_ps_lib_pixelstreamingfrontend_ue5_5__WEBPACK_IMPORTED_MODULE_6__.NumericParameters.AFKCountdownSecs))
                this.addSettingNumeric(psSettingsSection, this.numericParametersUi.get(_epicgames_ps_lib_pixelstreamingfrontend_ue5_5__WEBPACK_IMPORTED_MODULE_6__.NumericParameters.AFKCountdownSecs));
            if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSettingEnabled)(settingsConfig, _epicgames_ps_lib_pixelstreamingfrontend_ue5_5__WEBPACK_IMPORTED_MODULE_6__.NumericParameters.MaxReconnectAttempts))
                this.addSettingNumeric(psSettingsSection, this.numericParametersUi.get(_epicgames_ps_lib_pixelstreamingfrontend_ue5_5__WEBPACK_IMPORTED_MODULE_6__.NumericParameters.MaxReconnectAttempts));
            if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSettingEnabled)(settingsConfig, _epicgames_ps_lib_pixelstreamingfrontend_ue5_5__WEBPACK_IMPORTED_MODULE_6__.NumericParameters.StreamerAutoJoinInterval))
                this.addSettingNumeric(psSettingsSection, this.numericParametersUi.get(_epicgames_ps_lib_pixelstreamingfrontend_ue5_5__WEBPACK_IMPORTED_MODULE_6__.NumericParameters.StreamerAutoJoinInterval));
            if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSettingEnabled)(settingsConfig, _epicgames_ps_lib_pixelstreamingfrontend_ue5_5__WEBPACK_IMPORTED_MODULE_6__.NumericParameters.KeepaliveDelay))
                this.addSettingNumeric(psSettingsSection, this.numericParametersUi.get(_epicgames_ps_lib_pixelstreamingfrontend_ue5_5__WEBPACK_IMPORTED_MODULE_6__.NumericParameters.KeepaliveDelay));
        }
        if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSectionEnabled)(settingsConfig, _UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.SettingsSections.UI)) {
            /* Setup all view/ui related settings under this section */
            const viewSettingsSection = this.buildSectionWithHeading(settingsElem, _UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.SettingsSections.UI);
            if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSettingEnabled)(settingsConfig, _epicgames_ps_lib_pixelstreamingfrontend_ue5_5__WEBPACK_IMPORTED_MODULE_6__.Flags.MatchViewportResolution))
                this.addSettingFlag(viewSettingsSection, this.flagsUi.get(_epicgames_ps_lib_pixelstreamingfrontend_ue5_5__WEBPACK_IMPORTED_MODULE_6__.Flags.MatchViewportResolution));
            if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSettingEnabled)(settingsConfig, _epicgames_ps_lib_pixelstreamingfrontend_ue5_5__WEBPACK_IMPORTED_MODULE_6__.Flags.HoveringMouseMode))
                this.addSettingFlag(viewSettingsSection, this.flagsUi.get(_epicgames_ps_lib_pixelstreamingfrontend_ue5_5__WEBPACK_IMPORTED_MODULE_6__.Flags.HoveringMouseMode));
            if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSettingEnabled)(settingsConfig, _UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.ExtraFlags.LightMode))
                this.addSettingFlag(viewSettingsSection, this.flagsUi.get(_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.ExtraFlags.LightMode));
        }
        if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSectionEnabled)(settingsConfig, _UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.SettingsSections.Input)) {
            /* Setup all encoder related settings under this section */
            const inputSettingsSection = this.buildSectionWithHeading(settingsElem, _UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.SettingsSections.Input);
            if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSettingEnabled)(settingsConfig, _epicgames_ps_lib_pixelstreamingfrontend_ue5_5__WEBPACK_IMPORTED_MODULE_6__.Flags.KeyboardInput))
                this.addSettingFlag(inputSettingsSection, this.flagsUi.get(_epicgames_ps_lib_pixelstreamingfrontend_ue5_5__WEBPACK_IMPORTED_MODULE_6__.Flags.KeyboardInput));
            if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSettingEnabled)(settingsConfig, _epicgames_ps_lib_pixelstreamingfrontend_ue5_5__WEBPACK_IMPORTED_MODULE_6__.Flags.MouseInput))
                this.addSettingFlag(inputSettingsSection, this.flagsUi.get(_epicgames_ps_lib_pixelstreamingfrontend_ue5_5__WEBPACK_IMPORTED_MODULE_6__.Flags.MouseInput));
            if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSettingEnabled)(settingsConfig, _epicgames_ps_lib_pixelstreamingfrontend_ue5_5__WEBPACK_IMPORTED_MODULE_6__.Flags.FakeMouseWithTouches))
                this.addSettingFlag(inputSettingsSection, this.flagsUi.get(_epicgames_ps_lib_pixelstreamingfrontend_ue5_5__WEBPACK_IMPORTED_MODULE_6__.Flags.FakeMouseWithTouches));
            if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSettingEnabled)(settingsConfig, _epicgames_ps_lib_pixelstreamingfrontend_ue5_5__WEBPACK_IMPORTED_MODULE_6__.Flags.TouchInput))
                this.addSettingFlag(inputSettingsSection, this.flagsUi.get(_epicgames_ps_lib_pixelstreamingfrontend_ue5_5__WEBPACK_IMPORTED_MODULE_6__.Flags.TouchInput));
            if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSettingEnabled)(settingsConfig, _epicgames_ps_lib_pixelstreamingfrontend_ue5_5__WEBPACK_IMPORTED_MODULE_6__.Flags.GamepadInput))
                this.addSettingFlag(inputSettingsSection, this.flagsUi.get(_epicgames_ps_lib_pixelstreamingfrontend_ue5_5__WEBPACK_IMPORTED_MODULE_6__.Flags.GamepadInput));
            if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSettingEnabled)(settingsConfig, _epicgames_ps_lib_pixelstreamingfrontend_ue5_5__WEBPACK_IMPORTED_MODULE_6__.Flags.XRControllerInput))
                this.addSettingFlag(inputSettingsSection, this.flagsUi.get(_epicgames_ps_lib_pixelstreamingfrontend_ue5_5__WEBPACK_IMPORTED_MODULE_6__.Flags.XRControllerInput));
        }
        if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSectionEnabled)(settingsConfig, _UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.SettingsSections.Encoder)) {
            /* Setup all encoder related settings under this section */
            const encoderSettingsSection = this.buildSectionWithHeading(settingsElem, _UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.SettingsSections.Encoder);
            if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSettingEnabled)(settingsConfig, _epicgames_ps_lib_pixelstreamingfrontend_ue5_5__WEBPACK_IMPORTED_MODULE_6__.NumericParameters.CompatQualityMin))
                this.addSettingNumeric(encoderSettingsSection, this.numericParametersUi.get(_epicgames_ps_lib_pixelstreamingfrontend_ue5_5__WEBPACK_IMPORTED_MODULE_6__.NumericParameters.CompatQualityMin));
            if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSettingEnabled)(settingsConfig, _epicgames_ps_lib_pixelstreamingfrontend_ue5_5__WEBPACK_IMPORTED_MODULE_6__.NumericParameters.CompatQualityMax))
                this.addSettingNumeric(encoderSettingsSection, this.numericParametersUi.get(_epicgames_ps_lib_pixelstreamingfrontend_ue5_5__WEBPACK_IMPORTED_MODULE_6__.NumericParameters.CompatQualityMax));
            const preferredCodecOption = this.optionParametersUi.get(_epicgames_ps_lib_pixelstreamingfrontend_ue5_5__WEBPACK_IMPORTED_MODULE_6__.OptionParameters.PreferredCodec);
            if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSettingEnabled)(settingsConfig, _epicgames_ps_lib_pixelstreamingfrontend_ue5_5__WEBPACK_IMPORTED_MODULE_6__.OptionParameters.PreferredCodec))
                this.addSettingOption(encoderSettingsSection, this.optionParametersUi.get(_epicgames_ps_lib_pixelstreamingfrontend_ue5_5__WEBPACK_IMPORTED_MODULE_6__.OptionParameters.PreferredCodec));
            if (preferredCodecOption &&
                [...preferredCodecOption.selector.options]
                    .map((o) => o.value)
                    .includes('Only available on Chrome')) {
                preferredCodecOption.disable();
            }
            if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSettingEnabled)(settingsConfig, _epicgames_ps_lib_pixelstreamingfrontend_ue5_5__WEBPACK_IMPORTED_MODULE_6__.OptionParameters.PreferredQuality))
                this.addSettingOption(encoderSettingsSection, this.optionParametersUi.get(_epicgames_ps_lib_pixelstreamingfrontend_ue5_5__WEBPACK_IMPORTED_MODULE_6__.OptionParameters.PreferredQuality));
        }
        if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSectionEnabled)(settingsConfig, _UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.SettingsSections.WebRTC)) {
            /* Setup all webrtc related settings under this section */
            const webrtcSettingsSection = this.buildSectionWithHeading(settingsElem, _UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.SettingsSections.WebRTC);
            if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSettingEnabled)(settingsConfig, _epicgames_ps_lib_pixelstreamingfrontend_ue5_5__WEBPACK_IMPORTED_MODULE_6__.NumericParameters.WebRTCFPS))
                this.addSettingNumeric(webrtcSettingsSection, this.numericParametersUi.get(_epicgames_ps_lib_pixelstreamingfrontend_ue5_5__WEBPACK_IMPORTED_MODULE_6__.NumericParameters.WebRTCFPS));
            if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSettingEnabled)(settingsConfig, _epicgames_ps_lib_pixelstreamingfrontend_ue5_5__WEBPACK_IMPORTED_MODULE_6__.NumericParameters.WebRTCMinBitrate))
                this.addSettingNumeric(webrtcSettingsSection, this.numericParametersUi.get(_epicgames_ps_lib_pixelstreamingfrontend_ue5_5__WEBPACK_IMPORTED_MODULE_6__.NumericParameters.WebRTCMinBitrate));
            if ((0,_UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.isSettingEnabled)(settingsConfig, _epicgames_ps_lib_pixelstreamingfrontend_ue5_5__WEBPACK_IMPORTED_MODULE_6__.NumericParameters.WebRTCMaxBitrate))
                this.addSettingNumeric(webrtcSettingsSection, this.numericParametersUi.get(_epicgames_ps_lib_pixelstreamingfrontend_ue5_5__WEBPACK_IMPORTED_MODULE_6__.NumericParameters.WebRTCMaxBitrate));
        }
    }
    /**
     * Add a SettingText element to a particular settings section in the DOM and registers that text in the text settings map.
     * @param settingsSection - The settings section HTML element.
     * @param settingText - The textual settings object.
     */
    addSettingText(settingsSection, settingText) {
        if (settingText) {
            settingsSection.appendChild(settingText.rootElement);
            this.textParametersUi.set(settingText.setting.id, settingText);
        }
    }
    /**
     * Add a SettingFlag element to a particular settings section in the DOM and registers that flag in the Config.flag map.
     * @param settingsSection - The settings section HTML element.
     * @param settingFlag - The settings flag object.
     */
    addSettingFlag(settingsSection, settingFlag) {
        if (settingFlag) {
            settingsSection.appendChild(settingFlag.rootElement);
            this.flagsUi.set(settingFlag.setting.id, settingFlag);
        }
    }
    /**
     * Add a numeric setting element to a particular settings section in the DOM and registers that flag in the Config.numericParameters map.
     * @param settingsSection - The settings section HTML element.
     * @param settingFlag - The settings flag object.
     */
    addSettingNumeric(settingsSection, setting) {
        if (setting) {
            settingsSection.appendChild(setting.rootElement);
            this.numericParametersUi.set(setting.setting.id, setting);
        }
    }
    /**
     * Add an enum based settings element to a particular settings section in the DOM and registers that flag in the Config.enumParameters map.
     * @param settingsSection - The settings section HTML element.
     * @param settingFlag - The settings flag object.
     */
    addSettingOption(settingsSection, setting) {
        if (setting) {
            settingsSection.appendChild(setting.rootElement);
            this.optionParametersUi.set(setting.setting.id, setting);
        }
    }
    onSettingsChanged({ data: { id, target, type } }) {
        if (type === 'flag') {
            const _id = id;
            const _target = target;
            const setting = this.flagsUi.get(_id);
            if (setting) {
                if (setting.flag !== _target.flag) {
                    setting.flag = _target.flag;
                }
                if (setting.label !== _target.label) {
                    setting.label = _target.label;
                }
            }
        }
        else if (type === 'number') {
            const _id = id;
            const _target = target;
            const setting = this.numericParametersUi.get(_id);
            if (setting) {
                if (setting.number !== _target.number) {
                    setting.number = _target.number;
                }
                if (setting.label !== _target.label) {
                    setting.label = _target.label;
                }
            }
        }
        else if (type === 'text') {
            const _id = id;
            const _target = target;
            const setting = this.textParametersUi.get(_id);
            if (setting) {
                if (setting.text !== _target.text) {
                    setting.text = _target.text;
                }
                if (setting.label !== _target.label) {
                    setting.label = _target.label;
                }
            }
        }
        else if (type === 'option') {
            const _id = id;
            const _target = target;
            const setting = this.optionParametersUi.get(_id);
            if (setting) {
                const uiOptions = setting.options;
                const targetOptions = _target.options;
                if (uiOptions.length !== targetOptions.length ||
                    !uiOptions.every((value) => targetOptions.includes(value))) {
                    setting.options = _target.options;
                }
                if (setting.selected !== _target.selected) {
                    setting.selected = _target.selected;
                }
                if (setting.label !== _target.label) {
                    setting.label = _target.label;
                }
            }
        }
    }
    /**
     * Add a callback to fire when the flag is toggled.
     * @param id - The id of the flag.
     * @param onChangeListener - The callback to fire when the value changes.
     */
    addCustomFlagOnSettingChangedListener(id, onChangeListener) {
        if (this.customFlags.has(id)) {
            this.customFlags.get(id).onChange = onChangeListener;
        }
    }
    /**
     * Set the label for the flag.
     * @param id - The id of the flag.
     * @param label - The new label to use for the flag.
     */
    setCustomFlagLabel(id, label) {
        if (!this.customFlags.has(id)) {
            _epicgames_ps_lib_pixelstreamingfrontend_ue5_5__WEBPACK_IMPORTED_MODULE_7__.Logger.Warning(`Cannot set label for flag called ${id} - it does not exist in the Config.flags map.`);
        }
        else {
            this.customFlags.get(id).label = label;
            this.flagsUi.get(id).label = label;
        }
    }
    /**
     * Get the value of the configuration flag which has the given id.
     * @param id - The unique id for the flag.
     * @returns True if the flag is enabled.
     */
    isCustomFlagEnabled(id) {
        return this.customFlags.get(id).flag;
    }
    disableSetting(id) {
        var _a, _b, _c, _d;
        if ((0,_epicgames_ps_lib_pixelstreamingfrontend_ue5_5__WEBPACK_IMPORTED_MODULE_6__.isFlagId)(id)) {
            (_a = this.flagsUi.get(id)) === null || _a === void 0 ? void 0 : _a.disable();
        }
        else if ((0,_epicgames_ps_lib_pixelstreamingfrontend_ue5_5__WEBPACK_IMPORTED_MODULE_6__.isNumericId)(id)) {
            (_b = this.numericParametersUi.get(id)) === null || _b === void 0 ? void 0 : _b.disable();
        }
        else if ((0,_epicgames_ps_lib_pixelstreamingfrontend_ue5_5__WEBPACK_IMPORTED_MODULE_6__.isTextId)(id)) {
            (_c = this.textParametersUi.get(id)) === null || _c === void 0 ? void 0 : _c.disable();
        }
        else if ((0,_epicgames_ps_lib_pixelstreamingfrontend_ue5_5__WEBPACK_IMPORTED_MODULE_6__.isOptionId)(id)) {
            (_d = this.optionParametersUi.get(id)) === null || _d === void 0 ? void 0 : _d.disable();
        }
    }
    enableSetting(id) {
        var _a, _b, _c, _d;
        if ((0,_epicgames_ps_lib_pixelstreamingfrontend_ue5_5__WEBPACK_IMPORTED_MODULE_6__.isFlagId)(id)) {
            (_a = this.flagsUi.get(id)) === null || _a === void 0 ? void 0 : _a.enable();
        }
        else if ((0,_epicgames_ps_lib_pixelstreamingfrontend_ue5_5__WEBPACK_IMPORTED_MODULE_6__.isNumericId)(id)) {
            (_b = this.numericParametersUi.get(id)) === null || _b === void 0 ? void 0 : _b.enable();
        }
        else if ((0,_epicgames_ps_lib_pixelstreamingfrontend_ue5_5__WEBPACK_IMPORTED_MODULE_6__.isTextId)(id)) {
            (_c = this.textParametersUi.get(id)) === null || _c === void 0 ? void 0 : _c.enable();
        }
        else if ((0,_epicgames_ps_lib_pixelstreamingfrontend_ue5_5__WEBPACK_IMPORTED_MODULE_6__.isOptionId)(id)) {
            (_d = this.optionParametersUi.get(id)) === null || _d === void 0 ? void 0 : _d.enable();
        }
    }
}
//# sourceMappingURL=ConfigUI.js.map

/***/ }),

/***/ 6564:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SettingUIBase": () => (/* binding */ SettingUIBase)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
/**
 * Base class for a setting that has a text label, an arbitrary setting value it stores, an a HTML element that represents this setting.
 */
class SettingUIBase {
    constructor(setting) {
        this._setting = setting;
    }
    /**
     * @returns The setting component.
     */
    get setting() {
        return this._setting;
    }
    /**
     * @returns Return or creates a HTML element that represents this setting in the DOM.
     */
    get rootElement() {
        if (!this._rootElement) {
            this._rootElement = document.createElement('div');
        }
        return this._rootElement;
    }
}
//# sourceMappingURL=SettingUIBase.js.map

/***/ }),

/***/ 2396:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SettingUIFlag": () => (/* binding */ SettingUIFlag)
/* harmony export */ });
/* harmony import */ var _SettingUIBase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6564);
// Copyright Epic Games, Inc. All Rights Reserved.

class SettingUIFlag extends _SettingUIBase__WEBPACK_IMPORTED_MODULE_0__.SettingUIBase {
    constructor(setting) {
        super(setting);
        this.label = setting.label;
        this.flag = setting.flag;
    }
    /**
     * @returns The setting component.
     */
    get setting() {
        return this._setting;
    }
    get settingsTextElem() {
        if (!this._settingsTextElem) {
            this._settingsTextElem = document.createElement('div');
            this._settingsTextElem.innerText = this.setting._label;
            this._settingsTextElem.title = this.setting.description;
        }
        return this._settingsTextElem;
    }
    get checkbox() {
        if (!this._checkbox) {
            this._checkbox = document.createElement('input');
            this._checkbox.type = 'checkbox';
            // Block keypress/up/down propogation from text field typing going to UE
            this._checkbox.addEventListener('keypress', (event) => {
                event.stopPropagation();
            });
            this._checkbox.addEventListener('keyup', (event) => {
                event.stopPropagation();
            });
            this._checkbox.addEventListener('keydown', (event) => {
                event.stopPropagation();
            });
        }
        return this._checkbox;
    }
    /**
     * @returns Return or creates a HTML element that represents this setting in the DOM.
     */
    get rootElement() {
        if (!this._rootElement) {
            // create root div with "setting" css class
            this._rootElement = document.createElement('div');
            this._rootElement.id = this.setting.id;
            this._rootElement.classList.add('setting');
            // create div element to contain our setting's text
            this._rootElement.appendChild(this.settingsTextElem);
            // create label element to wrap out input type
            const wrapperLabel = document.createElement('label');
            wrapperLabel.classList.add('tgl-switch');
            this._rootElement.appendChild(wrapperLabel);
            // create input type=checkbox
            this.checkbox.title = this.setting.description;
            this.checkbox.classList.add('tgl');
            this.checkbox.classList.add('tgl-flat');
            const slider = document.createElement('div');
            slider.classList.add('tgl-slider');
            wrapperLabel.appendChild(this.checkbox);
            wrapperLabel.appendChild(slider);
            // setup on change from checkbox
            this.checkbox.addEventListener('change', () => {
                if (this.setting.flag !== this.checkbox.checked) {
                    this.setting.flag = this.checkbox.checked;
                    this.setting.updateURLParams();
                }
            });
        }
        return this._rootElement;
    }
    /**
     * Update the setting's stored value.
     * @param inValue - The new value for the setting.
     */
    set flag(inValue) {
        this.checkbox.checked = inValue;
    }
    /**
     * Get value
     */
    get flag() {
        return this.checkbox.checked;
    }
    /**
     * Set the label text for the setting.
     * @param label - setting label.
     */
    set label(inLabel) {
        this.settingsTextElem.innerText = inLabel;
    }
    /**
     * Get label
     */
    get label() {
        return this.settingsTextElem.innerText;
    }
    disable() {
        this.checkbox.disabled = true;
    }
    enable() {
        this.checkbox.disabled = false;
    }
}
//# sourceMappingURL=SettingUIFlag.js.map

/***/ }),

/***/ 768:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SettingUINumber": () => (/* binding */ SettingUINumber)
/* harmony export */ });
/* harmony import */ var _epicgames_ps_lib_pixelstreamingfrontend_ue5_5__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7800);
/* harmony import */ var _SettingUIBase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6564);
// Copyright Epic Games, Inc. All Rights Reserved.


/**
 * A number spinner with a text label beside it.
 */
class SettingUINumber extends _SettingUIBase__WEBPACK_IMPORTED_MODULE_0__.SettingUIBase {
    constructor(setting) {
        super(setting);
        this.label = this.setting.label;
        this.number = this.setting.number;
    }
    /**
     * @returns The setting component.
     */
    get setting() {
        return this._setting;
    }
    get settingsTextElem() {
        if (!this._settingsTextElem) {
            this._settingsTextElem = document.createElement('label');
            this._settingsTextElem.innerText = this.setting.label;
            this._settingsTextElem.title = this.setting.description;
        }
        return this._settingsTextElem;
    }
    /**
     * Get the HTMLInputElement for the button.
     */
    get spinner() {
        if (!this._spinner) {
            this._spinner = document.createElement('input');
            this._spinner.type = 'number';
            if (this.setting.min != null) {
                this._spinner.min = this.setting.min.toString();
            }
            if (this.setting.max != null) {
                this._spinner.max = this.setting.max.toString();
            }
            this._spinner.value = this.setting.number.toString();
            this._spinner.title = this.setting.description;
            this._spinner.classList.add('form-control');
            // Block keypress/up/down propogation from text field typing going to UE
            this.spinner.addEventListener('keypress', (event) => {
                event.stopPropagation();
            });
            this.spinner.addEventListener('keyup', (event) => {
                event.stopPropagation();
            });
            this.spinner.addEventListener('keydown', (event) => {
                event.stopPropagation();
            });
        }
        return this._spinner;
    }
    /**
     * @returns Return or creates a HTML element that represents this setting in the DOM.
     */
    get rootElement() {
        if (!this._rootElement) {
            // create root div with "setting" css class
            this._rootElement = document.createElement('div');
            this._rootElement.classList.add('setting');
            this._rootElement.classList.add('form-group');
            // create div element to contain our setting's text
            this._rootElement.appendChild(this.settingsTextElem);
            // create label element to wrap out input type
            this._rootElement.appendChild(this.spinner);
            // setup onchange
            this.spinner.onchange = (event) => {
                const inputElem = event.target;
                const parsedValue = Number.parseFloat(inputElem.value);
                if (Number.isNaN(parsedValue)) {
                    _epicgames_ps_lib_pixelstreamingfrontend_ue5_5__WEBPACK_IMPORTED_MODULE_1__.Logger.Warning(`Could not parse value change into a valid number - value was ${inputElem.value}, resetting value to ${this.setting.min}`);
                    if (this.setting.number !== this.setting.min) {
                        this.setting.number = this.setting.min;
                    }
                }
                else {
                    if (this.setting.number !== parsedValue) {
                        this.setting.number = parsedValue;
                        this.setting.updateURLParams();
                    }
                }
            };
        }
        return this._rootElement;
    }
    /**
     * Set the number in the spinner (will be clamped within range).
     */
    set number(newNumber) {
        this.spinner.value = this.setting.clamp(newNumber).toString();
    }
    /**
     * Get value
     */
    get number() {
        return +this.spinner.value;
    }
    /**
     * Set the label text for the setting.
     * @param label - setting label.
     */
    set label(inLabel) {
        this.settingsTextElem.innerText = inLabel;
    }
    /**
     * Get label
     */
    get label() {
        return this.settingsTextElem.innerText;
    }
    disable() {
        this.spinner.disabled = true;
    }
    enable() {
        this.spinner.disabled = false;
    }
}
//# sourceMappingURL=SettingUINumber.js.map

/***/ }),

/***/ 6223:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SettingUIOption": () => (/* binding */ SettingUIOption)
/* harmony export */ });
/* harmony import */ var _SettingUIBase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6564);
// Copyright Epic Games, Inc. All Rights Reserved.

class SettingUIOption extends _SettingUIBase__WEBPACK_IMPORTED_MODULE_0__.SettingUIBase {
    constructor(setting) {
        super(setting);
        this.label = this.setting.label;
        this.options = this.setting.options;
        this.selected = this.setting.selected;
    }
    /**
     * @returns The setting component.
     */
    get setting() {
        return this._setting;
    }
    get selector() {
        if (!this._selector) {
            this._selector = document.createElement('select');
            this._selector.classList.add('form-control');
            this._selector.classList.add('settings-option');
        }
        return this._selector;
    }
    get settingsTextElem() {
        if (!this._settingsTextElem) {
            this._settingsTextElem = document.createElement('div');
            this._settingsTextElem.innerText = this.setting.label;
            this._settingsTextElem.title = this.setting.description;
        }
        return this._settingsTextElem;
    }
    /**
     * Set the label text for the setting.
     * @param label - setting label.
     */
    set label(inLabel) {
        this.settingsTextElem.innerText = inLabel;
    }
    /**
     * Get label
     */
    get label() {
        return this.settingsTextElem.innerText;
    }
    /**
     * @returns Return or creates a HTML element that represents this setting in the DOM.
     */
    get rootElement() {
        if (!this._rootElement) {
            // create root div with "setting" css class
            this._rootElement = document.createElement('div');
            this._rootElement.id = this.setting.id;
            this._rootElement.classList.add('setting');
            this._rootElement.classList.add('form-group');
            // create div element to contain our setting's text
            this._rootElement.appendChild(this.settingsTextElem);
            // create label element to wrap out input type
            const wrapperLabel = document.createElement('label');
            this._rootElement.appendChild(wrapperLabel);
            // create select element
            this.selector.title = this.setting.description;
            wrapperLabel.appendChild(this.selector);
            // setup on change from selector
            this.selector.onchange = () => {
                if (this.setting.selected !== this.selector.value) {
                    this.setting.selected = this.selector.value;
                    this.setting.updateURLParams();
                }
            };
            // Block keypress/up/down propogation from text field typing going to UE
            this.selector.addEventListener('keypress', (event) => {
                event.stopPropagation();
            });
            this.selector.addEventListener('keyup', (event) => {
                event.stopPropagation();
            });
            this.selector.addEventListener('keydown', (event) => {
                event.stopPropagation();
            });
        }
        return this._rootElement;
    }
    set options(values) {
        for (let i = this.selector.options.length - 1; i >= 0; i--) {
            this.selector.remove(i);
        }
        values.forEach((value) => {
            const opt = document.createElement('option');
            opt.value = value;
            opt.innerHTML = value;
            this.selector.appendChild(opt);
        });
    }
    get options() {
        return [...this.selector.options].map((o) => o.value);
    }
    set selected(value) {
        // A user may not specify the full possible value so we instead use the closest match.
        // eg ?xxx=H264 would select 'H264 level-asymmetry-allowed=1;packetization-mode=1;profile-level-id=42001f'
        const filteredList = this.options.filter((option) => option.indexOf(value) !== -1);
        if (filteredList.length) {
            this.selector.value = filteredList[0];
        }
    }
    get selected() {
        return this.selector.value;
    }
    disable() {
        this.selector.disabled = true;
    }
    enable() {
        this.selector.disabled = false;
    }
}
//# sourceMappingURL=SettingUIOption.js.map

/***/ }),

/***/ 3652:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SettingUIText": () => (/* binding */ SettingUIText)
/* harmony export */ });
/* harmony import */ var _SettingUIBase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6564);
// Copyright Epic Games, Inc. All Rights Reserved.

class SettingUIText extends _SettingUIBase__WEBPACK_IMPORTED_MODULE_0__.SettingUIBase {
    constructor(setting) {
        super(setting);
        this.label = this.setting.label;
        this.text = this.setting.text;
    }
    /**
     * @returns The setting component.
     */
    get setting() {
        return this._setting;
    }
    get settingsTextElem() {
        if (!this._settingsTextElem) {
            this._settingsTextElem = document.createElement('div');
            this._settingsTextElem.innerText = this.setting.label;
            this._settingsTextElem.title = this.setting.description;
        }
        return this._settingsTextElem;
    }
    get textbox() {
        if (!this._textbox) {
            this._textbox = document.createElement('input');
            this._textbox.classList.add('form-control');
            this._textbox.type = 'textbox';
        }
        return this._textbox;
    }
    /**
     * @returns Return or creates a HTML element that represents this setting in the DOM.
     */
    get rootElement() {
        if (!this._rootElement) {
            // create root div with "setting" css class
            this._rootElement = document.createElement('div');
            this._rootElement.id = this.setting.id;
            this._rootElement.classList.add('setting');
            // create div element to contain our setting's text
            this._rootElement.appendChild(this.settingsTextElem);
            // create label element to wrap out input type
            const wrapperLabel = document.createElement('label');
            this._rootElement.appendChild(wrapperLabel);
            // create input type=checkbox
            this.textbox.title = this.setting.description;
            wrapperLabel.appendChild(this.textbox);
            // setup on change from checkbox
            this.textbox.addEventListener('input', (event) => {
                if (this.setting.text !== this.textbox.value) {
                    this.setting.text = this.textbox.value;
                    this.setting.updateURLParams();
                }
                event.stopPropagation();
            });
            // Block keypress/up/down propogation from text field typing going to UE
            this.textbox.addEventListener('keypress', (event) => {
                event.stopPropagation();
            });
            this.textbox.addEventListener('keyup', (event) => {
                event.stopPropagation();
            });
            this.textbox.addEventListener('keydown', (event) => {
                event.stopPropagation();
            });
        }
        return this._rootElement;
    }
    /**
     * Update the setting's stored value.
     * @param inValue - The new value for the setting.
     */
    set text(inValue) {
        this.textbox.value = inValue;
    }
    /**
     * Get value
     */
    get text() {
        return this.textbox.value;
    }
    /**
     * Set the label text for the setting.
     * @param label - setting label.
     */
    set label(inLabel) {
        this.settingsTextElem.innerText = inLabel;
    }
    /**
     * Get label
     */
    get label() {
        return this.settingsTextElem.innerText;
    }
    disable() {
        this.textbox.disabled = true;
    }
    enable() {
        this.textbox.disabled = false;
    }
}
//# sourceMappingURL=SettingUIText.js.map

/***/ }),

/***/ 7484:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AFKOverlay": () => (/* binding */ AFKOverlay)
/* harmony export */ });
/* harmony import */ var _ActionOverlay__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9202);
// Copyright Epic Games, Inc. All Rights Reserved.

/**
 * Show an overlay for when the session is unattended, it begins a countdown timer, which when elapsed will disconnect the stream.
 */
class AFKOverlay extends _ActionOverlay__WEBPACK_IMPORTED_MODULE_0__.ActionOverlay {
    /**
     * @returns The created root element of this overlay.
     */
    static createRootElement() {
        const afkOverlayHtml = document.createElement('div');
        afkOverlayHtml.id = 'afkOverlay';
        afkOverlayHtml.className = 'clickableState';
        return afkOverlayHtml;
    }
    /**
     * @returns The created content element of this overlay, which contain some text for an afk count down.
     */
    static createContentElement() {
        const afkOverlayHtmlInner = document.createElement('div');
        afkOverlayHtmlInner.id = 'afkOverlayInner';
        afkOverlayHtmlInner.innerHTML =
            '<center>No activity detected<br>Disconnecting in <span id="afkCountDownNumber"></span> seconds<br>Click to continue<br></center>';
        return afkOverlayHtmlInner;
    }
    /**
     * Construct an Afk overlay
     * @param parentElement - the element this overlay will be inserted into
     */
    constructor(rootDiv) {
        super(rootDiv, AFKOverlay.createRootElement(), AFKOverlay.createContentElement());
        this.rootElement.addEventListener('click', () => {
            this.activate();
        });
    }
    /**
     * Update the count down spans number for the overlay
     * @param countdown - the count down number to be inserted into the span for updating
     */
    updateCountdown(countdown) {
        this.textElement.innerHTML = `<center>No activity detected<br>Disconnecting in <span id="afkCountDownNumber">${countdown}</span> seconds<br>Click to continue<br></center>`;
    }
}
//# sourceMappingURL=AFKOverlay.js.map

/***/ }),

/***/ 9202:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ActionOverlay": () => (/* binding */ ActionOverlay)
/* harmony export */ });
/* harmony import */ var _epicgames_ps_lib_pixelstreamingfrontend_ue5_5__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7800);
/* harmony import */ var _BaseOverlay__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3843);
// Copyright Epic Games, Inc. All Rights Reserved.


/**
 * Class for the base action overlay structure
 */
class ActionOverlay extends _BaseOverlay__WEBPACK_IMPORTED_MODULE_0__.OverlayBase {
    /**
     * Construct an action overlay
     * @param rootDiv - the root element this overlay will be inserted into
     * @param rootElement - the root element that is the overlay
     * @param contentElement - an element that contains text for the action overlay
     */
    constructor(rootDiv, rootElement, contentElement) {
        super(rootDiv, rootElement, contentElement);
        this.onActionCallback = () => {
            /* do nothing */ _epicgames_ps_lib_pixelstreamingfrontend_ue5_5__WEBPACK_IMPORTED_MODULE_1__.Logger.Info('Did you forget to set the onAction callback in your overlay?');
        };
    }
    /**
     * Update the text overlays inner text
     * @param text - the update text to be inserted into the overlay
     */
    update(text) {
        if (text != null || text != undefined) {
            this.textElement.innerHTML = text;
        }
    }
    /**
     * Set a method as an event emitter callback
     * @param callBack - the method that is to be called when the event is emitted
     */
    onAction(callBack) {
        this.onActionCallback = callBack;
    }
    /**
     * Activate an event that is attached to the event emitter
     */
    activate() {
        this.onActionCallback();
    }
}
//# sourceMappingURL=ActionOverlay.js.map

/***/ }),

/***/ 3843:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "OverlayBase": () => (/* binding */ OverlayBase)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
/**
 * Class for the base overlay structure
 */
class OverlayBase {
    /**
     * Construct an overlay
     * @param rootDiv - the root element this overlay will be inserted into
     * @param rootElement - the root element that is the overlay
     */
    constructor(rootDiv, rootElement, textElement) {
        this.rootDiv = rootDiv;
        this.rootElement = rootElement;
        this.textElement = textElement;
        this.rootElement.appendChild(this.textElement);
        this.hide();
        this.rootDiv.appendChild(this.rootElement);
    }
    /**
     * Show the overlay
     */
    show() {
        this.rootElement.classList.remove('hiddenState');
    }
    /**
     * Hide the overlay
     */
    hide() {
        this.rootElement.classList.add('hiddenState');
    }
}
//# sourceMappingURL=BaseOverlay.js.map

/***/ }),

/***/ 2256:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ConnectOverlay": () => (/* binding */ ConnectOverlay)
/* harmony export */ });
/* harmony import */ var _ActionOverlay__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9202);
// Copyright Epic Games, Inc. All Rights Reserved.

/**
 * Overlay shown during connection, has a button that can be clicked to initiate a connection.
 */
class ConnectOverlay extends _ActionOverlay__WEBPACK_IMPORTED_MODULE_0__.ActionOverlay {
    /**
     * @returns The created root element of this overlay.
     */
    static createRootElement() {
        const connectElem = document.createElement('div');
        connectElem.id = 'connectOverlay';
        connectElem.className = 'clickableState';
        return connectElem;
    }
    /**
     * @returns The created content element of this overlay, which contain whatever content this element contains, like text or a button.
     */
    static createContentElement() {
        const connectContentElem = document.createElement('div');
        connectContentElem.id = 'connectButton';
        connectContentElem.innerHTML = 'Click to start';
        return connectContentElem;
    }
    /**
     * Construct a connect overlay with a connection button.
     * @param parentElem - the parent element this overlay will be inserted into.
     */
    constructor(parentElem) {
        super(parentElem, ConnectOverlay.createRootElement(), ConnectOverlay.createContentElement());
        // add the new event listener
        this.rootElement.addEventListener('click', () => {
            this.activate();
        });
    }
}
//# sourceMappingURL=ConnectOverlay.js.map

/***/ }),

/***/ 3825:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DisconnectOverlay": () => (/* binding */ DisconnectOverlay)
/* harmony export */ });
/* harmony import */ var _ActionOverlay__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9202);
// Copyright Epic Games, Inc. All Rights Reserved.

/**
 * Overlay shown during disconnection, has a reconnection element that can be clicked to reconnect.
 */
class DisconnectOverlay extends _ActionOverlay__WEBPACK_IMPORTED_MODULE_0__.ActionOverlay {
    /**
     * @returns The created root element of this overlay.
     */
    static createRootElement() {
        const disconnectOverlayHtml = document.createElement('div');
        disconnectOverlayHtml.id = 'disconnectOverlay';
        disconnectOverlayHtml.className = 'clickableState';
        return disconnectOverlayHtml;
    }
    /**
     * @returns The created content element of this overlay, which contain whatever content this element contains, like text or a button.
     */
    static createContentElement() {
        // build the inner html container
        const disconnectOverlayHtmlContainer = document.createElement('div');
        disconnectOverlayHtmlContainer.id = 'disconnectButton';
        disconnectOverlayHtmlContainer.innerHTML = 'Click To Restart';
        return disconnectOverlayHtmlContainer;
    }
    /**
     * Construct a disconnect overlay with a retry connection icon.
     * @param parentElem - the parent element this overlay will be inserted into.
     */
    constructor(parentElem) {
        super(parentElem, DisconnectOverlay.createRootElement(), DisconnectOverlay.createContentElement());
        // add the new event listener
        this.rootElement.addEventListener('click', () => {
            this.activate();
        });
    }
}
//# sourceMappingURL=DisconnectOverlay.js.map

/***/ }),

/***/ 3089:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ErrorOverlay": () => (/* binding */ ErrorOverlay)
/* harmony export */ });
/* harmony import */ var _TextOverlay__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8714);
// Copyright Epic Games, Inc. All Rights Reserved.

/**
 * Generic overlay used to show textual error info to the user.
 */
class ErrorOverlay extends _TextOverlay__WEBPACK_IMPORTED_MODULE_0__.TextOverlay {
    /**
     * @returns The created root element of this overlay.
     */
    static createRootElement() {
        const errorOverlayHtml = document.createElement('div');
        errorOverlayHtml.id = 'errorOverlay';
        errorOverlayHtml.className = 'textDisplayState';
        return errorOverlayHtml;
    }
    /**
     * @returns The created content element of this overlay, which contain whatever content this element contains, like text or a button.
     */
    static createContentElement() {
        const errorOverlayHtmlInner = document.createElement('div');
        errorOverlayHtmlInner.id = 'errorOverlayInner';
        return errorOverlayHtmlInner;
    }
    /**
     * Construct a connect overlay with a connection button.
     * @param parentElem - the parent element this overlay will be inserted into.
     */
    constructor(parentElem) {
        super(parentElem, ErrorOverlay.createRootElement(), ErrorOverlay.createContentElement());
    }
}
//# sourceMappingURL=ErrorOverlay.js.map

/***/ }),

/***/ 3912:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "InfoOverlay": () => (/* binding */ InfoOverlay)
/* harmony export */ });
/* harmony import */ var _TextOverlay__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8714);
// Copyright Epic Games, Inc. All Rights Reserved.

/**
 * Generic overlay used to show textual info to the user.
 */
class InfoOverlay extends _TextOverlay__WEBPACK_IMPORTED_MODULE_0__.TextOverlay {
    /**
     * @returns The created root element of this overlay.
     */
    static createRootElement() {
        const infoOverlayHtml = document.createElement('div');
        infoOverlayHtml.id = 'infoOverlay';
        infoOverlayHtml.className = 'textDisplayState';
        return infoOverlayHtml;
    }
    /**
     * @returns The created content element of this overlay, which contain whatever content this element contains, like text or a button.
     */
    static createContentElement() {
        const infoOverlayHtmlInner = document.createElement('div');
        infoOverlayHtmlInner.id = 'messageOverlayInner';
        return infoOverlayHtmlInner;
    }
    /**
     * Construct a connect overlay with a connection button.
     * @param parentElem - the parent element this overlay will be inserted into.
     */
    constructor(parentElem) {
        super(parentElem, InfoOverlay.createRootElement(), InfoOverlay.createContentElement());
    }
}
//# sourceMappingURL=InfoOverlay.js.map

/***/ }),

/***/ 2475:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PlayOverlay": () => (/* binding */ PlayOverlay)
/* harmony export */ });
/* harmony import */ var _ActionOverlay__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9202);
// Copyright Epic Games, Inc. All Rights Reserved.

/**
 * Overlay shown when stream is ready to play.
 */
class PlayOverlay extends _ActionOverlay__WEBPACK_IMPORTED_MODULE_0__.ActionOverlay {
    /**
     * @returns The created root element of this overlay.
     */
    static createRootElement() {
        const playElem = document.createElement('div');
        playElem.id = 'playOverlay';
        playElem.className = 'clickableState';
        return playElem;
    }
    /**
     * @returns The created content element of this overlay, which contain whatever content this element contains, like text or a button.
     */
    static createContentElement() {
        // todo: change this to an svg
        const playOverlayHtmlInner = document.createElement('img');
        playOverlayHtmlInner.id = 'playButton';
        playOverlayHtmlInner.src =
            'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAPEAAAD5CAYAAAD2mNNkAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAZdEVYdFNvZnR3YXJlAHBhaW50Lm5ldCA0LjAuMjHxIGmVAAASgklEQVR4Xu2dC7BdVX2HqUCCIRASCPjAFIQREBRBBSRYbFOt8lIrFUWRFqXWsT5wbItUqFWs0KqIMPKoYEWpRS06KDjS1BeVFkVQbCw+wCfiAwGhCKWP9PuZtU24uTe59zz22Y/vm/nGkXtz7jlrr9+sdfZea/03Wb169QtxGW62iYi0D8L7NbwYj8EdcdPyIxFpA4T2P/F/8Ua8CI/GhPnXyq+ISJMhrAlxxX9hRuYL8Sh8SPk1EWkqBHXdEFfcg6vw3fhs3Kb8uog0DQI6XYgr8rOvYsJ8OM4v/0xEmkIJ6ob4P8zIfANegCvQMIs0BQK5sRBXJMy/wIzM5+ByXFBeRkQmBUGcbYjX5S5MmM/AA3CL8nIiUjcEcJAQV9yBX8a/wSeiz5hF6obgDRPikGfMCfOX8DTcu7y0iNQBoRs2xBX/g3diwvwm3Kn8CREZJ4RtVCGuqMKcu9kn4xJ09ZfIuCBgow5xyJ3sTLNzAywrwF6J26NhFhk1BGscIV6XhPluvA6Pxx3KnxaRUUCoxh3iioQ5z5n/BY/FJeUtiMgwEKa6QlyRMN+Hn8Hn4ZblrYjIIBCiukMc8p25Ws6ZMD+zvB0RmSsEaBIhnkrew5V4EHrCiMhcKAFqCv+Nl+J+uBC9my2yMQhKk0Jcke/M78Gsy06YH1TerohMhYA0McQVP8Nz8UDcCl2bLTIVgtHkEFd8D8/E/XFrdGQWqSAQbQhxyKOpm/B03Ac9MkgkEIa2hLgiN78S5lPx0bgIvQEm/YUAtC3EFQnzzfgnuDc6zZZ+Qsdva4jX5Sv4atwXHZmlX9DhuxDikC2Qn8dXYUbmReUjinQbOntXQlyRTRafwldgwrxV+agi3YRO3rUQV/wcV+LL8DHoyZzSTejcXQ1xRc7/uhyzl3kv3Lx8dJFuQKfueohDnjFnZP4o/j7m0ZQH4Es3oDP3IcQV2f6YMF+COZjgUeiZ2dJu6MR9CvG63ILvx4zMCfO80iQi7YLO29cQV3wb34spsr4rumBE2gWdtu8hDln99S1MXeYX4M6leUSaDx3WEK8lRdYT5lR/zPlfnswpzYeOaojXJ4cSfB3Pw+fgtug0W5oJndMQT0/uZGeaXZVyfTZuV5pNpDnQMQ3xxsk0O9Ufz8ZDcdvSfCKThw5piGdP2ioF496JT0c3WcjkKR1T5kYWjCTM78DfQheMyOSgAxriwch35lR/vAbPwOXozS+pHzqeIR6Oal12wvx2fBy6yULqgw5niEdDwpyR+VpMkfXsmHIpp4wfOpohHj234RfwFNwDnWbL+KCDGeLxkJH5p3g1vg53K00uMlroXIZ4vGTBSMJ8FeZkzmWl6UVGA53KENfD/ZiyNCmynvO/FpdLIDIcdCZDXC8ZmfOd+d/wJejZXzIcdCJDXD95xpwjdnP+V74zH4Wu/pLBoPMY4smSMN+FKbJ+BBpmmRt0GkPcDBLmu/FjeAi6lFNmB53FEDeHTLPzaCoj80dwBfqMWTYMncQQN5esAPsw7lcul8j60EEMcfPJDbD3YU7l3KxcOpE10CkMcTvIVDvfmc/E3XELtPqjGOKWkhVgp+GemDD7vbnP0AEMcXtJkfU34GNxAToy9xEuvCFuP6vwJMyOqYXl0kpf4KIb4m5QncyZTRapZGGY+wIX2xB3i3vxOswmi13QaXbX4QIb4m6SY3a/iMdh7mYb5q7ChTXE3aXaaLESq7rMW5ZLL12Bi2qI+8E9eDkmzLuhYe4KXExD3B8yMt+Ol+KL0CLrXYCLaIj7R8J8K16CR6PLOdsMF88Q95fsmPoRXozPxdzNdvVX2+CiGWLJza+EOXWZj8Sd0APw2wIXyxBLqPYy34LnY8K8DA1z0+EiGWKZSgJ9I74LU2R9R3Sa3VS4OIZYZqJaynkWpsj6w0u3kSbBhTHEsjHuwxswpVwPw6Wl+0gT4IIYYpkNmWKnr1yPqf54KG5VupFMknJhRGZLwpzVX6n++DZ8GrpjapJwAQyxDELCnB1TqWTx1/gUdGSeBDS8IZZBSZBjzv76PP4VHoSGuU5ocEMsoyBhTsG4VH98Ix6A80s3k3FCQxtiGSVZMPIT/CwmzPuhz5jHCQ1siGUcZClnwvxpPAX3LF1ORg2Na4hlXGSKnQUjCfNn8PX4CNy0dD8ZBTSoIZZxkzBXI/Pn8ATMumzDPApoSEMsdZEw5zvzDzHT7JdjwuzZX8NAAxpimQSZZifMn8Tj8aGlS8pcofEMsUyKjMw5lTOnjHwcc2TQktI1ZbbQaIZYJk3CnE0WGZmvwOeh+5hnC41liKUpVCNzwvwJPBy9+bUxaCRDLE0jYb4fU/0x0+yD8cGly8pUaBxDLE0kQa7CfCfmML8D0SN2p0KjGGJpOglztWgkh/k9CT1it4LGMMTSFhLmLBrJ3exzcJ/SjfsNDWGIpY0k0D/AM/GRpTv3ExrAEEubqVaAnY5LsX93s/nQhli6QLUF8nWYI3bnYT+Wc/JBDbF0heqO9jfwlfhInI/dDjMf0BBLF0mYr8NsskiNqS2wm2Hmgxli6TJ5zpwjg/4Qd8buLRrhQxli6QM5ZjdHBh2H+c7cnUUjfBhDLH0hU+y7cCU+H7OXeV6JQnvhQxhi6RsJc0bmy/BZ+MsbYCUS7YM3b4ilryTM2QL5QUzBuHxnbt80mzdtiEVWr74NL8KUck2R9faMzLxZQyyyhozMWcp5If4uJszNP5yAN2mIRR5IVn/djOfhEdjsw/x4c4ZYZHryjPkmPBsPwYeV2DQL3pghFpmZTLFzZFDCnLrMz8DtsTkbLXgzhlhk4yTM2cu8CrNjKiNzwjz5OlO8CUMsMjcS5qzLfgumyPr2JU6TgTdgiEUGoyqynrrMv42TOTObP2yIRQYn0+ws5bwaU8r1N3HrEq964A8aYpHhSZjvwBSMS5gPwnrWZfOHDLHI6Mgz5hyxm4Jxf4kH4HjDzB8wxCKjJ2HONPuf8c9xHxzPXmZe2BCLjIdMsWMqWfwTnoiPwdGOzLygIRYZPwlzVWPqtbgXjmbBCC9kiEXqI8+Ys8nicnwN7laiODi8iCEWqZeMylmXnTCnYFxO5tyxRHLu8I8NschkSJizLvv7mJH5pbgY57Zjin9giEUmSzUyfw9TZP1Y3LZEdOPwy4ZYpBkkzKn++B38KB6F25Wozgy/ZIhFmkXCnLO/vosfwpwysqhEdn34oSEWaSYJ8y8w0+wP4GG4/oIR/qMhFmk2VZgzzU6Ys2Nq7T5m/o8hFmkHCXO2PybMF+O++CBDLNIuEuSsy8535lvxZEMs0j6qWszZJbXUEIu0i1vwrZhqFZv5nVikPWTqfA5mF9QDD+fjPxhikeaR777xdrwAn1Aiuz780BCLNIvsdMqBAqkNtRw3XBeKXzDEIpMno27Cezdeik/GBSWmG4ZfNMQikyPhzXrpVGXM6R8rcG7lVfkHhlikfhLe7FzKo6KV+Hu45m7zXOEfGmKReske4oT3k3gMblniOBi8gCEWqYeMvD/GK/F43KHEcDh4IUMsMl5yw+pHmLOoX4aDH8UzHbygIRYZD/nem5H3KjwBd8LRV1HkRQ2xyGjJ3eacNZ1iayfhr+P46hnz4oZYZDRk2pzwph7TX+CuOP76xfwRQywyHNlVVIX3VHx8iVc98AcNscjgZJFGypq+GffHwZ71DgN/1BCLzJ2f47/iWzBlTId71jsM/HFDLDI7crf5HrwG34YHY70FxaeDN2GIRTZMwpvjcK7Fd+BTcfLhreDNGGKRmcnIez2+Ew/FhTi3MivjhjdkiEXWJ0fEfhXPwmfi4hKZ5sGbM8Qia8n65lX4LkzlhYeVqDQX3qQhFlnzrPc/8FzMtsBl2Kxp80zwRg2x9J0cxn4epoBZlkjW/6x3GHjDhlj6SJZI5gTJ9+DzMeHdvMSiXfDGDbH0iWpbYMqgJLy7YLtG3qnwAQyx9IVsC7wEX4C74/h2FtUJH8QQS9fJUTg5QfI43APnle7fDfhAhli6So5//Ri+GBPeya1vHid8MEMsXSMH0X0CX4J74cLS3bsJH9AQS1fITavs6f1VeLEdz3qHgQ9piKXtZHNC1jfnELpfTpux++Gt4MMaYmkrmTZ/GV+LCW+3p80zwQc3xNI2skTyBswhdHtic7YFTgIawBBLm7gRT8HH4dbYn2nzTNAIhljaQCrkvwkT3tywGv8pkm2BxjDE0lRyokbOsjoDUyE/N6wM71RoFEMsTSPhvRPfjY/GBei0eSZoHEMsTeJ2/ADug+3cVVQ3NJQhliaQkfcf8SnoqDsXaDBDLJMij4ruxcvwaejIOwg0nCGWusnyyIT3CjwM+7lIY1TQgIZY6iA3qzLyZmdRSn0eic09QbJN0JCGWMZJwpuR9w78Er4Qu7klcFLQoIZYxkXq9OZuc2oWZXNCv5dHjgsa1hDLqKnCm2qB2Zzw0NLdZBzQwIZYRkWmzT/DhPdE3KV0MxknNLQhlmHJ996ENwXHsjkhq6xcHlkXNLYhlkFJeHPDKhvyszkh4W338a9thEY3xDJX8qgoGxMS3tTpfSzOL11K6obGN8QyWxLeLI/MtDmlPvdHp82ThotgiGU2ZOStwrsCXSLZFLgYhlg2xF2Yc6zOxqejCzWaBhfFEMt0pMj2VzB1eg/BJaXLSNPg4hhiqcjd5izUSIX8lPp8Fi4tXUWaChfJEEtIhfwU2b4QU2R7O3RfbxvgQhnifpOD17+JCW9KfS5F7zi3CS6YIe4nOXj9W/h3eAw+vHQJaRtcPEPcL/Ks92a8CI/FXdFpc5vhAhri/vB9/Hv8A3wUukSyC3AhDXH3+Sn+Ax6PqZDvEskuwQU1xN2kOgonJ0im1Gc2J2xRLrt0CS6sIe4W1c6ij2NG3lROmFcut3QRLrAh7g4J75X4R7g3Gt4+wIU2xO0n0+ZP4aswBcdc39wnuOCGuL3kWe/n8DW4Ly4ql1X6BBfeELeTL+AJ+ATcBn3W21e4+Ia4PeSO89fwT/GJuAhdItl36ASGuPlkZ9G38fWYo3Ay8hpeWQOdwRA3lxwBexO+GVPq07Insj50DEPcTLK++e2Yc6wWo995ZXroHIa4WdyKOQpnOWbavGm5VCLTQycxxM0gp0iej0/G3LAyvDI76CyGeHJUx+G8Hw9Ewytzh05jiCdDDqK7HA/Aheh3XhkMOo8hrpe096fxd9D9vDI8pVPJ+LkXP4vPQafMMjroUIZ4fOQ7b9Y3X4U5x8oi2zJ66FiGePRkeWROkfwiHoee3Szjgw5miEdDRt14D+bw9ZfjDqWZRcYHHc0QD091FE6OgP0z9OB1qQ86myEenKxtTngz8r4BHXmlfuh4hnjuJLwp9Zlqgafh7qU5ReqHDmiIZ0+mzVkeeQO+FR9fmlFkctARDfHsSJ3ef8dqZ5GH0EkzoDMa4pnJ3ea0T07TOAezvnlBaTqRZlA6qTyQhDdrm1fhBXgwGl5pJnROQ7yW6jlvwvtefAZuXppKpJmUTitrp80p9Zn1zQ8uTSTSbOisfQ9xps2pkJ/wPhe3K00j0g7otH0N8f34dXwfHo0W2ZZ2QuftY4izPDKnabwIH4Ee/yrthQ7clxBnldUP8BJ8MSa87uuV9kNH7nqIc4ZVwvshfCkuQ8Mr3YEO3dUQZ4nkD/HDmFKfe5SPLNIt6NxdDHHC+xF8BabsiSOvdBc6eJdCfBtehglvimz7rFe6Dx29CyHOQo0r8NWYOr0W2Zb+QIdva4izRDLPeldi6vSm1OfC8rFE+gMdv40hznu+GlMhfz/cEj0OR/oJnb9NIc57vQZPxCehI69ICUbTydnN1+LJmPAuKW9fRAhEk0OcZ73XYw6hOwg9v1lkKgSjqSHO5oRT8TdwKbq+WWQ6CEeTQpw7zlmocTqmTm/Ob7bomMiGICRNCHGmzT/BszClPjPyuspKZDYQlkmH+Mf4t7gct0enzSJzgdBMKsQJ70X4VHTkFRkUwlN3iFM54YN4KG6LHkQnMgyEqK4Q51nvpZjwZuQ1vCKjgDDVEeIr8XBMeL3bLDJKCNW4QpyR9zo8ArdBb1iJjAPCNeoQJ7ypFngszkc3JoiME0I2qhDnWW8Kjv0xujFBpC4I3DAhzgqrHESXUp/Z0/uQ8rIiUhcEb5AQJ7z34TfwJNy5vJyI1A0BnG2IE9yYsiffwTfizuh3XpFJQghnE+J83014v4upkL8r+qhIpAkQxg2FOOHNzzNtPhf3REdekSZRQjqVTJtzguSNeD4eWH5dRJoGAZ0a4rvxm3ghrkCnzSJNhpBWIc7/plpgwpudRZ7dLNIGCOvtJbwX42G4uPxIRNoAoU2d3iNxUflPItIaNtnk/wEGBoMdpECGHAAAAABJRU5ErkJggg==';
        playOverlayHtmlInner.alt = 'Start Streaming';
        return playOverlayHtmlInner;
    }
    /**
     * Construct a connect overlay with a connection button.
     * @param parentElem - the parent element this overlay will be inserted into.
     */
    constructor(parentElem) {
        super(parentElem, PlayOverlay.createRootElement(), PlayOverlay.createContentElement());
        // add the new event listener
        this.rootElement.addEventListener('click', () => {
            this.activate();
        });
    }
}
//# sourceMappingURL=PlayOverlay.js.map

/***/ }),

/***/ 8714:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TextOverlay": () => (/* binding */ TextOverlay)
/* harmony export */ });
/* harmony import */ var _BaseOverlay__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3843);
// Copyright Epic Games, Inc. All Rights Reserved.

/**
 * Class for the text overlay base
 */
class TextOverlay extends _BaseOverlay__WEBPACK_IMPORTED_MODULE_0__.OverlayBase {
    /**
     * Construct a text overlay
     * @param rootDiv - the root element this overlay will be inserted into
     * @param rootElement - the root element that is the overlay
     * @param textElement - an element that contains text for the action overlay
     */
    constructor(rootDiv, rootElement, textElement) {
        super(rootDiv, rootElement, textElement);
    }
    /**
     * Update the text overlays inner text
     * @param text - the update text to be inserted into the overlay
     */
    update(text) {
        if (text != null || text != undefined) {
            this.textElement.innerHTML = text;
        }
    }
}
//# sourceMappingURL=TextOverlay.js.map

/***/ }),

/***/ 3579:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PixelStreamingApplicationStyle": () => (/* binding */ PixelStreamingApplicationStyle)
/* harmony export */ });
/* harmony import */ var jss__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(4013);
/* harmony import */ var jss_plugin_global__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5019);
/* harmony import */ var jss_plugin_camel_case__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(314);
/* Copyright Epic Games, Inc. All Rights Reserved. */



class PixelStreamingApplicationStyle {
    constructor(options) {
        this.defaultLightModePalette = {
            '--color0': '#e2e0dd80',
            '--color1': '#FFFFFF',
            '--color2': '#000000',
            '--color3': '#0585fe',
            '--color4': '#35b350',
            '--color5': '#ffab00',
            '--color6': '#e1e2dd',
            '--color7': '#c3c4bf'
        };
        this.defaultDarkModePalette = {
            '--color0': '#1d1f22e0',
            '--color1': '#000000',
            '--color2': '#FFFFFF',
            '--color3': '#0585fe',
            '--color4': '#35b350',
            '--color5': '#ffab00',
            '--color6': '#1e1d22',
            '--color7': '#3c3b40'
        };
        this.defaultStyles = {
            ':root': {
                '--color0': '#1d1f22e0',
                '--color1': '#000000',
                '--color2': '#FFFFFF',
                '--color3': '#0585fe',
                '--color4': '#35b350',
                '--color5': '#ffab00',
                '--color6': '#1e1d22',
                '--color7': '#3c3b40',
                '--color8': '#41008c',
                '--color9': '#3e0070',
                '--color10': '#2e0052',
                '--color11': 'rgba(65,0,139,1)'
            },
            '.noselect': {
                userSelect: 'none'
            },
            '#playerUI': {
                width: '100%',
                height: '100%',
                position: 'relative'
            },
            '#videoElementParent': {
                width: '100%',
                height: '100%',
                position: 'absolute',
                backgroundColor: 'var(--color1)'
            },
            '#uiFeatures': {
                width: '100%',
                height: '100%',
                zIndex: '30',
                position: 'relative',
                color: 'var(--color2)',
                pointerEvents: 'none',
                overflow: 'hidden'
            },
            '.UiTool .tooltiptext': {
                visibility: 'hidden',
                width: 'auto',
                color: 'var(--color2)',
                textAlign: 'center',
                borderRadius: '15px',
                padding: '0px 10px',
                fontFamily: "'Montserrat', sans-serif",
                fontSize: '0.75rem',
                letterSpacing: '0.75px',
                position: 'absolute',
                top: '0',
                transform: 'translateY(25%)',
                left: '125%',
                zIndex: '20'
            },
            '.UiTool:hover .tooltiptext': {
                visibility: 'visible',
                backgroundColor: 'var(--color7)'
            },
            '#connection .tooltiptext': {
                top: '125%',
                transform: 'translateX(-25%)',
                left: '0',
                zIndex: '20',
                padding: '5px 10px'
            },
            '#connection': {
                position: 'absolute',
                bottom: '8%',
                left: '5%',
                fontFamily: "'Michroma', sans-serif",
                height: '3rem',
                width: '3rem',
                pointerEvents: 'all'
            },
            '#settings-panel .tooltiptext': {
                display: 'block',
                top: '125%',
                transform: 'translateX(-50%)',
                left: '0',
                zIndex: '20',
                padding: '5px 10px',
                border: '3px solid var(--color3)',
                width: 'max-content',
                fallbacks: [
                    {
                        width: 'max-content'
                    },
                    {
                        border: '3px solid var(--color3)'
                    },
                    {
                        padding: '5px 10px'
                    },
                    {
                        zIndex: '20'
                    },
                    {
                        left: '0'
                    },
                    {
                        transform: 'translateX(-50%)'
                    },
                    {
                        top: '125%'
                    },
                    {
                        display: 'block'
                    }
                ]
            },
            '#controls': {
                position: 'absolute',
                top: '3%',
                left: '2%',
                fontFamily: "'Michroma', sans-serif",
                pointerEvents: 'all',
                display: 'block'
            },
            '#controls>*': {
                marginBottom: '0.5rem',
                borderRadius: '50%',
                display: 'block',
                height: '2rem',
                lineHeight: '1.75rem',
                padding: '0.5rem'
            },
            '#controls #additionalinfo': {
                textAlign: 'center',
                fontFamily: "'Montserrat', sans-serif"
            },
            '#fullscreen-btn': {
                padding: '0.6rem !important'
            },
            '#minimizeIcon': {
                display: 'none'
            },
            '#settingsBtn, #statsBtn': {
                cursor: 'pointer'
            },
            '#uiFeatures button': {
                backgroundColor: 'var(--color7)',
                border: '1px solid var(--color7)',
                color: 'var(--color2)',
                position: 'relative',
                width: '3rem',
                height: '3rem',
                padding: '0.5rem',
                textAlign: 'center'
            },
            '#uiFeatures button:hover': {
                backgroundColor: 'var(--color3)',
                border: '3px solid var(--color3)',
                transition: '0.25s ease',
                paddingLeft: '0.55rem',
                paddingTop: '0.55rem'
            },
            '#uiFeatures button:active': {
                border: '3px solid var(--color3)',
                backgroundColor: 'var(--color7)',
                paddingLeft: '0.55rem',
                paddingTop: '0.55rem'
            },
            '.btn-flat': {
                backgroundColor: 'transparent',
                color: 'var(--color2)',
                fontFamily: "'Montserrat'",
                fontWeight: 'bold',
                border: '3px solid var(--color3)',
                borderRadius: '1rem',
                fontSize: '0.75rem',
                paddingLeft: '0.5rem',
                paddingRight: '0.5rem',
                cursor: 'pointer',
                textAlign: 'center'
            },
            '.btn-flat:hover': {
                backgroundColor: 'var(--color3)',
                transition: 'ease 0.3s'
            },
            '.btn-flat:disabled': {
                background: 'var(--color7)',
                borderColor: 'var(--color3)',
                color: 'var(--color3)',
                cursor: 'default'
            },
            '.btn-flat:active': {
                backgroundColor: 'transparent'
            },
            '.btn-flat:focus': {
                outline: 'none'
            },
            '#uiFeatures img': {
                width: '100%',
                height: '100%'
            },
            '.panel-wrap': {
                position: 'absolute',
                top: '0',
                bottom: '0',
                right: '0',
                height: '100%',
                minWidth: '20vw',
                maxWidth: '90vw',
                transform: 'translateX(100%)',
                transition: '.3s ease-out',
                pointerEvents: 'all',
                overflowY: 'auto',
                overflowX: 'hidden',
                backgroundColor: 'var(--color0)'
            },
            '.panel-wrap-visible': {
                transform: 'translateX(0%)'
            },
            '.panel': {
                overflowY: 'auto',
                padding: '1em'
            },
            '#settingsHeading, #statsHeading': {
                display: 'inline-block',
                fontSize: '2em',
                marginBlockStart: '0.67em',
                marginBlockEnd: '0.67em',
                marginInlineStart: '0px',
                marginInlineEnd: '0px',
                position: 'relative',
                padding: '0 0 0 2rem'
            },
            '#settingsClose, #statsClose': {
                margin: '0.5rem',
                paddingTop: '0.5rem',
                paddingBottom: '0.5rem',
                paddingRight: '0.5rem',
                fontSize: '2em',
                float: 'right'
            },
            '#settingsClose:after, #statsClose:after': {
                paddingLeft: '0.5rem',
                display: 'inline-block',
                content: '"\\00d7"'
            },
            '#settingsClose:hover, #statsClose:hover': {
                color: 'var(--color3)',
                transition: 'ease 0.3s'
            },
            '#settingsContent, #statsContent': {
                marginLeft: '2rem',
                marginRight: '2rem'
            },
            '.setting': {
                display: 'flex',
                flexDirection: 'row',
                justifyContent: 'space-between',
                padding: '0.15rem 10px 0.15rem 10px'
            },
            '.settings-text': {
                color: 'var(--color2)',
                verticalAlign: 'middle',
                fontWeight: 'normal'
            },
            '.settings-option': {
                width: '100%',
                textOverflow: 'ellipsis',
                whiteSpace: 'nowrap'
            },
            '#connectOverlay, #playOverlay, #infoOverlay, #errorOverlay, #afkOverlay, #disconnectOverlay': {
                zIndex: '30',
                position: 'absolute',
                color: 'var(--color2)',
                fontSize: '1.8em',
                width: '100%',
                height: '100%',
                backgroundColor: 'var(--color1)',
                alignItems: 'center',
                justifyContent: 'center',
                textTransform: 'uppercase'
            },
            '.clickableState': {
                alignItems: 'center',
                justifyContent: 'center',
                display: 'flex',
                cursor: 'pointer'
            },
            '.textDisplayState': {
                display: 'flex'
            },
            '.hiddenState': {
                display: 'none'
            },
            '#playButton, #connectButton': {
                display: 'inline-block',
                height: 'auto',
                zIndex: '30'
            },
            'img#playButton': {
                maxWidth: '241px',
                width: '10%'
            },
            '#uiInteraction': {
                position: 'fixed'
            },
            '#UIInteractionButtonBoundary': {
                padding: '2px'
            },
            '#UIInteractionButton': {
                cursor: 'pointer'
            },
            '.btn-overlay': {
                verticalAlign: 'middle',
                display: 'inline-block'
            },
            '.tgl-switch': {
                verticalAlign: 'middle',
                display: 'inline-block'
            },
            '.tgl-switch .tgl': {
                display: 'none'
            },
            '.tgl, .tgl:after, .tgl:before, .tgl *, .tgl *:after, .tgl *:before, .tgl+.tgl-slider': {
                '-webkit-box-sizing': 'border-box',
                boxSizing: 'border-box'
            },
            '.tgl::-moz-selection, .tgl:after::-moz-selection, .tgl:before::-moz-selection, .tgl *::-moz-selection, .tgl *:after::-moz-selection, .tgl *:before::-moz-selection, .tgl+.tgl-slider::-moz-selection': {
                background: 'none'
            },
            '.tgl::selection, .tgl:after::selection, .tgl:before::selection, .tgl *::selection, .tgl *:after::selection, .tgl *:before::selection, .tgl+.tgl-slider::selection': {
                background: 'none'
            },
            '.tgl-slider': {},
            '.tgl+.tgl-slider': {
                outline: '0',
                display: 'block',
                width: '40px',
                height: '18px',
                position: 'relative',
                cursor: 'pointer',
                userSelect: 'none'
            },
            '.tgl+.tgl-slider:after, .tgl+.tgl-slider:before': {
                position: 'relative',
                display: 'block',
                content: '""',
                width: '50%',
                height: '100%'
            },
            '.tgl+.tgl-slider:after': {
                left: '0'
            },
            '.tgl+.tgl-slider:before': {
                display: 'none'
            },
            '.tgl-flat+.tgl-slider': {
                padding: '2px',
                '-webkit-transition': 'all .2s ease',
                transition: 'all .2s ease',
                background: 'var(--color6)',
                border: '3px solid var(--color7)',
                borderRadius: '2em'
            },
            '.tgl-flat+.tgl-slider:after': {
                '-webkit-transition': 'all .2s ease',
                transition: 'all .2s ease',
                background: 'var(--color7)',
                content: '""',
                borderRadius: '1em'
            },
            '.tgl-flat:checked+.tgl-slider': {
                border: '3px solid var(--color3)'
            },
            '.tgl-flat:checked+.tgl-slider:after': {
                left: '50%',
                background: 'var(--color3)'
            },
            '.btn-apply': {
                display: 'block !important',
                marginLeft: 'auto',
                marginRight: 'auto',
                width: '40%'
            },
            '.form-control': {
                backgroundColor: 'var(--color7)',
                border: '2px solid var(--color7)',
                borderRadius: '4px',
                color: 'var(--color2)',
                textAlign: 'right',
                fontFamily: 'inherit'
            },
            '.form-control:hover': {
                borderColor: 'var(--color7)'
            },
            '.form-group': {
                paddingTop: '4px',
                display: 'grid',
                gridTemplateColumns: '80% 20%',
                rowGap: '4px',
                paddingRight: '10px',
                paddingLeft: '10px'
            },
            '.form-group label': {
                verticalAlign: 'middle',
                fontWeight: 'normal'
            },
            '.settingsContainer': {
                display: 'flex',
                flexDirection: 'column',
                borderBottom: '1px solid var(--color7)',
                paddingTop: '10px',
                paddingBottom: '10px'
            },
            '.settingsContainer> :first-child': {
                marginTop: '4px',
                marginBottom: '4px',
                fontWeight: 'bold',
                justifyContent: 'space-between',
                display: 'flex',
                flexDirection: 'row',
                alignItems: 'baseline'
            },
            '.collapse': {
                paddingLeft: '5%'
            },
            '#streamTools': {
                borderBottomRightRadius: '5px',
                borderBottomLeftRadius: '5px',
                userSelect: 'none',
                position: 'absolute',
                top: '0',
                right: '2%',
                zIndex: '100',
                border: '4px solid var(--colour8)',
                borderTopWidth: '0px'
            },
            '.settingsHeader': {
                fontStyle: 'italic'
            },
            '#streamToolsHeader': {
                display: 'flex',
                flexDirection: 'row',
                justifyContent: 'space-between',
                borderBottom: '1px solid var(--colour8)',
                backgroundColor: 'var(--color7)'
            },
            '.streamTools': {
                backgroundColor: 'var(--color2)',
                fontFamily: 'var(--buttonFont)',
                fontWeight: 'lighter',
                color: 'var(--color7)'
            },
            '.streamTools-shown>#streamToolsSettings, .streamTools-shown>#streamToolsStats': {
                display: 'block'
            },
            '#streamToolsToggle': {
                width: '100%'
            },
            '#qualityStatus': {
                fontSize: '37px',
                paddingRight: '4px'
            },
            '.svgIcon': {
                fill: 'var(--color2)'
            },
            '.modal': {
                minWidth: '100vw',
                minHeight: '100vh',
                left: '0',
                top: '0',
                position: 'fixed',
                display: 'flex',
                flexDirection: 'column',
                justifyContent: 'center',
                alignItems: 'center',
                color: 'var(--color2)'
            },
            '.innerModal': {
                position: 'relative',
                width: '500px',
                height: '300px',
                backgroundColor: 'var(--color0)',
                display: 'flex',
                flexDirection: 'column',
                justifyContent: 'space-between',
                alignItems: 'center',
                borderRadius: '0.75em'
            },
            '.modalBtnContainer': {
                display: 'flex',
                flexDirection: 'row',
                justifyContent: 'space-around',
                width: '100%',
                paddingTop: '1em',
                paddingBottom: '1em'
            },
            '.modalTextArea': {
                textAlign: 'left',
                width: '95%',
                height: '100%',
                resize: 'none',
                fontSize: '1rem',
                border: '1px solid var(--color2)'
            },
            '.modalTextArea:focus-visible': {
                outline: 'none !important',
                border: '1px solid var(--color3)'
            },
            '.modal .btn-flat': {
                fontSize: '1.0rem'
            }
        };
        const { customStyles, lightModePalette, darkModePalette, jssInsertionPoint } = options !== null && options !== void 0 ? options : {};
        // One time setup with default plugins and settings.
        const jssOptions = {
            // JSS has many interesting plugins we may wish to turn on
            //plugins: [functions(), template(), global(), extend(), nested(), compose(), camelCase(), defaultUnit(options.defaultUnit), expand(), vendorPrefixer(), propsSort()]
            plugins: [(0,jss_plugin_global__WEBPACK_IMPORTED_MODULE_0__["default"])(), (0,jss_plugin_camel_case__WEBPACK_IMPORTED_MODULE_1__["default"])()],
            insertionPoint: jssInsertionPoint
        };
        jss__WEBPACK_IMPORTED_MODULE_2__["default"].setup(jssOptions);
        this.customStyles = customStyles;
        this.lightModePalette = lightModePalette !== null && lightModePalette !== void 0 ? lightModePalette : this.defaultLightModePalette;
        this.darkModePalette = darkModePalette !== null && darkModePalette !== void 0 ? darkModePalette : this.defaultDarkModePalette;
    }
    applyStyleSheet() {
        // Todo: refactor codebase to use jss at a component level, classes can be grabbed like so:
        //const {pixelStreamingClasses} = jss.createStyleSheet(styles).attach();
        // attach generated style sheet to page
        jss__WEBPACK_IMPORTED_MODULE_2__["default"].createStyleSheet({
            '@global': Object.assign(Object.assign({}, this.defaultStyles), this.customStyles)
        }).attach();
    }
    applyPalette(palette) {
        const rootElement = document.querySelector(':root');
        rootElement.style.setProperty('--color0', palette['--color0']);
        rootElement.style.setProperty('--color1', palette['--color1']);
        rootElement.style.setProperty('--color2', palette['--color2']);
        rootElement.style.setProperty('--color3', palette['--color3']);
        rootElement.style.setProperty('--color4', palette['--color4']);
        rootElement.style.setProperty('--color5', palette['--color5']);
        rootElement.style.setProperty('--color6', palette['--color6']);
        rootElement.style.setProperty('--color7', palette['--color7']);
    }
    /**
     * Update the players color variables
     * @param isLightMode - should we use a light or dark color scheme
     */
    setColorMode(isLightMode) {
        if (isLightMode) {
            this.applyPalette(this.lightModePalette);
        }
        else {
            this.applyPalette(this.darkModePalette);
        }
    }
}
//# sourceMappingURL=PixelStreamingApplicationStyles.js.map

/***/ }),

/***/ 9666:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Controls": () => (/* binding */ Controls)
/* harmony export */ });
/* harmony import */ var _FullscreenIcon__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(2713);
/* harmony import */ var _SettingsIcon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5557);
/* harmony import */ var _StatsIcon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7595);
/* harmony import */ var _XRIcon__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(221);
/* harmony import */ var _epicgames_ps_lib_pixelstreamingfrontend_ue5_5__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(9581);
/* harmony import */ var _UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(58);
// Copyright Epic Games, Inc. All Rights Reserved.






// If there isn't a type provided, default behaviour is to create the element.
function shouldCreateButton(type) {
    return type == undefined ? true : type.creationMode === _UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.UIElementCreationMode.CreateDefaultElement;
}
/**
 * Element containing various controls like stats, settings, fullscreen.
 */
class Controls {
    /**
     * Construct the controls
     */
    constructor(config) {
        this.config = config;
        if (!config || shouldCreateButton(config.statsButtonType)) {
            this.statsIcon = new _StatsIcon__WEBPACK_IMPORTED_MODULE_1__.StatsIcon();
        }
        if (!config || shouldCreateButton(config.settingsButtonType)) {
            this.settingsIcon = new _SettingsIcon__WEBPACK_IMPORTED_MODULE_2__.SettingsIcon();
        }
        if (!config || shouldCreateButton(config.fullscreenButtonType)) {
            this.fullscreenIcon = new _FullscreenIcon__WEBPACK_IMPORTED_MODULE_3__.FullScreenIcon();
        }
        if (!config || shouldCreateButton(config.xrIconType)) {
            this.xrIcon = new _XRIcon__WEBPACK_IMPORTED_MODULE_4__.XRIcon();
        }
    }
    /**
     * Get the element containing the controls.
     */
    get rootElement() {
        if (!this._rootElement) {
            this._rootElement = document.createElement('div');
            this._rootElement.id = 'controls';
            if (this.fullscreenIcon) {
                this._rootElement.appendChild(this.fullscreenIcon.rootElement);
            }
            if (this.settingsIcon) {
                this._rootElement.appendChild(this.settingsIcon.rootElement);
            }
            if (this.statsIcon) {
                this._rootElement.appendChild(this.statsIcon.rootElement);
            }
            if (this.xrIcon) {
                void _epicgames_ps_lib_pixelstreamingfrontend_ue5_5__WEBPACK_IMPORTED_MODULE_5__.WebXRController.isSessionSupported('immersive-vr').then((supported) => {
                    if (supported) {
                        this._rootElement.appendChild(this.xrIcon.rootElement);
                    }
                });
            }
            document.addEventListener('fullscreenchange', this.handleFullscreenChange.bind(this));
        }
        return this._rootElement;
    }
    handleFullscreenChange() {
        var _a;
        const isInFullscreen = !!document.fullscreenElement;
        if (isInFullscreen && ((_a = this.config) === null || _a === void 0 ? void 0 : _a.hideControlsInFullscreen)) {
            this._rootElement.style.visibility = 'hidden';
        }
        else {
            this._rootElement.style.visibility = 'visible';
        }
    }
}
//# sourceMappingURL=Controls.js.map

/***/ }),

/***/ 6677:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DataChannelLatencyTest": () => (/* binding */ DataChannelLatencyTest)
/* harmony export */ });
/* harmony import */ var _epicgames_ps_lib_pixelstreamingfrontend_ue5_5__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7800);
/* harmony import */ var _UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(58);
// Copyright Epic Games, Inc. All Rights Reserved.


/**
 * DataChannel Latency test UI elements and results handling.
 */
class DataChannelLatencyTest {
    /**
     * Get the button containing the stats icon.
     */
    get rootElement() {
        if (!this._rootElement) {
            this._rootElement = document.createElement('section');
            this._rootElement.classList.add('settingsContainer');
            // make heading
            const heading = document.createElement('div');
            heading.id = 'dataChannelLatencyTestHeader';
            heading.classList.add('settings-text');
            heading.classList.add('settingsHeader');
            this._rootElement.appendChild(heading);
            const headingText = document.createElement('div');
            headingText.innerHTML = _UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.StatsSections.DataChannelLatencyTest;
            heading.appendChild(headingText);
            heading.appendChild(this.latencyTestButton);
            // make test results element
            const resultsParentElem = document.createElement('div');
            resultsParentElem.id = 'dataChannelLatencyTestContainer';
            resultsParentElem.classList.add('d-none');
            this._rootElement.appendChild(resultsParentElem);
            resultsParentElem.appendChild(this.latencyTestResultsElement);
        }
        return this._rootElement;
    }
    get latencyTestResultsElement() {
        if (!this._latencyTestResultsElement) {
            this._latencyTestResultsElement = document.createElement('div');
            this._latencyTestResultsElement.id = 'dataChannelLatencyStatsResults';
            this._latencyTestResultsElement.classList.add('StatsResult');
        }
        return this._latencyTestResultsElement;
    }
    get latencyTestButton() {
        if (!this._latencyTestButton) {
            this._latencyTestButton = document.createElement('input');
            this._latencyTestButton.type = 'button';
            this._latencyTestButton.value = 'Run Test';
            this._latencyTestButton.id = 'btn-start-data-channel-latency-test';
            this._latencyTestButton.classList.add('streamTools-button');
            this._latencyTestButton.classList.add('btn-flat');
        }
        return this._latencyTestButton;
    }
    /**
     * Populate the UI based on the latency test's results.
     * @param result - The latency test results.
     */
    handleTestResult(result) {
        _epicgames_ps_lib_pixelstreamingfrontend_ue5_5__WEBPACK_IMPORTED_MODULE_1__.Logger.Info(JSON.stringify(result));
        /**
         * Check we have results, NaN would mean that UE version we talk to doesn't support our test
         */
        if (isNaN(result.dataChannelRtt)) {
            this.latencyTestResultsElement.innerHTML = '<div>Not supported</div>';
            return;
        }
        let latencyStatsInnerHTML = '';
        latencyStatsInnerHTML += '<div>Data channel RTT (ms): ' + result.dataChannelRtt + '</div>';
        /**
         * Separate path time discovery works only when UE and Player clocks have been synchronized.
         */
        if (result.playerToStreamerTime >= 0 && result.streamerToPlayerTime >= 0) {
            latencyStatsInnerHTML +=
                '<div>Player to Streamer path (ms): ' + result.playerToStreamerTime + '</div>';
            latencyStatsInnerHTML +=
                '<div>Streamer to Player path (ms): ' + result.streamerToPlayerTime + '</div>';
        }
        this.latencyTestResultsElement.innerHTML = latencyStatsInnerHTML;
        //setup button to download the detailed results
        const downloadButton = document.createElement('input');
        downloadButton.type = 'button';
        downloadButton.value = 'Download';
        downloadButton.classList.add('streamTools-button');
        downloadButton.classList.add('btn-flat');
        downloadButton.onclick = () => {
            const file = new Blob([result.exportLatencyAsCSV()], { type: 'text/plain' });
            const a = document.createElement('a');
            const url = URL.createObjectURL(file);
            a.href = url;
            a.download = 'data_channel_latency_test_results.csv';
            document.body.appendChild(a);
            a.click();
            setTimeout(function () {
                document.body.removeChild(a);
                window.URL.revokeObjectURL(url);
            }, 0);
        };
        this.latencyTestResultsElement.appendChild(downloadButton);
    }
    handleTestStart() {
        this.latencyTestResultsElement.innerHTML = '<div>Test in progress</div>';
    }
}
//# sourceMappingURL=DataChannelLatencyTest.js.map

/***/ }),

/***/ 2525:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EditConfirmedEvent": () => (/* binding */ EditConfirmedEvent),
/* harmony export */   "EditTextModal": () => (/* binding */ EditTextModal)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
// Event fired when "Confirm" button is clicked
class EditConfirmedEvent extends CustomEvent {
    constructor(confirmedText) {
        super('editConfirmed', {
            detail: confirmedText,
            bubbles: true,
            cancelable: true
        });
        this.confirmedText = confirmedText;
    }
}
/**
 * A modal that is shown when a UE widget is touched on mobile.
 * or
 * A hidden (offscreen) input field that is shown on non-touch devices (e.g. Desktop)
 * when a UE widget is clicked. The hidden text field is used so non-latin character
 * input can be composed using IME assistance (which requires an input field).
 *
 * The reason this modal is required is that on mobile typing uses
 * an on-screen keyboard, which requires a valid input text area/input
 * to be focused to summon it. Therefore we show this modal which has
 * the contents of the UE widget, populate its text area with the contents
 * of the UE widget, then focus the text area to finally summon the native
 * on-screen keyboard.
 *
 * The modal also contains:
 * 1) A cancel button - this closes the modal
 * 2) A confirm button - this submits the edit back to the UE side
 */
class EditTextModal {
    constructor() {
        this._rootElement = this.rootElement;
        this._events = new EventTarget();
    }
    // Bind to this if you want to handle edit confirmed
    get events() {
        return this._events;
    }
    showModal(existingTextAreaContents) {
        if (existingTextAreaContents) {
            // Remove any null terminators from the string
            existingTextAreaContents = existingTextAreaContents.replace(/\0/g, '');
            this.textArea.value = existingTextAreaContents;
        }
        // Bring focus to the text area.
        // This will make the on-screen keyboard show if we are
        // a device that has a native on-screen keyboard.
        // If we are on a non-touch device this will give IME a valid
        // input field to work with.
        this.textArea.focus();
        // Put cursor to the end of the textarea
        this.textArea.selectionStart = this.textArea.value.length;
    }
    /**
     * Get the root element that contains either the modal (mobile) or hidden text input (desktop)
     */
    get rootElement() {
        if (!this._rootElement) {
            this._rootElement = document.createElement('div');
            this._rootElement.classList.add('modal');
            this._rootElement.appendChild(this.innerModal);
        }
        return this._rootElement;
    }
    get innerModal() {
        if (!this._innerModal) {
            this._innerModal = document.createElement('div');
            this._innerModal.classList.add('innerModal');
            this._innerModal.appendChild(this.editTextHeading);
            this._innerModal.appendChild(this.textArea);
            this._innerModal.appendChild(this.modalBtnContainer);
        }
        return this._innerModal;
    }
    get editTextHeading() {
        if (!this._editTextHeading) {
            this._editTextHeading = document.createElement('h2');
            this._editTextHeading.innerText = 'Edit Text';
        }
        return this._editTextHeading;
    }
    get textArea() {
        if (!this._textArea) {
            this._textArea = document.createElement('textarea');
            this._textArea.classList.add('form-control');
            this._textArea.classList.add('modalTextArea');
            this._textArea.title = 'Edit Text Area';
            this._textArea.placeholder = 'UE text widget value here...';
            // When keyboard is typed into we want to ensure keys are not sent back to UE until we confirm.
            this.textArea.addEventListener('keypress', (event) => {
                event.stopPropagation();
            });
            this.textArea.addEventListener('keyup', (event) => {
                event.stopPropagation();
            });
            this.textArea.addEventListener('keydown', (event) => {
                event.stopPropagation();
            });
            this.textArea.addEventListener('compositionend', (event) => {
                event.stopPropagation();
            });
        }
        return this._textArea;
    }
    get modalBtnContainer() {
        if (!this._modalBtnContainer) {
            this._modalBtnContainer = document.createElement('div');
            this._modalBtnContainer.classList.add('modalBtnContainer');
            this._modalBtnContainer.appendChild(this.cancelBtn);
            this._modalBtnContainer.appendChild(this.confirmBtn);
        }
        return this._modalBtnContainer;
    }
    get cancelBtn() {
        if (!this._cancelBtn) {
            this._cancelBtn = document.createElement('button');
            this._cancelBtn.classList.add('btn-flat');
            this._cancelBtn.innerText = 'Cancel';
            // When cancel is clicked, remove this modal from the DOM
            this._cancelBtn.addEventListener('click', (event) => {
                this.rootElement.remove();
                // Ensure the click/tap does not go back to UE
                event.stopPropagation();
            });
        }
        return this._cancelBtn;
    }
    get confirmBtn() {
        if (!this._confirmBtn) {
            this._confirmBtn = document.createElement('button');
            this._confirmBtn.classList.add('btn-flat');
            this._confirmBtn.innerText = 'Confirm';
            // When confirm is clicked, remove from DOM and send the contents of textarea to UE
            this._confirmBtn.addEventListener('click', (event) => {
                this.events.dispatchEvent(new EditConfirmedEvent(this.textArea.value));
                this.rootElement.remove();
                // Ensure the click/tap does not go back to UE
                event.stopPropagation();
            });
        }
        return this._confirmBtn;
    }
}
//# sourceMappingURL=EditTextModal.js.map

/***/ }),

/***/ 2713:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FullScreenIcon": () => (/* binding */ FullScreenIcon),
/* harmony export */   "FullScreenIconBase": () => (/* binding */ FullScreenIconBase),
/* harmony export */   "FullScreenIconExternal": () => (/* binding */ FullScreenIconExternal)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
/**
 * Base class for an element (i.e. button) that, when clicked, will toggle fullscreen of a given element.
 * Can be initialized with any HTMLElement, if it is set as rootElement in the constructor.
 */
class FullScreenIconBase {
    get rootElement() {
        return this._rootElement;
    }
    set rootElement(element) {
        element.onclick = () => this.toggleFullscreen();
        this._rootElement = element;
    }
    constructor() {
        this.isFullscreen = false;
        // set up the full screen events
        document.addEventListener('webkitfullscreenchange', () => this.onFullscreenChange(), false);
        document.addEventListener('mozfullscreenchange', () => this.onFullscreenChange(), false);
        document.addEventListener('fullscreenchange', () => this.onFullscreenChange(), false);
        document.addEventListener('MSFullscreenChange', () => this.onFullscreenChange(), false);
    }
    /**
     * Makes the document or fullscreenElement fullscreen.
     */
    toggleFullscreen() {
        // if already full screen; exit
        // else go fullscreen
        if (document.fullscreenElement ||
            document.webkitFullscreenElement ||
            document.mozFullScreenElement ||
            document.msFullscreenElement) {
            if (document.exitFullscreen) {
                document.exitFullscreen();
            }
            else if (document.mozCancelFullScreen) {
                document.mozCancelFullScreen();
            }
            else if (document.webkitExitFullscreen) {
                document.webkitExitFullscreen();
            }
            else if (document.msExitFullscreen) {
                document.msExitFullscreen();
            }
        }
        else {
            const element = this.fullscreenElement;
            if (!element) {
                return;
            }
            if (element.requestFullscreen) {
                element.requestFullscreen();
            }
            else if (element.mozRequestFullscreen) {
                element.mozRequestFullscreen();
            }
            else if (element.webkitRequestFullscreen) {
                element.webkitRequestFullscreen();
            }
            else if (element.msRequestFullscreen) {
                element.msRequestFullscreen();
            }
            else if (element.webkitEnterFullscreen) {
                element.webkitEnterFullscreen(); //for iphone this code worked
            }
        }
        this.onFullscreenChange();
    }
    /**
     * Handles the fullscreen button on change
     */
    onFullscreenChange() {
        this.isFullscreen =
            document.webkitIsFullScreen ||
                document.mozFullScreen ||
                (document.msFullscreenElement && document.msFullscreenElement !== null) ||
                (document.fullscreenElement && document.fullscreenElement !== null);
    }
}
/**
 * An implementation of FullScreenIconBase that uses an externally
 * provided HTMLElement for toggling full screen.
 */
class FullScreenIconExternal extends FullScreenIconBase {
    constructor(externalButton) {
        super();
        this.rootElement = externalButton;
    }
}
/**
 * The default fullscreen icon that contains a button and svgs for each state.
 */
class FullScreenIcon extends FullScreenIconBase {
    constructor() {
        super();
        const createdButton = document.createElement('button');
        createdButton.type = 'button';
        createdButton.classList.add('UiTool');
        createdButton.id = 'fullscreen-btn';
        createdButton.appendChild(this.maximizeIcon);
        createdButton.appendChild(this.minimizeIcon);
        createdButton.appendChild(this.tooltipText);
        this.rootElement = createdButton;
    }
    get tooltipText() {
        if (!this._tooltipText) {
            this._tooltipText = document.createElement('span');
            this._tooltipText.classList.add('tooltiptext');
            this._tooltipText.innerHTML = 'Fullscreen';
        }
        return this._tooltipText;
    }
    get maximizeIcon() {
        if (!this._maximizeIcon) {
            this._maximizeIcon = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            this._maximizeIcon.setAttributeNS(null, 'id', 'maximizeIcon');
            this._maximizeIcon.setAttributeNS(null, 'x', '0px');
            this._maximizeIcon.setAttributeNS(null, 'y', '0px');
            this._maximizeIcon.setAttributeNS(null, 'viewBox', '0 0 384.97 384.97');
            // create svg group for the paths
            const svgGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            svgGroup.classList.add('svgIcon');
            this._maximizeIcon.appendChild(svgGroup);
            // create paths for the icon itself, one for each corner
            const path1 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path1.setAttributeNS(null, 'd', 'M384.97,12.03c0-6.713-5.317-12.03-12.03-12.03H264.847c-6.833,0-11.922,5.39-11.934,12.223c0,6.821,5.101,11.838,11.934,11.838h96.062l-0.193,96.519c0,6.833,5.197,12.03,12.03,12.03c6.833-0.012,12.03-5.197,12.03-12.03l0.193-108.369c0-0.036-0.012-0.06-0.012-0.084C384.958,12.09,384.97,12.066,384.97,12.03z');
            const path2 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path2.setAttributeNS(null, 'd', 'M120.496,0H12.403c-0.036,0-0.06,0.012-0.096,0.012C12.283,0.012,12.247,0,12.223,0C5.51,0,0.192,5.317,0.192,12.03L0,120.399c0,6.833,5.39,11.934,12.223,11.934c6.821,0,11.838-5.101,11.838-11.934l0.192-96.339h96.242c6.833,0,12.03-5.197,12.03-12.03C132.514,5.197,127.317,0,120.496,0z');
            const path3 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path3.setAttributeNS(null, 'd', 'M120.123,360.909H24.061v-96.242c0-6.833-5.197-12.03-12.03-12.03S0,257.833,0,264.667v108.092c0,0.036,0.012,0.06,0.012,0.084c0,0.036-0.012,0.06-0.012,0.096c0,6.713,5.317,12.03,12.03,12.03h108.092c6.833,0,11.922-5.39,11.934-12.223C132.057,365.926,126.956,360.909,120.123,360.909z');
            const path4 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path4.setAttributeNS(null, 'd', 'M372.747,252.913c-6.833,0-11.85,5.101-11.838,11.934v96.062h-96.242c-6.833,0-12.03,5.197-12.03,12.03s5.197,12.03,12.03,12.03h108.092c0.036,0,0.06-0.012,0.084-0.012c0.036-0.012,0.06,0.012,0.096,0.012c6.713,0,12.03-5.317,12.03-12.03V264.847C384.97,258.014,379.58,252.913,372.747,252.913z');
            svgGroup.appendChild(path1);
            svgGroup.appendChild(path2);
            svgGroup.appendChild(path3);
            svgGroup.appendChild(path4);
        }
        return this._maximizeIcon;
    }
    get minimizeIcon() {
        if (!this._minimizeIcon) {
            this._minimizeIcon = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            this._minimizeIcon.setAttributeNS(null, 'id', 'minimizeIcon');
            this._minimizeIcon.setAttributeNS(null, 'x', '0px');
            this._minimizeIcon.setAttributeNS(null, 'y', '0px');
            this._minimizeIcon.setAttributeNS(null, 'viewBox', '0 0 385.331 385.331');
            // create svg group for the paths
            const svgGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            svgGroup.classList.add('svgIcon');
            this._minimizeIcon.appendChild(svgGroup);
            // create paths for the icon itself, one for each corner
            const path1 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path1.setAttributeNS(null, 'd', 'M264.943,156.665h108.273c6.833,0,11.934-5.39,11.934-12.211c0-6.833-5.101-11.85-11.934-11.838h-96.242V36.181c0-6.833-5.197-12.03-12.03-12.03s-12.03,5.197-12.03,12.03v108.273c0,0.036,0.012,0.06,0.012,0.084c0,0.036-0.012,0.06-0.012,0.096C252.913,151.347,258.23,156.677,264.943,156.665z');
            const path2 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path2.setAttributeNS(null, 'd', 'M120.291,24.247c-6.821,0-11.838,5.113-11.838,11.934v96.242H12.03c-6.833,0-12.03,5.197-12.03,12.03c0,6.833,5.197,12.03,12.03,12.03h108.273c0.036,0,0.06-0.012,0.084-0.012c0.036,0,0.06,0.012,0.096,0.012c6.713,0,12.03-5.317,12.03-12.03V36.181C132.514,29.36,127.124,24.259,120.291,24.247z');
            const path3 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path3.setAttributeNS(null, 'd', 'M120.387,228.666H12.115c-6.833,0.012-11.934,5.39-11.934,12.223c0,6.833,5.101,11.85,11.934,11.838h96.242v96.423c0,6.833,5.197,12.03,12.03,12.03c6.833,0,12.03-5.197,12.03-12.03V240.877c0-0.036-0.012-0.06-0.012-0.084c0-0.036,0.012-0.06,0.012-0.096C132.418,233.983,127.1,228.666,120.387,228.666z');
            const path4 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path4.setAttributeNS(null, 'd', 'M373.3,228.666H265.028c-0.036,0-0.06,0.012-0.084,0.012c-0.036,0-0.06-0.012-0.096-0.012c-6.713,0-12.03,5.317-12.03,12.03v108.273c0,6.833,5.39,11.922,12.223,11.934c6.821,0.012,11.838-5.101,11.838-11.922v-96.242H373.3c6.833,0,12.03-5.197,12.03-12.03S380.134,228.678,373.3,228.666z');
            svgGroup.appendChild(path1);
            svgGroup.appendChild(path2);
            svgGroup.appendChild(path3);
            svgGroup.appendChild(path4);
        }
        return this._minimizeIcon;
    }
    onFullscreenChange() {
        super.onFullscreenChange();
        const minimize = this.minimizeIcon;
        const maximize = this.maximizeIcon;
        if (this.isFullscreen) {
            minimize.style.display = 'inline';
            //ios disappearing svg fix
            minimize.style.transform = 'translate(0, 0)';
            maximize.style.display = 'none';
        }
        else {
            minimize.style.display = 'none';
            maximize.style.display = 'inline';
            //ios disappearing svg fix
            maximize.style.transform = 'translate(0, 0)';
        }
    }
}
//# sourceMappingURL=FullscreenIcon.js.map

/***/ }),

/***/ 9998:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LabelledButton": () => (/* binding */ LabelledButton)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
/**
 * A button with a text label beside it.
 */
class LabelledButton {
    constructor(label, buttonText) {
        this._label = label;
        this._buttonText = buttonText;
    }
    /**
     * Add a click listener to the button element.
     */
    addOnClickListener(onClickFunc) {
        this.button.addEventListener('click', onClickFunc);
    }
    /**
     * Get the HTMLInputElement for the button.
     */
    get button() {
        if (!this._button) {
            this._button = document.createElement('input');
            this._button.type = 'button';
            this._button.value = this._buttonText;
            this._button.classList.add('overlay-button');
            this._button.classList.add('btn-flat');
        }
        return this._button;
    }
    /**
     * @returns Return or creates a HTML element that represents this setting in the DOM.
     */
    get rootElement() {
        if (!this._rootElement) {
            // create root div with "setting" css class
            this._rootElement = document.createElement('div');
            this._rootElement.classList.add('setting');
            // create div element to contain our setting's text
            const settingsTextElem = document.createElement('div');
            settingsTextElem.innerText = this._label;
            this._rootElement.appendChild(settingsTextElem);
            // create label element to wrap out input type
            const wrapperLabel = document.createElement('label');
            wrapperLabel.classList.add('btn-overlay');
            this._rootElement.appendChild(wrapperLabel);
            wrapperLabel.appendChild(this.button);
        }
        return this._rootElement;
    }
}
//# sourceMappingURL=LabelledButton.js.map

/***/ }),

/***/ 4921:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LatencyTest": () => (/* binding */ LatencyTest)
/* harmony export */ });
/* harmony import */ var _epicgames_ps_lib_pixelstreamingfrontend_ue5_5__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7800);
/* harmony import */ var _UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(58);
// Copyright Epic Games, Inc. All Rights Reserved.


/**
 * Latency test UI elements and results handling.
 */
class LatencyTest {
    /**
     * Get the the button containing the stats icon.
     */
    get rootElement() {
        if (!this._rootElement) {
            this._rootElement = document.createElement('section');
            this._rootElement.classList.add('settingsContainer');
            // make heading
            const heading = document.createElement('div');
            heading.id = 'latencyTestHeader';
            heading.classList.add('settings-text');
            heading.classList.add('settingsHeader');
            this._rootElement.appendChild(heading);
            const headingText = document.createElement('div');
            headingText.innerHTML = _UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.StatsSections.LatencyTest;
            heading.appendChild(headingText);
            heading.appendChild(this.latencyTestButton);
            // make test results element
            const resultsParentElem = document.createElement('div');
            resultsParentElem.id = 'latencyTestContainer';
            resultsParentElem.classList.add('d-none');
            this._rootElement.appendChild(resultsParentElem);
            resultsParentElem.appendChild(this.latencyTestResultsElement);
        }
        return this._rootElement;
    }
    get latencyTestResultsElement() {
        if (!this._latencyTestResultsElement) {
            this._latencyTestResultsElement = document.createElement('div');
            this._latencyTestResultsElement.id = 'latencyStatsResults';
            this._latencyTestResultsElement.classList.add('StatsResult');
        }
        return this._latencyTestResultsElement;
    }
    get latencyTestButton() {
        if (!this._latencyTestButton) {
            this._latencyTestButton = document.createElement('input');
            this._latencyTestButton.type = 'button';
            this._latencyTestButton.value = 'Run Test';
            this._latencyTestButton.id = 'btn-start-latency-test';
            this._latencyTestButton.classList.add('streamTools-button');
            this._latencyTestButton.classList.add('btn-flat');
        }
        return this._latencyTestButton;
    }
    /**
     * Populate the UI based on the latency test's results.
     * @param latencyTimings - The latency test results.
     */
    handleTestResult(latencyTimings) {
        _epicgames_ps_lib_pixelstreamingfrontend_ue5_5__WEBPACK_IMPORTED_MODULE_1__.Logger.Info(JSON.stringify(latencyTimings));
        let latencyStatsInnerHTML = '';
        if (latencyTimings.networkLatency !== undefined && latencyTimings.networkLatency > 0) {
            latencyStatsInnerHTML += '<div>Net latency RTT (ms): ' + latencyTimings.networkLatency + '</div>';
        }
        if (latencyTimings.EncodeMs !== undefined && latencyTimings.EncodeMs > 0) {
            latencyStatsInnerHTML += '<div>UE Encode (ms): ' + latencyTimings.EncodeMs + '</div>';
        }
        if (latencyTimings.CaptureToSendMs !== undefined && latencyTimings.CaptureToSendMs > 0) {
            latencyStatsInnerHTML += '<div>UE Capture (ms): ' + latencyTimings.CaptureToSendMs + '</div>';
        }
        if (latencyTimings.browserSendLatency !== undefined && latencyTimings.browserSendLatency > 0) {
            latencyStatsInnerHTML +=
                '<div>Browser send latency (ms): ' + latencyTimings.browserSendLatency + '</div>';
        }
        if (latencyTimings.frameDisplayDeltaTimeMs !== undefined &&
            latencyTimings.browserReceiptTimeMs !== undefined) {
            latencyStatsInnerHTML +=
                latencyTimings.frameDisplayDeltaTimeMs && latencyTimings.browserReceiptTimeMs
                    ? '<div>Browser receive latency (ms): ' +
                        latencyTimings.frameDisplayDeltaTimeMs +
                        '</div>'
                    : '';
        }
        if (latencyTimings.latencyExcludingDecode !== undefined) {
            latencyStatsInnerHTML +=
                '<div>Total latency (excluding browser) (ms): ' +
                    latencyTimings.latencyExcludingDecode +
                    '</div>';
        }
        if (latencyTimings.endToEndLatency !== undefined) {
            latencyStatsInnerHTML += latencyTimings.endToEndLatency
                ? '<div>Total latency (ms): ' + latencyTimings.endToEndLatency + '</div>'
                : '';
        }
        this.latencyTestResultsElement.innerHTML = latencyStatsInnerHTML;
    }
}
//# sourceMappingURL=LatencyTest.js.map

/***/ }),

/***/ 5557:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SettingsIcon": () => (/* binding */ SettingsIcon)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
/**
 * Settings icon that can be clicked.
 */
class SettingsIcon {
    /**
     * Get the the button containing the settings icon.
     */
    get rootElement() {
        if (!this._rootElement) {
            this._rootElement = document.createElement('button');
            this._rootElement.type = 'button';
            this._rootElement.classList.add('UiTool');
            this._rootElement.id = 'settingsBtn';
            this._rootElement.appendChild(this.settingsIcon);
            this._rootElement.appendChild(this.tooltipText);
        }
        return this._rootElement;
    }
    get tooltipText() {
        if (!this._tooltipText) {
            this._tooltipText = document.createElement('span');
            this._tooltipText.classList.add('tooltiptext');
            this._tooltipText.innerHTML = 'Settings';
        }
        return this._tooltipText;
    }
    get settingsIcon() {
        if (!this._settingsIcon) {
            this._settingsIcon = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            this._settingsIcon.setAttributeNS(null, 'id', 'settingsIcon');
            this._settingsIcon.setAttributeNS(null, 'x', '0px');
            this._settingsIcon.setAttributeNS(null, 'y', '0px');
            this._settingsIcon.setAttributeNS(null, 'viewBox', '0 0 478.703 478.703');
            // create svg group for the paths
            const svgGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            svgGroup.classList.add('svgIcon');
            this._settingsIcon.appendChild(svgGroup);
            // create paths for the icon itself, the inner and out path of a cog
            const path1 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path1.setAttributeNS(null, 'd', 'M454.2,189.101l-33.6-5.7c-3.5-11.3-8-22.2-13.5-32.6l19.8-27.7c8.4-11.8,7.1-27.9-3.2-38.1l-29.8-29.8\
			c-5.6-5.6-13-8.7-20.9-8.7c-6.2,0-12.1,1.9-17.1,5.5l-27.8,19.8c-10.8-5.7-22.1-10.4-33.8-13.9l-5.6-33.2\
			c-2.4-14.3-14.7-24.7-29.2-24.7h-42.1c-14.5,0-26.8,10.4-29.2,24.7l-5.8,34c-11.2,3.5-22.1,8.1-32.5,13.7l-27.5-19.8\
			c-5-3.6-11-5.5-17.2-5.5c-7.9,0-15.4,3.1-20.9,8.7l-29.9,29.8c-10.2,10.2-11.6,26.3-3.2,38.1l20,28.1\
			c-5.5,10.5-9.9,21.4-13.3,32.7l-33.2,5.6c-14.3,2.4-24.7,14.7-24.7,29.2v42.1c0,14.5,10.4,26.8,24.7,29.2l34,5.8\
			c3.5,11.2,8.1,22.1,13.7,32.5l-19.7,27.4c-8.4,11.8-7.1,27.9,3.2,38.1l29.8,29.8c5.6,5.6,13,8.7,20.9,8.7c6.2,0,12.1-1.9,17.1-5.5\
			l28.1-20c10.1,5.3,20.7,9.6,31.6,13l5.6,33.6c2.4,14.3,14.7,24.7,29.2,24.7h42.2c14.5,0,26.8-10.4,29.2-24.7l5.7-33.6\
			c11.3-3.5,22.2-8,32.6-13.5l27.7,19.8c5,3.6,11,5.5,17.2,5.5l0,0c7.9,0,15.3-3.1,20.9-8.7l29.8-29.8c10.2-10.2,11.6-26.3,3.2-38.1\
			l-19.8-27.8c5.5-10.5,10.1-21.4,13.5-32.6l33.6-5.6c14.3-2.4,24.7-14.7,24.7-29.2v-42.1\
			C478.9,203.801,468.5,191.501,454.2,189.101z M451.9,260.401c0,1.3-0.9,2.4-2.2,2.6l-42,7c-5.3,0.9-9.5,4.8-10.8,9.9\
			c-3.8,14.7-9.6,28.8-17.4,41.9c-2.7,4.6-2.5,10.3,0.6,14.7l24.7,34.8c0.7,1,0.6,2.5-0.3,3.4l-29.8,29.8c-0.7,0.7-1.4,0.8-1.9,0.8\
			c-0.6,0-1.1-0.2-1.5-0.5l-34.7-24.7c-4.3-3.1-10.1-3.3-14.7-0.6c-13.1,7.8-27.2,13.6-41.9,17.4c-5.2,1.3-9.1,5.6-9.9,10.8l-7.1,42\
			c-0.2,1.3-1.3,2.2-2.6,2.2h-42.1c-1.3,0-2.4-0.9-2.6-2.2l-7-42c-0.9-5.3-4.8-9.5-9.9-10.8c-14.3-3.7-28.1-9.4-41-16.8\
			c-2.1-1.2-4.5-1.8-6.8-1.8c-2.7,0-5.5,0.8-7.8,2.5l-35,24.9c-0.5,0.3-1,0.5-1.5,0.5c-0.4,0-1.2-0.1-1.9-0.8l-29.8-29.8\
			c-0.9-0.9-1-2.3-0.3-3.4l24.6-34.5c3.1-4.4,3.3-10.2,0.6-14.8c-7.8-13-13.8-27.1-17.6-41.8c-1.4-5.1-5.6-9-10.8-9.9l-42.3-7.2\
			c-1.3-0.2-2.2-1.3-2.2-2.6v-42.1c0-1.3,0.9-2.4,2.2-2.6l41.7-7c5.3-0.9,9.6-4.8,10.9-10c3.7-14.7,9.4-28.9,17.1-42\
			c2.7-4.6,2.4-10.3-0.7-14.6l-24.9-35c-0.7-1-0.6-2.5,0.3-3.4l29.8-29.8c0.7-0.7,1.4-0.8,1.9-0.8c0.6,0,1.1,0.2,1.5,0.5l34.5,24.6\
			c4.4,3.1,10.2,3.3,14.8,0.6c13-7.8,27.1-13.8,41.8-17.6c5.1-1.4,9-5.6,9.9-10.8l7.2-42.3c0.2-1.3,1.3-2.2,2.6-2.2h42.1\
			c1.3,0,2.4,0.9,2.6,2.2l7,41.7c0.9,5.3,4.8,9.6,10,10.9c15.1,3.8,29.5,9.7,42.9,17.6c4.6,2.7,10.3,2.5,14.7-0.6l34.5-24.8\
			c0.5-0.3,1-0.5,1.5-0.5c0.4,0,1.2,0.1,1.9,0.8l29.8,29.8c0.9,0.9,1,2.3,0.3,3.4l-24.7,34.7c-3.1,4.3-3.3,10.1-0.6,14.7\
			c7.8,13.1,13.6,27.2,17.4,41.9c1.3,5.2,5.6,9.1,10.8,9.9l42,7.1c1.3,0.2,2.2,1.3,2.2,2.6v42.1H451.9z');
            const path2 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path2.setAttributeNS(null, 'd', 'M239.4,136.001c-57,0-103.3,46.3-103.3,103.3s46.3,103.3,103.3,103.3s103.3-46.3,103.3-103.3S296.4,136.001,239.4,136.001z M239.4,315.601c-42.1,0-76.3-34.2-76.3-76.3s34.2-76.3,76.3-76.3s76.3,34.2,76.3,76.3S281.5,315.601,239.4,315.601z');
            svgGroup.appendChild(path1);
            svgGroup.appendChild(path2);
        }
        return this._settingsIcon;
    }
}
//# sourceMappingURL=SettingsIcon.js.map

/***/ }),

/***/ 8611:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SettingsPanel": () => (/* binding */ SettingsPanel)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
/**
 * A UI component containing all the settings for the application.
 */
class SettingsPanel {
    constructor() {
        this._rootElement = null;
    }
    /**
     * @returns Return or creates a HTML element that represents this setting in the DOM.
     */
    get rootElement() {
        if (!this._rootElement) {
            this._rootElement = document.createElement('div');
            this._rootElement.id = 'settings-panel';
            this._rootElement.classList.add('panel-wrap');
            const panelElem = document.createElement('div');
            panelElem.classList.add('panel');
            this._rootElement.appendChild(panelElem);
            const settingsHeading = document.createElement('div');
            settingsHeading.id = 'settingsHeading';
            settingsHeading.textContent = 'Settings';
            panelElem.appendChild(settingsHeading);
            panelElem.appendChild(this.settingsCloseButton);
            panelElem.appendChild(this.settingsContentElement);
        }
        return this._rootElement;
    }
    get settingsContentElement() {
        if (!this._settingsContentElement) {
            this._settingsContentElement = document.createElement('div');
            this._settingsContentElement.id = 'settingsContent';
        }
        return this._settingsContentElement;
    }
    get settingsCloseButton() {
        if (!this._settingsCloseButton) {
            this._settingsCloseButton = document.createElement('div');
            this._settingsCloseButton.id = 'settingsClose';
        }
        return this._settingsCloseButton;
    }
    /**
     * Show settings panel.
     */
    show() {
        if (!this.rootElement.classList.contains('panel-wrap-visible')) {
            this.rootElement.classList.add('panel-wrap-visible');
        }
    }
    /**
     * Toggle the visibility of the settings panel.
     */
    toggleVisibility() {
        this.rootElement.classList.toggle('panel-wrap-visible');
    }
    /**
     * Hide settings panel.
     */
    hide() {
        if (this.rootElement.classList.contains('panel-wrap-visible')) {
            this.rootElement.classList.remove('panel-wrap-visible');
        }
    }
}
//# sourceMappingURL=SettingsPanel.js.map

/***/ }),

/***/ 7595:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "StatsIcon": () => (/* binding */ StatsIcon)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
/**
 * Stats icon that can be clicked.
 */
class StatsIcon {
    /**
     * Get the the button containing the stats icon.
     */
    get rootElement() {
        if (!this._rootElement) {
            this._rootElement = document.createElement('button');
            this._rootElement.type = 'button';
            this._rootElement.classList.add('UiTool');
            this._rootElement.id = 'statsBtn';
            this._rootElement.appendChild(this.statsIcon);
            this._rootElement.appendChild(this.tooltipText);
        }
        return this._rootElement;
    }
    get tooltipText() {
        if (!this._tooltipText) {
            this._tooltipText = document.createElement('span');
            this._tooltipText.classList.add('tooltiptext');
            this._tooltipText.innerHTML = 'Information';
        }
        return this._tooltipText;
    }
    get statsIcon() {
        if (!this._statsIcon) {
            this._statsIcon = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            this._statsIcon.setAttributeNS(null, 'id', 'statsIcon');
            this._statsIcon.setAttributeNS(null, 'x', '0px');
            this._statsIcon.setAttributeNS(null, 'y', '0px');
            this._statsIcon.setAttributeNS(null, 'viewBox', '0 0 330 330');
            // create svg group for the paths
            const svgGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            svgGroup.classList.add('svgIcon');
            this._statsIcon.appendChild(svgGroup);
            // create paths for the icon itself, the inner and out path of a cog
            const path1 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path1.setAttributeNS(null, 'd', 'M165,0.008C74.019,0.008,0,74.024,0,164.999c0,90.977,74.019,164.992,165,164.992s165-74.015,165-164.992C330,74.024,255.981,0.008,165,0.008z M165,299.992c-74.439,0-135-60.557-135-134.992S90.561,30.008,165,30.008s135,60.557,135,134.991C300,239.436,239.439,299.992,165,299.992z');
            const path2 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path2.setAttributeNS(null, 'd', 'M165,130.008c-8.284,0-15,6.716-15,15v99.983c0,8.284,6.716,15,15,15s15-6.716,15-15v-99.983C180,136.725,173.284,130.008,165,130.008z');
            const path3 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path3.setAttributeNS(null, 'd', 'M165,70.011c-3.95,0-7.811,1.6-10.61,4.39c-2.79,2.79-4.39,6.66-4.39,10.61s1.6,7.81,4.39,10.61c2.79,2.79,6.66,4.39,10.61,4.39s7.81-1.6,10.609-4.39c2.79-2.8,4.391-6.66,4.391-10.61s-1.601-7.82-4.391-10.61C172.81,71.61,168.95,70.011,165,70.011z');
            svgGroup.appendChild(path1);
            svgGroup.appendChild(path2);
            svgGroup.appendChild(path3);
        }
        return this._statsIcon;
    }
}
//# sourceMappingURL=StatsIcon.js.map

/***/ }),

/***/ 1088:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Stat": () => (/* binding */ Stat),
/* harmony export */   "StatsPanel": () => (/* binding */ StatsPanel)
/* harmony export */ });
/* harmony import */ var _LatencyTest__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4921);
/* harmony import */ var _epicgames_ps_lib_pixelstreamingfrontend_ue5_5__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(7800);
/* harmony import */ var _Util_MathUtils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(7336);
/* harmony import */ var _DataChannelLatencyTest__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6677);
/* harmony import */ var _UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(58);
// Copyright Epic Games, Inc. All Rights Reserved.





/**
 * A stat structure, an id, the stat string, and the element where it is rendered.
 */
class Stat {
}
/**
 * A UI component containing all the stats for the application.
 */
class StatsPanel {
    constructor(config) {
        /* A map stats we are storing/rendering */
        this.statsMap = new Map();
        this._config = config;
        this.latencyTest = new _LatencyTest__WEBPACK_IMPORTED_MODULE_0__.LatencyTest();
        this.dataChannelLatencyTest = new _DataChannelLatencyTest__WEBPACK_IMPORTED_MODULE_1__.DataChannelLatencyTest();
    }
    /**
     * @returns Return or creates a HTML element that represents this setting in the DOM.
     */
    get rootElement() {
        if (!this._rootElement) {
            this._rootElement = document.createElement('div');
            this._rootElement.id = 'stats-panel';
            this._rootElement.classList.add('panel-wrap');
            const panelElem = document.createElement('div');
            panelElem.classList.add('panel');
            this._rootElement.appendChild(panelElem);
            const statsHeading = document.createElement('div');
            statsHeading.id = 'statsHeading';
            statsHeading.textContent = 'Information';
            panelElem.appendChild(statsHeading);
            panelElem.appendChild(this.statsCloseButton);
            panelElem.appendChild(this.statsContentElement);
        }
        return this._rootElement;
    }
    get statsContentElement() {
        if (!this._statsContentElement) {
            this._statsContentElement = document.createElement('div');
            this._statsContentElement.id = 'statsContent';
            const streamToolStats = document.createElement('div');
            streamToolStats.id = 'streamToolsStats';
            streamToolStats.classList.add('container');
            const controlStats = document.createElement('div');
            controlStats.id = 'ControlStats';
            controlStats.classList.add('row');
            const statistics = document.createElement('section');
            statistics.id = 'statistics';
            statistics.classList.add('settingsContainer');
            const latencyStats = document.createElement('section');
            latencyStats.id = 'latencyStats';
            latencyStats.classList.add('settingsContainer');
            const statisticsHeader = document.createElement('div');
            statisticsHeader.id = 'statisticsHeader';
            statisticsHeader.classList.add('settings-text');
            statisticsHeader.classList.add('settingsHeader');
            const latencyStatsHeader = document.createElement('div');
            latencyStatsHeader.id = 'latencyStatsHeader';
            latencyStatsHeader.classList.add('settings-text');
            latencyStatsHeader.classList.add('settingsHeader');
            this._statsContentElement.appendChild(streamToolStats);
            streamToolStats.appendChild(controlStats);
            controlStats.appendChild(statistics);
            controlStats.appendChild(latencyStats);
            statistics.appendChild(statisticsHeader);
            latencyStats.appendChild(latencyStatsHeader);
            if ((0,_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_2__.isSectionEnabled)(this._config, _UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_2__.StatsSections.SessionStats)) {
                const sessionStatsText = document.createElement('div');
                sessionStatsText.innerHTML = _UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_2__.StatsSections.SessionStats;
                statisticsHeader.appendChild(sessionStatsText);
            }
            statistics.appendChild(this.statisticsContainer);
            if ((0,_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_2__.isSectionEnabled)(this._config, _UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_2__.StatsSections.LatencyStats)) {
                const latencyStatsText = document.createElement('div');
                latencyStatsText.innerHTML = _UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_2__.StatsSections.LatencyStats;
                latencyStatsHeader.appendChild(latencyStatsText);
            }
            latencyStats.appendChild(this.latencyStatsContainer);
            if ((0,_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_2__.isSectionEnabled)(this._config, _UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_2__.StatsSections.LatencyTest)) {
                controlStats.appendChild(this.latencyTest.rootElement);
            }
            if ((0,_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_2__.isSectionEnabled)(this._config, _UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_2__.StatsSections.DataChannelLatencyTest)) {
                controlStats.appendChild(this.dataChannelLatencyTest.rootElement);
            }
        }
        return this._statsContentElement;
    }
    get statisticsContainer() {
        if (!this._statisticsContainer) {
            this._statisticsContainer = document.createElement('div');
            this._statisticsContainer.id = 'statisticsContainer';
            this._statisticsContainer.classList.add('d-none');
            this._statisticsContainer.appendChild(this.statsResult);
        }
        return this._statisticsContainer;
    }
    get latencyStatsContainer() {
        if (!this._latencyStatsContainer) {
            this._latencyStatsContainer = document.createElement('div');
            this._latencyStatsContainer.id = 'latencyStatsContainer';
            this._latencyStatsContainer.classList.add('d-none');
            this._latencyStatsContainer.appendChild(this.latencyResult);
        }
        return this._latencyStatsContainer;
    }
    get statsResult() {
        if (!this._statsResult) {
            this._statsResult = document.createElement('div');
            this._statsResult.id = 'statisticsResult';
            this._statsResult.classList.add('StatsResult');
        }
        return this._statsResult;
    }
    get latencyResult() {
        if (!this._latencyResult) {
            this._latencyResult = document.createElement('div');
            this._latencyResult.id = 'latencyResult';
            this._latencyResult.classList.add('StatsResult');
        }
        return this._latencyResult;
    }
    get statsCloseButton() {
        if (!this._statsCloseButton) {
            this._statsCloseButton = document.createElement('div');
            this._statsCloseButton.id = 'statsClose';
        }
        return this._statsCloseButton;
    }
    onDisconnect() {
        this.latencyTest.latencyTestButton.onclick = () => {
            // do nothing
        };
        this.dataChannelLatencyTest.latencyTestButton.onclick = () => {
            //do nothing
        };
    }
    onVideoInitialized(stream) {
        // starting a latency check
        this.latencyTest.latencyTestButton.onclick = () => {
            stream.requestLatencyTest();
        };
        this.dataChannelLatencyTest.latencyTestButton.onclick = () => {
            const started = stream.requestDataChannelLatencyTest({
                duration: 1000,
                rps: 10,
                requestSize: 200,
                responseSize: 200
            });
            if (started) {
                this.dataChannelLatencyTest.handleTestStart();
            }
        };
    }
    configure(settings) {
        if (settings.DisableLatencyTest) {
            this.latencyTest.latencyTestButton.disabled = true;
            this.latencyTest.latencyTestButton.title = 'Disabled by -PixelStreamingDisableLatencyTester=true';
            this.dataChannelLatencyTest.latencyTestButton.disabled = true;
            this.dataChannelLatencyTest.latencyTestButton.title =
                'Disabled by -PixelStreamingDisableLatencyTester=true';
            _epicgames_ps_lib_pixelstreamingfrontend_ue5_5__WEBPACK_IMPORTED_MODULE_3__.Logger.Info('-PixelStreamingDisableLatencyTester=true, requesting latency report from the the browser to UE is disabled.');
        }
    }
    /**
     * Show stats panel.
     */
    show() {
        if (!this.rootElement.classList.contains('panel-wrap-visible')) {
            this.rootElement.classList.add('panel-wrap-visible');
        }
    }
    /**
     * Toggle the visibility of the stats panel.
     */
    toggleVisibility() {
        this.rootElement.classList.toggle('panel-wrap-visible');
    }
    /**
     * Hide the stats panel.
     */
    hide() {
        if (this.rootElement.classList.contains('panel-wrap-visible')) {
            this.rootElement.classList.remove('panel-wrap-visible');
        }
    }
    handlePlayerCount(playerCount) {
        this.addOrUpdateSessionStat('PlayerCountStat', 'Players', playerCount.toString());
    }
    /**
     * Handle stats coming in from browser/UE
     * @param stats - the stats structure
     */
    handleStats(stats) {
        var _a, _b, _c, _d;
        // format numbering based on the browser language
        const numberFormat = new Intl.NumberFormat(window.navigator.language, {
            maximumFractionDigits: 0
        });
        // Inbound data
        const inboundData = _Util_MathUtils__WEBPACK_IMPORTED_MODULE_4__.MathUtils.formatBytes(stats.inboundVideoStats.bytesReceived, 2);
        this.addOrUpdateSessionStat('InboundDataStat', 'Received', inboundData);
        // Packets lost
        const packetsLostStat = Object.prototype.hasOwnProperty.call(stats.inboundVideoStats, 'packetsLost')
            ? numberFormat.format(stats.inboundVideoStats.packetsLost)
            : 'Chrome only';
        this.addOrUpdateSessionStat('PacketsLostStat', 'Packets Lost', packetsLostStat);
        // Bitrate
        if (stats.inboundVideoStats.bitrate) {
            this.addOrUpdateSessionStat('VideoBitrateStat', 'Video Bitrate (kbps)', stats.inboundVideoStats.bitrate.toString());
        }
        if (stats.inboundAudioStats.bitrate) {
            this.addOrUpdateSessionStat('AudioBitrateStat', 'Audio Bitrate (kbps)', stats.inboundAudioStats.bitrate.toString());
        }
        // Video resolution
        const resStat = stats.inboundVideoStats.frameWidth !== undefined &&
            stats.inboundVideoStats.frameWidth > 0 &&
            stats.inboundVideoStats.frameHeight !== undefined &&
            stats.inboundVideoStats.frameHeight > 0
            ? stats.inboundVideoStats.frameWidth + 'x' + stats.inboundVideoStats.frameHeight
            : 'Chrome only';
        this.addOrUpdateSessionStat('VideoResStat', 'Video resolution', resStat);
        // Frames decoded
        if (stats.inboundVideoStats.framesDecoded !== undefined) {
            const framesDecoded = numberFormat.format(stats.inboundVideoStats.framesDecoded);
            this.addOrUpdateSessionStat('FramesDecodedStat', 'Frames Decoded', framesDecoded);
        }
        // Framerate
        if (stats.inboundVideoStats.framesPerSecond) {
            this.addOrUpdateSessionStat('FramerateStat', 'Framerate', stats.inboundVideoStats.framesPerSecond.toString());
        }
        // Frames dropped
        if (stats.inboundVideoStats.framesDropped !== undefined) {
            this.addOrUpdateSessionStat('FramesDroppedStat', 'Frames dropped', stats.inboundVideoStats.framesDropped.toString());
        }
        if (stats.inboundVideoStats.codecId) {
            this.addOrUpdateSessionStat('VideoCodecStat', 'Video codec', 
            // Split the codec to remove the Fmtp line
            (_b = (_a = stats.codecs.get(stats.inboundVideoStats.codecId)) === null || _a === void 0 ? void 0 : _a.mimeType.replace('video/', '')) !== null && _b !== void 0 ? _b : '');
        }
        if (stats.inboundAudioStats.codecId) {
            this.addOrUpdateSessionStat('AudioCodecStat', 'Audio codec', 
            // Split the codec to remove the Fmtp line
            (_d = (_c = stats.codecs.get(stats.inboundAudioStats.codecId)) === null || _c === void 0 ? void 0 : _c.mimeType.replace('audio/', '')) !== null && _d !== void 0 ? _d : '');
        }
        // Store the active candidate pair return a new Candidate pair stat if getActiveCandidate is null
        const activeCandidatePair = stats.getActiveCandidatePair();
        if (activeCandidatePair) {
            // RTT
            const netRTT = Object.prototype.hasOwnProperty.call(activeCandidatePair, 'currentRoundTripTime') &&
                stats.isNumber(activeCandidatePair.currentRoundTripTime)
                ? Math.ceil(activeCandidatePair.currentRoundTripTime * 1000).toString()
                : "Can't calculate";
            this.addOrUpdateSessionStat('RTTStat', 'Net RTT (ms)', netRTT);
        }
        this.addOrUpdateSessionStat('DurationStat', 'Duration', stats.sessionStats.runTime);
        this.addOrUpdateSessionStat('ControlsInputStat', 'Controls stream input', stats.sessionStats.controlsStreamInput);
        // QP
        if (stats.sessionStats.videoEncoderAvgQP !== undefined &&
            !Number.isNaN(stats.sessionStats.videoEncoderAvgQP)) {
            this.addOrUpdateSessionStat('QPStat', 'Video quantization parameter', stats.sessionStats.videoEncoderAvgQP.toString());
        }
        _epicgames_ps_lib_pixelstreamingfrontend_ue5_5__WEBPACK_IMPORTED_MODULE_3__.Logger.Info(`--------- Stats ---------\n ${JSON.stringify(stats)}\n------------------------`);
    }
    handleLatencyInfo(latencyInfo) {
        if (latencyInfo.frameTiming !== undefined) {
            // Encoder latency
            if (latencyInfo.frameTiming.encoderLatencyMs !== undefined) {
                this.addOrUpdateLatencyStat('EncodeLatency', 'Encode latency (ms)', Math.ceil(latencyInfo.frameTiming.encoderLatencyMs).toString());
            }
            // Packetizer latency
            if (latencyInfo.frameTiming.packetizeLatencyMs !== undefined) {
                this.addOrUpdateLatencyStat('PacketizerLatency', 'Packetizer latency (ms)', Math.ceil(latencyInfo.frameTiming.packetizeLatencyMs).toString());
            }
            // Pacer latency
            if (latencyInfo.frameTiming.pacerLatencyMs !== undefined) {
                this.addOrUpdateLatencyStat('PacerLatency', 'Pacer latency (ms)', Math.ceil(latencyInfo.frameTiming.pacerLatencyMs).toString());
            }
            // Sender latency calculated using timing stats
            if (latencyInfo.frameTiming.captureToSendLatencyMs !== undefined) {
                this.addOrUpdateLatencyStat('VideoTimingCaptureToSend', 'Post-capture to send latency (ms)', Math.ceil(latencyInfo.frameTiming.captureToSendLatencyMs).toString());
            }
        }
        if (latencyInfo.senderLatencyMs !== undefined) {
            this.addOrUpdateLatencyStat('AbsCaptureTimeToSendLatency', 'Post-capture (abs-ct) to send latency (ms)', Math.ceil(latencyInfo.senderLatencyMs).toString());
        }
        if (latencyInfo.averageAssemblyDelayMs !== undefined) {
            this.addOrUpdateLatencyStat('AvgAssemblyDelay', 'Assembly delay (ms)', Math.ceil(latencyInfo.averageAssemblyDelayMs).toString());
        }
        if (latencyInfo.averageDecodeLatencyMs !== undefined) {
            this.addOrUpdateLatencyStat('AvgDecodeDelay', 'Decode time (ms)', Math.ceil(latencyInfo.averageDecodeLatencyMs).toString());
        }
        if (latencyInfo.averageJitterBufferDelayMs !== undefined) {
            this.addOrUpdateLatencyStat('AvgJitterBufferDelay', 'Jitter buffer (ms)', Math.ceil(latencyInfo.averageJitterBufferDelayMs).toString());
        }
        if (latencyInfo.averageProcessingDelayMs !== undefined) {
            this.addOrUpdateLatencyStat('AvgProcessingDelay', 'Processing delay (ms)', Math.ceil(latencyInfo.averageProcessingDelayMs).toString());
        }
        if (latencyInfo.averageE2ELatency !== undefined) {
            this.addOrUpdateLatencyStat('AvgE2ELatency', 'Total latency (ms)', Math.ceil(latencyInfo.averageE2ELatency).toString());
        }
    }
    /**
     * Adds a new stat to the stats results in the DOM or updates an exiting stat.
     * @param id - The id of the stat to add/update.
     * @param stat - The contents of the stat.
     */
    addOrUpdateSessionStat(id, statLabel, stat) {
        this.addOrUpdateStat(_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_2__.StatsSections.SessionStats, id, statLabel, stat);
    }
    /**
     * Adds a new stat to the latency results in the DOM or updates an exiting stat.
     * @param id - The id of the stat to add/update.
     * @param stat - The contents of the stat.
     */
    addOrUpdateLatencyStat(id, statLabel, stat) {
        this.addOrUpdateStat(_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_2__.StatsSections.LatencyStats, id, statLabel, stat);
    }
    /**
     * Adds a new stat to the stats results in the DOM or updates an exiting stat.
     * @param sectionId - The section to add this stat too.
     * @param id - The id of the stat to add/update.
     * @param stat - The contents of the stat.
     */
    addOrUpdateStat(sectionId, id, statLabel, stat) {
        if (sectionId === _UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_2__.StatsSections.SessionStats &&
            !(0,_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_2__.isSectionEnabled)(this._config, _UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_2__.StatsSections.SessionStats)) {
            return;
        }
        if (sectionId === _UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_2__.StatsSections.LatencyStats &&
            !(0,_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_2__.isSectionEnabled)(this._config, _UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_2__.StatsSections.LatencyStats)) {
            return;
        }
        // Only support session or latency stats being updated in this function currently
        if (sectionId !== _UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_2__.StatsSections.SessionStats && sectionId !== _UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_2__.StatsSections.LatencyStats) {
            return;
        }
        const parentElem = sectionId === _UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_2__.StatsSections.SessionStats ? this.statsResult : this.latencyResult;
        const statHTML = `${statLabel}: ${stat}`;
        if (!this.statsMap.has(id)) {
            // create the stat
            const newStat = new Stat();
            newStat.id = id;
            newStat.stat = stat;
            newStat.title = statLabel;
            newStat.element = document.createElement('div');
            newStat.element.innerHTML = statHTML;
            // add the stat to the dom
            parentElem.appendChild(newStat.element);
            this.statsMap.set(id, newStat);
        }
        // update the existing stat
        else {
            const value = this.statsMap.get(id);
            if (value !== undefined) {
                value.element.innerHTML = statHTML;
            }
        }
    }
}
//# sourceMappingURL=StatsPanel.js.map

/***/ }),

/***/ 58:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ExtraFlags": () => (/* binding */ ExtraFlags),
/* harmony export */   "SettingsSections": () => (/* binding */ SettingsSections),
/* harmony export */   "StatsSections": () => (/* binding */ StatsSections),
/* harmony export */   "UIElementCreationMode": () => (/* binding */ UIElementCreationMode),
/* harmony export */   "isPanelEnabled": () => (/* binding */ isPanelEnabled),
/* harmony export */   "isSectionEnabled": () => (/* binding */ isSectionEnabled),
/* harmony export */   "isSettingEnabled": () => (/* binding */ isSettingEnabled)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
class ExtraFlags {
}
ExtraFlags.LightMode = 'LightMode';
/**
 * All the UI sections across all the panels.
 */
class SettingsSections {
}
SettingsSections.PixelStreaming = 'Pixel Streaming';
SettingsSections.UI = 'UI';
SettingsSections.Input = 'Input';
SettingsSections.Encoder = 'Encoder';
SettingsSections.WebRTC = 'WebRTC';
SettingsSections.Commands = 'Commands';
class StatsSections {
}
StatsSections.SessionStats = 'Session Stats';
StatsSections.LatencyStats = 'Latency Stats';
StatsSections.LatencyTest = 'Latency Test';
StatsSections.DataChannelLatencyTest = 'Data Channel Latency Test';
/** Whether a stream UI element is internally made, externally provided, or disabled. */
var UIElementCreationMode;
(function (UIElementCreationMode) {
    UIElementCreationMode[UIElementCreationMode["CreateDefaultElement"] = 0] = "CreateDefaultElement";
    UIElementCreationMode[UIElementCreationMode["UseCustomElement"] = 1] = "UseCustomElement";
    UIElementCreationMode[UIElementCreationMode["Disable"] = 2] = "Disable";
})(UIElementCreationMode || (UIElementCreationMode = {}));
function isPanelEnabled(config) {
    return !config || (!!config && config.isEnabled);
}
function isSectionEnabled(config, section) {
    return (!config ||
        (!!config &&
            (!Object.prototype.hasOwnProperty.call(config.sectionVisibility, section) ||
                (Object.prototype.hasOwnProperty.call(config.sectionVisibility, section) &&
                    config.sectionVisibility[section]))));
}
function isSettingEnabled(config, setting) {
    return (!config ||
        (!!config &&
            (!Object.prototype.hasOwnProperty.call(config.settingVisibility, setting) ||
                (Object.prototype.hasOwnProperty.call(config.settingVisibility, setting) &&
                    config.settingVisibility[setting]))));
}
//# sourceMappingURL=UIConfigurationTypes.js.map

/***/ }),

/***/ 8214:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "VideoQpIndicator": () => (/* binding */ VideoQpIndicator)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
/**
 * A UI element showing the QP (quantization parameter) of the video stream at the last encoded frame (well, last transmitted QP really).
 * A blockier encoding will have a higher QP and this will make the indicator turn more red.
 * A non-blocky stream will have a lower QP and this will make the indicator turn more green.
 * The QP indicator is represented visually using a WiFi icon.
 */
class VideoQpIndicator {
    constructor(config) {
        this.videoEncoderAvgQP = -1;
        // non html elements
        this.statsText = '';
        this.color = '';
        // qp colors
        this.orangeQP = 26;
        this.redQP = 35;
        this.config = config;
    }
    /**
     * Get the root element of the QP indicator.
     */
    get rootElement() {
        if (!this._rootElement) {
            // make the root element that contains the svg for the connection
            this._rootElement = document.createElement('div');
            this._rootElement.id = 'connection';
            this._rootElement.classList.add('UiTool');
            // add svg icon for the connection strength
            this._rootElement.appendChild(this.qualityStatus);
            // add the text underneath the connection
            this._rootElement.appendChild(this.qualityText);
            // set colors to not connected initially
            this.updateQpTooltip(-1);
        }
        return this._rootElement;
    }
    /**
     * Get the text that displays under the icon.
     */
    get qualityText() {
        if (!this._qualityText) {
            this._qualityText = document.createElement('span');
            this._qualityText.id = 'qualityText';
            this._qualityText.classList.add('tooltiptext');
        }
        return this._qualityText;
    }
    /**
     * Get the icon.
     */
    get qualityStatus() {
        if (!this._qualityStatus) {
            this._qualityStatus = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            this._qualityStatus.setAttributeNS(null, 'id', 'connectionStrength');
            this._qualityStatus.setAttributeNS(null, 'x', '0px');
            this._qualityStatus.setAttributeNS(null, 'y', '0px');
            this._qualityStatus.setAttributeNS(null, 'viewBox', '0 0 494.45 494.45');
            // build wifi icon
            this.qualityStatus.appendChild(this.dot);
            this.qualityStatus.appendChild(this.middle);
            this.qualityStatus.appendChild(this.outer);
            this.qualityStatus.appendChild(this.inner);
        }
        return this._qualityStatus;
    }
    /**
     * Get the dot at the bottom of the wifi icon.
     */
    get dot() {
        if (!this._dot) {
            this._dot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            this._dot.setAttributeNS(null, 'id', 'dot');
            this._dot.setAttributeNS(null, 'cx', '247.125');
            this._dot.setAttributeNS(null, 'cy', '398.925');
            this._dot.setAttributeNS(null, 'r', '35.3');
        }
        return this._dot;
    }
    /**
     * Get the outer arc of the wifi icon.
     */
    get outer() {
        if (!this._outer) {
            this._outer = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            this._outer.setAttributeNS(null, 'id', 'outer');
            this._outer.setAttributeNS(null, 'd', 'M467.925,204.625c-6.8,0-13.5-2.6-18.7-7.8c-111.5-111.4-292.7-111.4-404.1,0c-10.3,10.3-27.1,10.3-37.4,0s-10.3-27.1,0-37.4c64-64,149-99.2,239.5-99.2s175.5,35.2,239.5,99.2c10.3,10.3,10.3,27.1,0,37.4C481.425,202.025,474.625,204.625,467.925,204.625z');
        }
        return this._outer;
    }
    /**
     * Get the middle arc of the wifi icon.
     */
    get middle() {
        if (!this._middle) {
            this._middle = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            this._middle.setAttributeNS(null, 'id', 'middle');
            this._middle.setAttributeNS(null, 'd', 'M395.225,277.325c-6.8,0-13.5-2.6-18.7-7.8c-71.4-71.3-187.4-71.3-258.8,0c-10.3,10.3-27.1,10.3-37.4,0s-10.3-27.1,0-37.4c92-92,241.6-92,333.6,0c10.3,10.3,10.3,27.1,0,37.4C408.725,274.725,401.925,277.325,395.225,277.325z');
        }
        return this._middle;
    }
    /**
     * Get the inner arc of the wifi icon.
     */
    get inner() {
        if (!this._inner) {
            this._inner = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            this._inner.setAttributeNS(null, 'id', 'inner');
            this._inner.setAttributeNS(null, 'd', 'M323.625,348.825c-6.8,0-13.5-2.6-18.7-7.8c-15.4-15.4-36-23.9-57.8-23.9s-42.4,8.5-57.8,23.9c-10.3,10.3-27.1,10.3-37.4,0c-10.3-10.3-10.3-27.1,0-37.4c25.4-25.4,59.2-39.4,95.2-39.4s69.8,14,95.2,39.5c10.3,10.3,10.3,27.1,0,37.4C337.225,346.225,330.425,348.825,323.625,348.825z');
        }
        return this._inner;
    }
    /**
     * Used to set the speed of the status light.
     * @param speed - Set the speed of the blink, higher numbers make the status light blink faster.
     */
    blinkVideoQualityStatus(speed) {
        let iteration = speed;
        let opacity = 1;
        const tickID = setInterval(() => {
            opacity -= 0.1;
            this.qualityText.style.opacity = String(Math.abs((opacity - 0.5) * 2));
            if (opacity <= 0.1) {
                if (--iteration == 0) {
                    clearInterval(tickID);
                }
                else {
                    opacity = 1;
                }
            }
        }, 100 / speed);
    }
    /**
     * updates the QP tooltip by converting the Video Encoder QP to a color light
     * @param QP - The video encoder QP number needed to find the average
     */
    updateQpTooltip(QP) {
        var _a;
        this.videoEncoderAvgQP = QP;
        if (QP > this.redQP) {
            this.color = 'red';
            this.blinkVideoQualityStatus(2);
            this.statsText = `<div style="color: ${this.color}">Poor encoding quality</div>`;
            this.outer.setAttributeNS(null, 'fill', '#3c3b40');
            this.middle.setAttributeNS(null, 'fill', '#3c3b40');
            this.inner.setAttributeNS(null, 'fill', this.color);
            this.dot.setAttributeNS(null, 'fill', this.color);
        }
        else if (QP > this.orangeQP) {
            this.color = 'orange';
            this.blinkVideoQualityStatus(1);
            this.statsText = `<div style="color: ${this.color}">Blocky encoding quality</div>`;
            this.outer.setAttributeNS(null, 'fill', '#3c3b40');
            this.middle.setAttributeNS(null, 'fill', this.color);
            this.inner.setAttributeNS(null, 'fill', this.color);
            this.dot.setAttributeNS(null, 'fill', this.color);
        }
        else if (QP <= 0) {
            this.color = '#b0b0b0';
            this.outer.setAttributeNS(null, 'fill', '#3c3b40');
            this.middle.setAttributeNS(null, 'fill', '#3c3b40');
            this.inner.setAttributeNS(null, 'fill', '#3c3b40');
            this.dot.setAttributeNS(null, 'fill', '#3c3b40');
            this.statsText = `<div style="color: ${this.color}">Not connected</div>`;
        }
        else {
            this.color = 'lime';
            this.qualityStatus.style.opacity = ((_a = this.config) === null || _a === void 0 ? void 0 : _a.hideWhenGood) == true ? '0' : '1';
            this.statsText = `<div style="color: ${this.color}">Clear encoding quality</div>`;
            this.outer.setAttributeNS(null, 'fill', this.color);
            this.middle.setAttributeNS(null, 'fill', this.color);
            this.inner.setAttributeNS(null, 'fill', this.color);
            this.dot.setAttributeNS(null, 'fill', this.color);
        }
        this.qualityText.innerHTML = this.statsText;
    }
}
//# sourceMappingURL=VideoQpIndicator.js.map

/***/ }),

/***/ 221:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "XRIcon": () => (/* binding */ XRIcon)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
/**
 * XR icon that can be clicked.
 */
class XRIcon {
    /**
     * Get the the button containing the XR icon.
     */
    get rootElement() {
        if (!this._rootElement) {
            this._rootElement = document.createElement('button');
            this._rootElement.type = 'button';
            this._rootElement.classList.add('UiTool');
            this._rootElement.id = 'xrBtn';
            this._rootElement.appendChild(this.xrIcon);
            this._rootElement.appendChild(this.tooltipText);
        }
        return this._rootElement;
    }
    get tooltipText() {
        if (!this._tooltipText) {
            this._tooltipText = document.createElement('span');
            this._tooltipText.classList.add('tooltiptext');
            this._tooltipText.innerHTML = 'XR';
        }
        return this._tooltipText;
    }
    get xrIcon() {
        if (!this._xrIcon) {
            this._xrIcon = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            this._xrIcon.setAttributeNS(null, 'id', 'xrIcon');
            this._xrIcon.setAttributeNS(null, 'x', '0px');
            this._xrIcon.setAttributeNS(null, 'y', '0px');
            this._xrIcon.setAttributeNS(null, 'viewBox', '0 0 100 100');
            // create svg group for the paths
            const svgGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            svgGroup.classList.add('svgIcon');
            this._xrIcon.appendChild(svgGroup);
            // create paths for the icon itself, the path of the xr headset
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.setAttributeNS(null, 'd', 'M29 41c-5 0-9 4-9 9s4 9 9 9 9-4 9-9-4-9-9-9zm0 14c-2.8 0-5-2.2-5-5s2.2-5 5-5 5 2.2 5 5-2.2 5-5 5zm42-14c-5 0-9 4-9 9s4 9 9 9 9-4 9-9-4-9-9-9zm0 14c-2.8 0-5-2.2-5-5s2.2-5 5-5 5 2.2 5 5-2.2 5-5 5zm12-31H17c-6.6 0-12 5.4-12 12v28c0 6.6 5.4 12 12 12h14.5c3.5 0 6.8-1.5 9-4.1l3.5-4c1.5-1.7 3.7-2.7 6-2.7s4.5 1 6 2.7l3.5 4c2.3 2.6 5.6 4.1 9 4.1H83c6.6 0 12-5.4 12-12V36c0-6.6-5.4-12-12-12zm8 40c0 4.4-3.6 8-8 8H68.5c-2.3 0-4.5-1-6-2.7l-3.5-4c-2.3-2.6-5.6-4.1-9-4.1-3.5 0-6.8 1.5-9 4.1l-3.5 4C36 71 33.8 72 31.5 72H17c-4.4 0-8-3.6-8-8V36c0-4.4 3.6-8 8-8h66c4.4 0 8 3.6 8 8v28z');
            svgGroup.appendChild(path);
        }
        return this._xrIcon;
    }
}
//# sourceMappingURL=XRIcon.js.map

/***/ }),

/***/ 7336:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MathUtils": () => (/* binding */ MathUtils)
/* harmony export */ });
// Copyright Epic Games, Inc. All Rights Reserved.
class MathUtils {
    /**
     * formats Bytes coming in for video stats
     * @param bytes - number to convert
     * @param decimals - number of decimal places
     */
    static formatBytes(bytes, decimals) {
        if (bytes === 0) {
            return '0';
        }
        const factor = 1024;
        const dm = decimals < 0 ? 0 : decimals;
        const sizes = ['Bytes', 'KiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB', 'ZiB', 'YiB'];
        const i = Math.floor(Math.log(bytes) / Math.log(factor));
        return parseFloat((bytes / Math.pow(factor, i)).toFixed(dm)) + ' ' + sizes[i];
    }
}
//# sourceMappingURL=MathUtils.js.map

/***/ }),

/***/ 4366:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AFKOverlay": () => (/* reexport safe */ _Overlay_AFKOverlay__WEBPACK_IMPORTED_MODULE_2__.AFKOverlay),
/* harmony export */   "ActionOverlay": () => (/* reexport safe */ _Overlay_ActionOverlay__WEBPACK_IMPORTED_MODULE_3__.ActionOverlay),
/* harmony export */   "Application": () => (/* reexport safe */ _Application_Application__WEBPACK_IMPORTED_MODULE_0__.Application),
/* harmony export */   "ConfigUI": () => (/* reexport safe */ _Config_ConfigUI__WEBPACK_IMPORTED_MODULE_11__.ConfigUI),
/* harmony export */   "ConnectOverlay": () => (/* reexport safe */ _Overlay_ConnectOverlay__WEBPACK_IMPORTED_MODULE_5__.ConnectOverlay),
/* harmony export */   "DisconnectOverlay": () => (/* reexport safe */ _Overlay_DisconnectOverlay__WEBPACK_IMPORTED_MODULE_6__.DisconnectOverlay),
/* harmony export */   "ErrorOverlay": () => (/* reexport safe */ _Overlay_ErrorOverlay__WEBPACK_IMPORTED_MODULE_7__.ErrorOverlay),
/* harmony export */   "InfoOverlay": () => (/* reexport safe */ _Overlay_InfoOverlay__WEBPACK_IMPORTED_MODULE_8__.InfoOverlay),
/* harmony export */   "OverlayBase": () => (/* reexport safe */ _Overlay_BaseOverlay__WEBPACK_IMPORTED_MODULE_4__.OverlayBase),
/* harmony export */   "PixelStreamingApplicationStyle": () => (/* reexport safe */ _Styles_PixelStreamingApplicationStyles__WEBPACK_IMPORTED_MODULE_1__.PixelStreamingApplicationStyle),
/* harmony export */   "PlayOverlay": () => (/* reexport safe */ _Overlay_PlayOverlay__WEBPACK_IMPORTED_MODULE_9__.PlayOverlay),
/* harmony export */   "SettingUIBase": () => (/* reexport safe */ _Config_SettingUIBase__WEBPACK_IMPORTED_MODULE_12__.SettingUIBase),
/* harmony export */   "SettingUIFlag": () => (/* reexport safe */ _Config_SettingUIFlag__WEBPACK_IMPORTED_MODULE_13__.SettingUIFlag),
/* harmony export */   "SettingUINumber": () => (/* reexport safe */ _Config_SettingUINumber__WEBPACK_IMPORTED_MODULE_14__.SettingUINumber),
/* harmony export */   "SettingUIOption": () => (/* reexport safe */ _Config_SettingUIOption__WEBPACK_IMPORTED_MODULE_15__.SettingUIOption),
/* harmony export */   "SettingUIText": () => (/* reexport safe */ _Config_SettingUIText__WEBPACK_IMPORTED_MODULE_16__.SettingUIText),
/* harmony export */   "TextOverlay": () => (/* reexport safe */ _Overlay_TextOverlay__WEBPACK_IMPORTED_MODULE_10__.TextOverlay),
/* harmony export */   "UIElementCreationMode": () => (/* reexport safe */ _UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_17__.UIElementCreationMode)
/* harmony export */ });
/* harmony import */ var _Application_Application__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2092);
/* harmony import */ var _Styles_PixelStreamingApplicationStyles__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3579);
/* harmony import */ var _Overlay_AFKOverlay__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7484);
/* harmony import */ var _Overlay_ActionOverlay__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(9202);
/* harmony import */ var _Overlay_BaseOverlay__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(3843);
/* harmony import */ var _Overlay_ConnectOverlay__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(2256);
/* harmony import */ var _Overlay_DisconnectOverlay__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(3825);
/* harmony import */ var _Overlay_ErrorOverlay__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(3089);
/* harmony import */ var _Overlay_InfoOverlay__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(3912);
/* harmony import */ var _Overlay_PlayOverlay__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(2475);
/* harmony import */ var _Overlay_TextOverlay__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(8714);
/* harmony import */ var _Config_ConfigUI__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(489);
/* harmony import */ var _Config_SettingUIBase__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(6564);
/* harmony import */ var _Config_SettingUIFlag__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(2396);
/* harmony import */ var _Config_SettingUINumber__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(768);
/* harmony import */ var _Config_SettingUIOption__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(6223);
/* harmony import */ var _Config_SettingUIText__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(3652);
/* harmony import */ var _UI_UIConfigurationTypes__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(58);
// Copyright Epic Games, Inc. All Rights Reserved.


















//# sourceMappingURL=pixelstreamingfrontend-ui.js.map

/***/ }),

/***/ 9920:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "assert": () => (/* binding */ assert),
/* harmony export */   "assertFloat32": () => (/* binding */ assertFloat32),
/* harmony export */   "assertInt32": () => (/* binding */ assertInt32),
/* harmony export */   "assertNever": () => (/* binding */ assertNever),
/* harmony export */   "assertUInt32": () => (/* binding */ assertUInt32)
/* harmony export */ });
/**
 * assert that condition is true or throw error (with message)
 */
function assert(condition, msg) {
    if (!condition) {
        throw new Error(msg);
    }
}
/**
 * assert that value cannot exist = type `never`. throw runtime error if it does.
 */
function assertNever(value, msg) {
    throw new Error(msg !== null && msg !== void 0 ? msg : 'Unexpected object: ' + value);
}
const FLOAT32_MAX = 3.4028234663852886e+38, FLOAT32_MIN = -3.4028234663852886e+38, UINT32_MAX = 0xFFFFFFFF, INT32_MAX = 0X7FFFFFFF, INT32_MIN = -0X80000000;
function assertInt32(arg) {
    if (typeof arg !== "number")
        throw new Error('invalid int 32: ' + typeof arg);
    if (!Number.isInteger(arg) || arg > INT32_MAX || arg < INT32_MIN)
        throw new Error('invalid int 32: ' + arg);
}
function assertUInt32(arg) {
    if (typeof arg !== "number")
        throw new Error('invalid uint 32: ' + typeof arg);
    if (!Number.isInteger(arg) || arg > UINT32_MAX || arg < 0)
        throw new Error('invalid uint 32: ' + arg);
}
function assertFloat32(arg) {
    if (typeof arg !== "number")
        throw new Error('invalid float 32: ' + typeof arg);
    if (!Number.isFinite(arg))
        return;
    if (arg > FLOAT32_MAX || arg < FLOAT32_MIN)
        throw new Error('invalid float 32: ' + arg);
}


/***/ }),

/***/ 8668:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "base64decode": () => (/* binding */ base64decode),
/* harmony export */   "base64encode": () => (/* binding */ base64encode)
/* harmony export */ });
// lookup table from base64 character to byte
let encTable = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');
// lookup table from base64 character *code* to byte because lookup by number is fast
let decTable = [];
for (let i = 0; i < encTable.length; i++)
    decTable[encTable[i].charCodeAt(0)] = i;
// support base64url variants
decTable["-".charCodeAt(0)] = encTable.indexOf("+");
decTable["_".charCodeAt(0)] = encTable.indexOf("/");
/**
 * Decodes a base64 string to a byte array.
 *
 * - ignores white-space, including line breaks and tabs
 * - allows inner padding (can decode concatenated base64 strings)
 * - does not require padding
 * - understands base64url encoding:
 *   "-" instead of "+",
 *   "_" instead of "/",
 *   no padding
 */
function base64decode(base64Str) {
    // estimate byte size, not accounting for inner padding and whitespace
    let es = base64Str.length * 3 / 4;
    // if (es % 3 !== 0)
    // throw new Error('invalid base64 string');
    if (base64Str[base64Str.length - 2] == '=')
        es -= 2;
    else if (base64Str[base64Str.length - 1] == '=')
        es -= 1;
    let bytes = new Uint8Array(es), bytePos = 0, // position in byte array
    groupPos = 0, // position in base64 group
    b, // current byte
    p = 0 // previous byte
    ;
    for (let i = 0; i < base64Str.length; i++) {
        b = decTable[base64Str.charCodeAt(i)];
        if (b === undefined) {
            // noinspection FallThroughInSwitchStatementJS
            switch (base64Str[i]) {
                case '=':
                    groupPos = 0; // reset state when padding found
                case '\n':
                case '\r':
                case '\t':
                case ' ':
                    continue; // skip white-space, and padding
                default:
                    throw Error(`invalid base64 string.`);
            }
        }
        switch (groupPos) {
            case 0:
                p = b;
                groupPos = 1;
                break;
            case 1:
                bytes[bytePos++] = p << 2 | (b & 48) >> 4;
                p = b;
                groupPos = 2;
                break;
            case 2:
                bytes[bytePos++] = (p & 15) << 4 | (b & 60) >> 2;
                p = b;
                groupPos = 3;
                break;
            case 3:
                bytes[bytePos++] = (p & 3) << 6 | b;
                groupPos = 0;
                break;
        }
    }
    if (groupPos == 1)
        throw Error(`invalid base64 string.`);
    return bytes.subarray(0, bytePos);
}
/**
 * Encodes a byte array to a base64 string.
 * Adds padding at the end.
 * Does not insert newlines.
 */
function base64encode(bytes) {
    let base64 = '', groupPos = 0, // position in base64 group
    b, // current byte
    p = 0; // carry over from previous byte
    for (let i = 0; i < bytes.length; i++) {
        b = bytes[i];
        switch (groupPos) {
            case 0:
                base64 += encTable[b >> 2];
                p = (b & 3) << 4;
                groupPos = 1;
                break;
            case 1:
                base64 += encTable[p | b >> 4];
                p = (b & 15) << 2;
                groupPos = 2;
                break;
            case 2:
                base64 += encTable[p | b >> 6];
                base64 += encTable[b & 63];
                groupPos = 0;
                break;
        }
    }
    // padding required?
    if (groupPos) {
        base64 += encTable[p];
        base64 += '=';
        if (groupPos == 1)
            base64 += '=';
    }
    return base64;
}


/***/ }),

/***/ 299:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "UnknownFieldHandler": () => (/* binding */ UnknownFieldHandler),
/* harmony export */   "WireType": () => (/* binding */ WireType),
/* harmony export */   "mergeBinaryOptions": () => (/* binding */ mergeBinaryOptions)
/* harmony export */ });
/**
 * This handler implements the default behaviour for unknown fields.
 * When reading data, unknown fields are stored on the message, in a
 * symbol property.
 * When writing data, the symbol property is queried and unknown fields
 * are serialized into the output again.
 */
var UnknownFieldHandler;
(function (UnknownFieldHandler) {
    /**
     * The symbol used to store unknown fields for a message.
     * The property must conform to `UnknownFieldContainer`.
     */
    UnknownFieldHandler.symbol = Symbol.for("protobuf-ts/unknown");
    /**
     * Store an unknown field during binary read directly on the message.
     * This method is compatible with `BinaryReadOptions.readUnknownField`.
     */
    UnknownFieldHandler.onRead = (typeName, message, fieldNo, wireType, data) => {
        let container = is(message) ? message[UnknownFieldHandler.symbol] : message[UnknownFieldHandler.symbol] = [];
        container.push({ no: fieldNo, wireType, data });
    };
    /**
     * Write unknown fields stored for the message to the writer.
     * This method is compatible with `BinaryWriteOptions.writeUnknownFields`.
     */
    UnknownFieldHandler.onWrite = (typeName, message, writer) => {
        for (let { no, wireType, data } of UnknownFieldHandler.list(message))
            writer.tag(no, wireType).raw(data);
    };
    /**
     * List unknown fields stored for the message.
     * Note that there may be multiples fields with the same number.
     */
    UnknownFieldHandler.list = (message, fieldNo) => {
        if (is(message)) {
            let all = message[UnknownFieldHandler.symbol];
            return fieldNo ? all.filter(uf => uf.no == fieldNo) : all;
        }
        return [];
    };
    /**
     * Returns the last unknown field by field number.
     */
    UnknownFieldHandler.last = (message, fieldNo) => UnknownFieldHandler.list(message, fieldNo).slice(-1)[0];
    const is = (message) => message && Array.isArray(message[UnknownFieldHandler.symbol]);
})(UnknownFieldHandler || (UnknownFieldHandler = {}));
/**
 * Merges binary write or read options. Later values override earlier values.
 */
function mergeBinaryOptions(a, b) {
    return Object.assign(Object.assign({}, a), b);
}
/**
 * Protobuf binary format wire types.
 *
 * A wire type provides just enough information to find the length of the
 * following value.
 *
 * See https://developers.google.com/protocol-buffers/docs/encoding#structure
 */
var WireType;
(function (WireType) {
    /**
     * Used for int32, int64, uint32, uint64, sint32, sint64, bool, enum
     */
    WireType[WireType["Varint"] = 0] = "Varint";
    /**
     * Used for fixed64, sfixed64, double.
     * Always 8 bytes with little-endian byte order.
     */
    WireType[WireType["Bit64"] = 1] = "Bit64";
    /**
     * Used for string, bytes, embedded messages, packed repeated fields
     *
     * Only repeated numeric types (types which use the varint, 32-bit,
     * or 64-bit wire types) can be packed. In proto3, such fields are
     * packed by default.
     */
    WireType[WireType["LengthDelimited"] = 2] = "LengthDelimited";
    /**
     * Used for groups
     * @deprecated
     */
    WireType[WireType["StartGroup"] = 3] = "StartGroup";
    /**
     * Used for groups
     * @deprecated
     */
    WireType[WireType["EndGroup"] = 4] = "EndGroup";
    /**
     * Used for fixed32, sfixed32, float.
     * Always 4 bytes with little-endian byte order.
     */
    WireType[WireType["Bit32"] = 5] = "Bit32";
})(WireType || (WireType = {}));


/***/ }),

/***/ 5383:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BinaryReader": () => (/* binding */ BinaryReader),
/* harmony export */   "binaryReadOptions": () => (/* binding */ binaryReadOptions)
/* harmony export */ });
/* harmony import */ var _binary_format_contract__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(299);
/* harmony import */ var _pb_long__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(766);
/* harmony import */ var _goog_varint__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7493);



const defaultsRead = {
    readUnknownField: true,
    readerFactory: bytes => new BinaryReader(bytes),
};
/**
 * Make options for reading binary data form partial options.
 */
function binaryReadOptions(options) {
    return options ? Object.assign(Object.assign({}, defaultsRead), options) : defaultsRead;
}
class BinaryReader {
    constructor(buf, textDecoder) {
        this.varint64 = _goog_varint__WEBPACK_IMPORTED_MODULE_0__.varint64read; // dirty cast for `this`
        /**
         * Read a `uint32` field, an unsigned 32 bit varint.
         */
        this.uint32 = _goog_varint__WEBPACK_IMPORTED_MODULE_0__.varint32read; // dirty cast for `this` and access to protected `buf`
        this.buf = buf;
        this.len = buf.length;
        this.pos = 0;
        this.view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
        this.textDecoder = textDecoder !== null && textDecoder !== void 0 ? textDecoder : new TextDecoder("utf-8", {
            fatal: true,
            ignoreBOM: true,
        });
    }
    /**
     * Reads a tag - field number and wire type.
     */
    tag() {
        let tag = this.uint32(), fieldNo = tag >>> 3, wireType = tag & 7;
        if (fieldNo <= 0 || wireType < 0 || wireType > 5)
            throw new Error("illegal tag: field no " + fieldNo + " wire type " + wireType);
        return [fieldNo, wireType];
    }
    /**
     * Skip one element on the wire and return the skipped data.
     * Supports WireType.StartGroup since v2.0.0-alpha.23.
     */
    skip(wireType) {
        let start = this.pos;
        // noinspection FallThroughInSwitchStatementJS
        switch (wireType) {
            case _binary_format_contract__WEBPACK_IMPORTED_MODULE_1__.WireType.Varint:
                while (this.buf[this.pos++] & 0x80) {
                    // ignore
                }
                break;
            case _binary_format_contract__WEBPACK_IMPORTED_MODULE_1__.WireType.Bit64:
                this.pos += 4;
            case _binary_format_contract__WEBPACK_IMPORTED_MODULE_1__.WireType.Bit32:
                this.pos += 4;
                break;
            case _binary_format_contract__WEBPACK_IMPORTED_MODULE_1__.WireType.LengthDelimited:
                let len = this.uint32();
                this.pos += len;
                break;
            case _binary_format_contract__WEBPACK_IMPORTED_MODULE_1__.WireType.StartGroup:
                // From descriptor.proto: Group type is deprecated, not supported in proto3.
                // But we must still be able to parse and treat as unknown.
                let t;
                while ((t = this.tag()[1]) !== _binary_format_contract__WEBPACK_IMPORTED_MODULE_1__.WireType.EndGroup) {
                    this.skip(t);
                }
                break;
            default:
                throw new Error("cant skip wire type " + wireType);
        }
        this.assertBounds();
        return this.buf.subarray(start, this.pos);
    }
    /**
     * Throws error if position in byte array is out of range.
     */
    assertBounds() {
        if (this.pos > this.len)
            throw new RangeError("premature EOF");
    }
    /**
     * Read a `int32` field, a signed 32 bit varint.
     */
    int32() {
        return this.uint32() | 0;
    }
    /**
     * Read a `sint32` field, a signed, zigzag-encoded 32-bit varint.
     */
    sint32() {
        let zze = this.uint32();
        // decode zigzag
        return (zze >>> 1) ^ -(zze & 1);
    }
    /**
     * Read a `int64` field, a signed 64-bit varint.
     */
    int64() {
        return new _pb_long__WEBPACK_IMPORTED_MODULE_2__.PbLong(...this.varint64());
    }
    /**
     * Read a `uint64` field, an unsigned 64-bit varint.
     */
    uint64() {
        return new _pb_long__WEBPACK_IMPORTED_MODULE_2__.PbULong(...this.varint64());
    }
    /**
     * Read a `sint64` field, a signed, zig-zag-encoded 64-bit varint.
     */
    sint64() {
        let [lo, hi] = this.varint64();
        // decode zig zag
        let s = -(lo & 1);
        lo = ((lo >>> 1 | (hi & 1) << 31) ^ s);
        hi = (hi >>> 1 ^ s);
        return new _pb_long__WEBPACK_IMPORTED_MODULE_2__.PbLong(lo, hi);
    }
    /**
     * Read a `bool` field, a variant.
     */
    bool() {
        let [lo, hi] = this.varint64();
        return lo !== 0 || hi !== 0;
    }
    /**
     * Read a `fixed32` field, an unsigned, fixed-length 32-bit integer.
     */
    fixed32() {
        return this.view.getUint32((this.pos += 4) - 4, true);
    }
    /**
     * Read a `sfixed32` field, a signed, fixed-length 32-bit integer.
     */
    sfixed32() {
        return this.view.getInt32((this.pos += 4) - 4, true);
    }
    /**
     * Read a `fixed64` field, an unsigned, fixed-length 64 bit integer.
     */
    fixed64() {
        return new _pb_long__WEBPACK_IMPORTED_MODULE_2__.PbULong(this.sfixed32(), this.sfixed32());
    }
    /**
     * Read a `fixed64` field, a signed, fixed-length 64-bit integer.
     */
    sfixed64() {
        return new _pb_long__WEBPACK_IMPORTED_MODULE_2__.PbLong(this.sfixed32(), this.sfixed32());
    }
    /**
     * Read a `float` field, 32-bit floating point number.
     */
    float() {
        return this.view.getFloat32((this.pos += 4) - 4, true);
    }
    /**
     * Read a `double` field, a 64-bit floating point number.
     */
    double() {
        return this.view.getFloat64((this.pos += 8) - 8, true);
    }
    /**
     * Read a `bytes` field, length-delimited arbitrary data.
     */
    bytes() {
        let len = this.uint32();
        let start = this.pos;
        this.pos += len;
        this.assertBounds();
        return this.buf.subarray(start, start + len);
    }
    /**
     * Read a `string` field, length-delimited data converted to UTF-8 text.
     */
    string() {
        return this.textDecoder.decode(this.bytes());
    }
}


/***/ }),

/***/ 3014:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BinaryWriter": () => (/* binding */ BinaryWriter),
/* harmony export */   "binaryWriteOptions": () => (/* binding */ binaryWriteOptions)
/* harmony export */ });
/* harmony import */ var _pb_long__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(766);
/* harmony import */ var _goog_varint__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7493);
/* harmony import */ var _assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9920);



const defaultsWrite = {
    writeUnknownFields: true,
    writerFactory: () => new BinaryWriter(),
};
/**
 * Make options for writing binary data form partial options.
 */
function binaryWriteOptions(options) {
    return options ? Object.assign(Object.assign({}, defaultsWrite), options) : defaultsWrite;
}
class BinaryWriter {
    constructor(textEncoder) {
        /**
         * Previous fork states.
         */
        this.stack = [];
        this.textEncoder = textEncoder !== null && textEncoder !== void 0 ? textEncoder : new TextEncoder();
        this.chunks = [];
        this.buf = [];
    }
    /**
     * Return all bytes written and reset this writer.
     */
    finish() {
        this.chunks.push(new Uint8Array(this.buf)); // flush the buffer
        let len = 0;
        for (let i = 0; i < this.chunks.length; i++)
            len += this.chunks[i].length;
        let bytes = new Uint8Array(len);
        let offset = 0;
        for (let i = 0; i < this.chunks.length; i++) {
            bytes.set(this.chunks[i], offset);
            offset += this.chunks[i].length;
        }
        this.chunks = [];
        return bytes;
    }
    /**
     * Start a new fork for length-delimited data like a message
     * or a packed repeated field.
     *
     * Must be joined later with `join()`.
     */
    fork() {
        this.stack.push({ chunks: this.chunks, buf: this.buf });
        this.chunks = [];
        this.buf = [];
        return this;
    }
    /**
     * Join the last fork. Write its length and bytes, then
     * return to the previous state.
     */
    join() {
        // get chunk of fork
        let chunk = this.finish();
        // restore previous state
        let prev = this.stack.pop();
        if (!prev)
            throw new Error('invalid state, fork stack empty');
        this.chunks = prev.chunks;
        this.buf = prev.buf;
        // write length of chunk as varint
        this.uint32(chunk.byteLength);
        return this.raw(chunk);
    }
    /**
     * Writes a tag (field number and wire type).
     *
     * Equivalent to `uint32( (fieldNo << 3 | type) >>> 0 )`.
     *
     * Generated code should compute the tag ahead of time and call `uint32()`.
     */
    tag(fieldNo, type) {
        return this.uint32((fieldNo << 3 | type) >>> 0);
    }
    /**
     * Write a chunk of raw bytes.
     */
    raw(chunk) {
        if (this.buf.length) {
            this.chunks.push(new Uint8Array(this.buf));
            this.buf = [];
        }
        this.chunks.push(chunk);
        return this;
    }
    /**
     * Write a `uint32` value, an unsigned 32 bit varint.
     */
    uint32(value) {
        (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assertUInt32)(value);
        // write value as varint 32, inlined for speed
        while (value > 0x7f) {
            this.buf.push((value & 0x7f) | 0x80);
            value = value >>> 7;
        }
        this.buf.push(value);
        return this;
    }
    /**
     * Write a `int32` value, a signed 32 bit varint.
     */
    int32(value) {
        (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assertInt32)(value);
        (0,_goog_varint__WEBPACK_IMPORTED_MODULE_1__.varint32write)(value, this.buf);
        return this;
    }
    /**
     * Write a `bool` value, a variant.
     */
    bool(value) {
        this.buf.push(value ? 1 : 0);
        return this;
    }
    /**
     * Write a `bytes` value, length-delimited arbitrary data.
     */
    bytes(value) {
        this.uint32(value.byteLength); // write length of chunk as varint
        return this.raw(value);
    }
    /**
     * Write a `string` value, length-delimited data converted to UTF-8 text.
     */
    string(value) {
        let chunk = this.textEncoder.encode(value);
        this.uint32(chunk.byteLength); // write length of chunk as varint
        return this.raw(chunk);
    }
    /**
     * Write a `float` value, 32-bit floating point number.
     */
    float(value) {
        (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assertFloat32)(value);
        let chunk = new Uint8Array(4);
        new DataView(chunk.buffer).setFloat32(0, value, true);
        return this.raw(chunk);
    }
    /**
     * Write a `double` value, a 64-bit floating point number.
     */
    double(value) {
        let chunk = new Uint8Array(8);
        new DataView(chunk.buffer).setFloat64(0, value, true);
        return this.raw(chunk);
    }
    /**
     * Write a `fixed32` value, an unsigned, fixed-length 32-bit integer.
     */
    fixed32(value) {
        (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assertUInt32)(value);
        let chunk = new Uint8Array(4);
        new DataView(chunk.buffer).setUint32(0, value, true);
        return this.raw(chunk);
    }
    /**
     * Write a `sfixed32` value, a signed, fixed-length 32-bit integer.
     */
    sfixed32(value) {
        (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assertInt32)(value);
        let chunk = new Uint8Array(4);
        new DataView(chunk.buffer).setInt32(0, value, true);
        return this.raw(chunk);
    }
    /**
     * Write a `sint32` value, a signed, zigzag-encoded 32-bit varint.
     */
    sint32(value) {
        (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assertInt32)(value);
        // zigzag encode
        value = ((value << 1) ^ (value >> 31)) >>> 0;
        (0,_goog_varint__WEBPACK_IMPORTED_MODULE_1__.varint32write)(value, this.buf);
        return this;
    }
    /**
     * Write a `fixed64` value, a signed, fixed-length 64-bit integer.
     */
    sfixed64(value) {
        let chunk = new Uint8Array(8);
        let view = new DataView(chunk.buffer);
        let long = _pb_long__WEBPACK_IMPORTED_MODULE_2__.PbLong.from(value);
        view.setInt32(0, long.lo, true);
        view.setInt32(4, long.hi, true);
        return this.raw(chunk);
    }
    /**
     * Write a `fixed64` value, an unsigned, fixed-length 64 bit integer.
     */
    fixed64(value) {
        let chunk = new Uint8Array(8);
        let view = new DataView(chunk.buffer);
        let long = _pb_long__WEBPACK_IMPORTED_MODULE_2__.PbULong.from(value);
        view.setInt32(0, long.lo, true);
        view.setInt32(4, long.hi, true);
        return this.raw(chunk);
    }
    /**
     * Write a `int64` value, a signed 64-bit varint.
     */
    int64(value) {
        let long = _pb_long__WEBPACK_IMPORTED_MODULE_2__.PbLong.from(value);
        (0,_goog_varint__WEBPACK_IMPORTED_MODULE_1__.varint64write)(long.lo, long.hi, this.buf);
        return this;
    }
    /**
     * Write a `sint64` value, a signed, zig-zag-encoded 64-bit varint.
     */
    sint64(value) {
        let long = _pb_long__WEBPACK_IMPORTED_MODULE_2__.PbLong.from(value), 
        // zigzag encode
        sign = long.hi >> 31, lo = (long.lo << 1) ^ sign, hi = ((long.hi << 1) | (long.lo >>> 31)) ^ sign;
        (0,_goog_varint__WEBPACK_IMPORTED_MODULE_1__.varint64write)(lo, hi, this.buf);
        return this;
    }
    /**
     * Write a `uint64` value, an unsigned 64-bit varint.
     */
    uint64(value) {
        let long = _pb_long__WEBPACK_IMPORTED_MODULE_2__.PbULong.from(value);
        (0,_goog_varint__WEBPACK_IMPORTED_MODULE_1__.varint64write)(long.lo, long.hi, this.buf);
        return this;
    }
}


/***/ }),

/***/ 7493:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "int64fromString": () => (/* binding */ int64fromString),
/* harmony export */   "int64toString": () => (/* binding */ int64toString),
/* harmony export */   "varint32read": () => (/* binding */ varint32read),
/* harmony export */   "varint32write": () => (/* binding */ varint32write),
/* harmony export */   "varint64read": () => (/* binding */ varint64read),
/* harmony export */   "varint64write": () => (/* binding */ varint64write)
/* harmony export */ });
// Copyright 2008 Google Inc.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
// * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
// * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
// * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// Code generated by the Protocol Buffer compiler is owned by the owner
// of the input file used when generating it.  This code is not
// standalone and requires a support library to be linked with it.  This
// support library is itself covered by the above license.
/**
 * Read a 64 bit varint as two JS numbers.
 *
 * Returns tuple:
 * [0]: low bits
 * [0]: high bits
 *
 * Copyright 2008 Google Inc.  All rights reserved.
 *
 * See https://github.com/protocolbuffers/protobuf/blob/8a71927d74a4ce34efe2d8769fda198f52d20d12/js/experimental/runtime/kernel/buffer_decoder.js#L175
 */
function varint64read() {
    let lowBits = 0;
    let highBits = 0;
    for (let shift = 0; shift < 28; shift += 7) {
        let b = this.buf[this.pos++];
        lowBits |= (b & 0x7F) << shift;
        if ((b & 0x80) == 0) {
            this.assertBounds();
            return [lowBits, highBits];
        }
    }
    let middleByte = this.buf[this.pos++];
    // last four bits of the first 32 bit number
    lowBits |= (middleByte & 0x0F) << 28;
    // 3 upper bits are part of the next 32 bit number
    highBits = (middleByte & 0x70) >> 4;
    if ((middleByte & 0x80) == 0) {
        this.assertBounds();
        return [lowBits, highBits];
    }
    for (let shift = 3; shift <= 31; shift += 7) {
        let b = this.buf[this.pos++];
        highBits |= (b & 0x7F) << shift;
        if ((b & 0x80) == 0) {
            this.assertBounds();
            return [lowBits, highBits];
        }
    }
    throw new Error('invalid varint');
}
/**
 * Write a 64 bit varint, given as two JS numbers, to the given bytes array.
 *
 * Copyright 2008 Google Inc.  All rights reserved.
 *
 * See https://github.com/protocolbuffers/protobuf/blob/8a71927d74a4ce34efe2d8769fda198f52d20d12/js/experimental/runtime/kernel/writer.js#L344
 */
function varint64write(lo, hi, bytes) {
    for (let i = 0; i < 28; i = i + 7) {
        const shift = lo >>> i;
        const hasNext = !((shift >>> 7) == 0 && hi == 0);
        const byte = (hasNext ? shift | 0x80 : shift) & 0xFF;
        bytes.push(byte);
        if (!hasNext) {
            return;
        }
    }
    const splitBits = ((lo >>> 28) & 0x0F) | ((hi & 0x07) << 4);
    const hasMoreBits = !((hi >> 3) == 0);
    bytes.push((hasMoreBits ? splitBits | 0x80 : splitBits) & 0xFF);
    if (!hasMoreBits) {
        return;
    }
    for (let i = 3; i < 31; i = i + 7) {
        const shift = hi >>> i;
        const hasNext = !((shift >>> 7) == 0);
        const byte = (hasNext ? shift | 0x80 : shift) & 0xFF;
        bytes.push(byte);
        if (!hasNext) {
            return;
        }
    }
    bytes.push((hi >>> 31) & 0x01);
}
// constants for binary math
const TWO_PWR_32_DBL = (1 << 16) * (1 << 16);
/**
 * Parse decimal string of 64 bit integer value as two JS numbers.
 *
 * Returns tuple:
 * [0]: minus sign?
 * [1]: low bits
 * [2]: high bits
 *
 * Copyright 2008 Google Inc.
 */
function int64fromString(dec) {
    // Check for minus sign.
    let minus = dec[0] == '-';
    if (minus)
        dec = dec.slice(1);
    // Work 6 decimal digits at a time, acting like we're converting base 1e6
    // digits to binary. This is safe to do with floating point math because
    // Number.isSafeInteger(ALL_32_BITS * 1e6) == true.
    const base = 1e6;
    let lowBits = 0;
    let highBits = 0;
    function add1e6digit(begin, end) {
        // Note: Number('') is 0.
        const digit1e6 = Number(dec.slice(begin, end));
        highBits *= base;
        lowBits = lowBits * base + digit1e6;
        // Carry bits from lowBits to highBits
        if (lowBits >= TWO_PWR_32_DBL) {
            highBits = highBits + ((lowBits / TWO_PWR_32_DBL) | 0);
            lowBits = lowBits % TWO_PWR_32_DBL;
        }
    }
    add1e6digit(-24, -18);
    add1e6digit(-18, -12);
    add1e6digit(-12, -6);
    add1e6digit(-6);
    return [minus, lowBits, highBits];
}
/**
 * Format 64 bit integer value (as two JS numbers) to decimal string.
 *
 * Copyright 2008 Google Inc.
 */
function int64toString(bitsLow, bitsHigh) {
    // Skip the expensive conversion if the number is small enough to use the
    // built-in conversions.
    if ((bitsHigh >>> 0) <= 0x1FFFFF) {
        return '' + (TWO_PWR_32_DBL * bitsHigh + (bitsLow >>> 0));
    }
    // What this code is doing is essentially converting the input number from
    // base-2 to base-1e7, which allows us to represent the 64-bit range with
    // only 3 (very large) digits. Those digits are then trivial to convert to
    // a base-10 string.
    // The magic numbers used here are -
    // 2^24 = 16777216 = (1,6777216) in base-1e7.
    // 2^48 = 281474976710656 = (2,8147497,6710656) in base-1e7.
    // Split 32:32 representation into 16:24:24 representation so our
    // intermediate digits don't overflow.
    let low = bitsLow & 0xFFFFFF;
    let mid = (((bitsLow >>> 24) | (bitsHigh << 8)) >>> 0) & 0xFFFFFF;
    let high = (bitsHigh >> 16) & 0xFFFF;
    // Assemble our three base-1e7 digits, ignoring carries. The maximum
    // value in a digit at this step is representable as a 48-bit integer, which
    // can be stored in a 64-bit floating point number.
    let digitA = low + (mid * 6777216) + (high * 6710656);
    let digitB = mid + (high * 8147497);
    let digitC = (high * 2);
    // Apply carries from A to B and from B to C.
    let base = 10000000;
    if (digitA >= base) {
        digitB += Math.floor(digitA / base);
        digitA %= base;
    }
    if (digitB >= base) {
        digitC += Math.floor(digitB / base);
        digitB %= base;
    }
    // Convert base-1e7 digits to base-10, with optional leading zeroes.
    function decimalFrom1e7(digit1e7, needLeadingZeros) {
        let partial = digit1e7 ? String(digit1e7) : '';
        if (needLeadingZeros) {
            return '0000000'.slice(partial.length) + partial;
        }
        return partial;
    }
    return decimalFrom1e7(digitC, /*needLeadingZeros=*/ 0) +
        decimalFrom1e7(digitB, /*needLeadingZeros=*/ digitC) +
        // If the final 1e7 digit didn't need leading zeros, we would have
        // returned via the trivial code path at the top.
        decimalFrom1e7(digitA, /*needLeadingZeros=*/ 1);
}
/**
 * Write a 32 bit varint, signed or unsigned. Same as `varint64write(0, value, bytes)`
 *
 * Copyright 2008 Google Inc.  All rights reserved.
 *
 * See https://github.com/protocolbuffers/protobuf/blob/1b18833f4f2a2f681f4e4a25cdf3b0a43115ec26/js/binary/encoder.js#L144
 */
function varint32write(value, bytes) {
    if (value >= 0) {
        // write value as varint 32
        while (value > 0x7f) {
            bytes.push((value & 0x7f) | 0x80);
            value = value >>> 7;
        }
        bytes.push(value);
    }
    else {
        for (let i = 0; i < 9; i++) {
            bytes.push(value & 127 | 128);
            value = value >> 7;
        }
        bytes.push(1);
    }
}
/**
 * Read an unsigned 32 bit varint.
 *
 * See https://github.com/protocolbuffers/protobuf/blob/8a71927d74a4ce34efe2d8769fda198f52d20d12/js/experimental/runtime/kernel/buffer_decoder.js#L220
 */
function varint32read() {
    let b = this.buf[this.pos++];
    let result = b & 0x7F;
    if ((b & 0x80) == 0) {
        this.assertBounds();
        return result;
    }
    b = this.buf[this.pos++];
    result |= (b & 0x7F) << 7;
    if ((b & 0x80) == 0) {
        this.assertBounds();
        return result;
    }
    b = this.buf[this.pos++];
    result |= (b & 0x7F) << 14;
    if ((b & 0x80) == 0) {
        this.assertBounds();
        return result;
    }
    b = this.buf[this.pos++];
    result |= (b & 0x7F) << 21;
    if ((b & 0x80) == 0) {
        this.assertBounds();
        return result;
    }
    // Extract only last 4 bits
    b = this.buf[this.pos++];
    result |= (b & 0x0F) << 28;
    for (let readBytes = 5; ((b & 0x80) !== 0) && readBytes < 10; readBytes++)
        b = this.buf[this.pos++];
    if ((b & 0x80) != 0)
        throw new Error('invalid varint');
    this.assertBounds();
    // Result can have 32 bits, convert it to unsigned
    return result >>> 0;
}


/***/ }),

/***/ 9557:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "jsonReadOptions": () => (/* binding */ jsonReadOptions),
/* harmony export */   "jsonWriteOptions": () => (/* binding */ jsonWriteOptions),
/* harmony export */   "mergeJsonOptions": () => (/* binding */ mergeJsonOptions)
/* harmony export */ });
const defaultsWrite = {
    emitDefaultValues: false,
    enumAsInteger: false,
    useProtoFieldName: false,
    prettySpaces: 0,
}, defaultsRead = {
    ignoreUnknownFields: false,
};
/**
 * Make options for reading JSON data from partial options.
 */
function jsonReadOptions(options) {
    return options ? Object.assign(Object.assign({}, defaultsRead), options) : defaultsRead;
}
/**
 * Make options for writing JSON data from partial options.
 */
function jsonWriteOptions(options) {
    return options ? Object.assign(Object.assign({}, defaultsWrite), options) : defaultsWrite;
}
/**
 * Merges JSON write or read options. Later values override earlier values. Type registries are merged.
 */
function mergeJsonOptions(a, b) {
    var _a, _b;
    let c = Object.assign(Object.assign({}, a), b);
    c.typeRegistry = [...((_a = a === null || a === void 0 ? void 0 : a.typeRegistry) !== null && _a !== void 0 ? _a : []), ...((_b = b === null || b === void 0 ? void 0 : b.typeRegistry) !== null && _b !== void 0 ? _b : [])];
    return c;
}


/***/ }),

/***/ 889:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isJsonObject": () => (/* binding */ isJsonObject),
/* harmony export */   "typeofJsonValue": () => (/* binding */ typeofJsonValue)
/* harmony export */ });
/**
 * Get the type of a JSON value.
 * Distinguishes between array, null and object.
 */
function typeofJsonValue(value) {
    let t = typeof value;
    if (t == "object") {
        if (Array.isArray(value))
            return "array";
        if (value === null)
            return "null";
    }
    return t;
}
/**
 * Is this a JSON object (instead of an array or null)?
 */
function isJsonObject(value) {
    return value !== null && typeof value == "object" && !Array.isArray(value);
}


/***/ }),

/***/ 1212:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "lowerCamelCase": () => (/* binding */ lowerCamelCase)
/* harmony export */ });
/**
 * Converts snake_case to lowerCamelCase.
 *
 * Should behave like protoc:
 * https://github.com/protocolbuffers/protobuf/blob/e8ae137c96444ea313485ed1118c5e43b2099cf1/src/google/protobuf/compiler/java/java_helpers.cc#L118
 */
function lowerCamelCase(snakeCase) {
    let capNext = false;
    const sb = [];
    for (let i = 0; i < snakeCase.length; i++) {
        let next = snakeCase.charAt(i);
        if (next == '_') {
            capNext = true;
        }
        else if (/\d/.test(next)) {
            sb.push(next);
            capNext = true;
        }
        else if (capNext) {
            sb.push(next.toUpperCase());
            capNext = false;
        }
        else if (i == 0) {
            sb.push(next.toLowerCase());
        }
        else {
            sb.push(next);
        }
    }
    return sb.join('');
}


/***/ }),

/***/ 3712:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MESSAGE_TYPE": () => (/* binding */ MESSAGE_TYPE)
/* harmony export */ });
/**
 * The symbol used as a key on message objects to store the message type.
 *
 * Note that this is an experimental feature - it is here to stay, but
 * implementation details may change without notice.
 */
const MESSAGE_TYPE = Symbol.for("protobuf-ts/message-type");


/***/ }),

/***/ 827:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MessageType": () => (/* binding */ MessageType)
/* harmony export */ });
/* harmony import */ var _message_type_contract__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3712);
/* harmony import */ var _reflection_info__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6304);
/* harmony import */ var _reflection_type_check__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(8125);
/* harmony import */ var _reflection_json_reader__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(8839);
/* harmony import */ var _reflection_json_writer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(4332);
/* harmony import */ var _reflection_binary_reader__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(5234);
/* harmony import */ var _reflection_binary_writer__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(9223);
/* harmony import */ var _reflection_create__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(1277);
/* harmony import */ var _reflection_merge_partial__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(4548);
/* harmony import */ var _json_typings__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(889);
/* harmony import */ var _json_format_contract__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(9557);
/* harmony import */ var _reflection_equals__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(5282);
/* harmony import */ var _binary_writer__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(3014);
/* harmony import */ var _binary_reader__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(5383);














const baseDescriptors = Object.getOwnPropertyDescriptors(Object.getPrototypeOf({}));
/**
 * This standard message type provides reflection-based
 * operations to work with a message.
 */
class MessageType {
    constructor(name, fields, options) {
        this.defaultCheckDepth = 16;
        this.typeName = name;
        this.fields = fields.map(_reflection_info__WEBPACK_IMPORTED_MODULE_0__.normalizeFieldInfo);
        this.options = options !== null && options !== void 0 ? options : {};
        this.messagePrototype = Object.create(null, Object.assign(Object.assign({}, baseDescriptors), { [_message_type_contract__WEBPACK_IMPORTED_MODULE_1__.MESSAGE_TYPE]: { value: this } }));
        this.refTypeCheck = new _reflection_type_check__WEBPACK_IMPORTED_MODULE_2__.ReflectionTypeCheck(this);
        this.refJsonReader = new _reflection_json_reader__WEBPACK_IMPORTED_MODULE_3__.ReflectionJsonReader(this);
        this.refJsonWriter = new _reflection_json_writer__WEBPACK_IMPORTED_MODULE_4__.ReflectionJsonWriter(this);
        this.refBinReader = new _reflection_binary_reader__WEBPACK_IMPORTED_MODULE_5__.ReflectionBinaryReader(this);
        this.refBinWriter = new _reflection_binary_writer__WEBPACK_IMPORTED_MODULE_6__.ReflectionBinaryWriter(this);
    }
    create(value) {
        let message = (0,_reflection_create__WEBPACK_IMPORTED_MODULE_7__.reflectionCreate)(this);
        if (value !== undefined) {
            (0,_reflection_merge_partial__WEBPACK_IMPORTED_MODULE_8__.reflectionMergePartial)(this, message, value);
        }
        return message;
    }
    /**
     * Clone the message.
     *
     * Unknown fields are discarded.
     */
    clone(message) {
        let copy = this.create();
        (0,_reflection_merge_partial__WEBPACK_IMPORTED_MODULE_8__.reflectionMergePartial)(this, copy, message);
        return copy;
    }
    /**
     * Determines whether two message of the same type have the same field values.
     * Checks for deep equality, traversing repeated fields, oneof groups, maps
     * and messages recursively.
     * Will also return true if both messages are `undefined`.
     */
    equals(a, b) {
        return (0,_reflection_equals__WEBPACK_IMPORTED_MODULE_9__.reflectionEquals)(this, a, b);
    }
    /**
     * Is the given value assignable to our message type
     * and contains no [excess properties](https://www.typescriptlang.org/docs/handbook/interfaces.html#excess-property-checks)?
     */
    is(arg, depth = this.defaultCheckDepth) {
        return this.refTypeCheck.is(arg, depth, false);
    }
    /**
     * Is the given value assignable to our message type,
     * regardless of [excess properties](https://www.typescriptlang.org/docs/handbook/interfaces.html#excess-property-checks)?
     */
    isAssignable(arg, depth = this.defaultCheckDepth) {
        return this.refTypeCheck.is(arg, depth, true);
    }
    /**
     * Copy partial data into the target message.
     */
    mergePartial(target, source) {
        (0,_reflection_merge_partial__WEBPACK_IMPORTED_MODULE_8__.reflectionMergePartial)(this, target, source);
    }
    /**
     * Create a new message from binary format.
     */
    fromBinary(data, options) {
        let opt = (0,_binary_reader__WEBPACK_IMPORTED_MODULE_10__.binaryReadOptions)(options);
        return this.internalBinaryRead(opt.readerFactory(data), data.byteLength, opt);
    }
    /**
     * Read a new message from a JSON value.
     */
    fromJson(json, options) {
        return this.internalJsonRead(json, (0,_json_format_contract__WEBPACK_IMPORTED_MODULE_11__.jsonReadOptions)(options));
    }
    /**
     * Read a new message from a JSON string.
     * This is equivalent to `T.fromJson(JSON.parse(json))`.
     */
    fromJsonString(json, options) {
        let value = JSON.parse(json);
        return this.fromJson(value, options);
    }
    /**
     * Write the message to canonical JSON value.
     */
    toJson(message, options) {
        return this.internalJsonWrite(message, (0,_json_format_contract__WEBPACK_IMPORTED_MODULE_11__.jsonWriteOptions)(options));
    }
    /**
     * Convert the message to canonical JSON string.
     * This is equivalent to `JSON.stringify(T.toJson(t))`
     */
    toJsonString(message, options) {
        var _a;
        let value = this.toJson(message, options);
        return JSON.stringify(value, null, (_a = options === null || options === void 0 ? void 0 : options.prettySpaces) !== null && _a !== void 0 ? _a : 0);
    }
    /**
     * Write the message to binary format.
     */
    toBinary(message, options) {
        let opt = (0,_binary_writer__WEBPACK_IMPORTED_MODULE_12__.binaryWriteOptions)(options);
        return this.internalBinaryWrite(message, opt.writerFactory(), opt).finish();
    }
    /**
     * This is an internal method. If you just want to read a message from
     * JSON, use `fromJson()` or `fromJsonString()`.
     *
     * Reads JSON value and merges the fields into the target
     * according to protobuf rules. If the target is omitted,
     * a new instance is created first.
     */
    internalJsonRead(json, options, target) {
        if (json !== null && typeof json == "object" && !Array.isArray(json)) {
            let message = target !== null && target !== void 0 ? target : this.create();
            this.refJsonReader.read(json, message, options);
            return message;
        }
        throw new Error(`Unable to parse message ${this.typeName} from JSON ${(0,_json_typings__WEBPACK_IMPORTED_MODULE_13__.typeofJsonValue)(json)}.`);
    }
    /**
     * This is an internal method. If you just want to write a message
     * to JSON, use `toJson()` or `toJsonString().
     *
     * Writes JSON value and returns it.
     */
    internalJsonWrite(message, options) {
        return this.refJsonWriter.write(message, options);
    }
    /**
     * This is an internal method. If you just want to write a message
     * in binary format, use `toBinary()`.
     *
     * Serializes the message in binary format and appends it to the given
     * writer. Returns passed writer.
     */
    internalBinaryWrite(message, writer, options) {
        this.refBinWriter.write(message, writer, options);
        return writer;
    }
    /**
     * This is an internal method. If you just want to read a message from
     * binary data, use `fromBinary()`.
     *
     * Reads data from binary format and merges the fields into
     * the target according to protobuf rules. If the target is
     * omitted, a new instance is created first.
     */
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create();
        this.refBinReader.read(reader, message, options, length);
        return message;
    }
}


/***/ }),

/***/ 3008:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "clearOneofValue": () => (/* binding */ clearOneofValue),
/* harmony export */   "getOneofValue": () => (/* binding */ getOneofValue),
/* harmony export */   "getSelectedOneofValue": () => (/* binding */ getSelectedOneofValue),
/* harmony export */   "isOneofGroup": () => (/* binding */ isOneofGroup),
/* harmony export */   "setOneofValue": () => (/* binding */ setOneofValue),
/* harmony export */   "setUnknownOneofValue": () => (/* binding */ setUnknownOneofValue)
/* harmony export */ });
/**
 * Is the given value a valid oneof group?
 *
 * We represent protobuf `oneof` as algebraic data types (ADT) in generated
 * code. But when working with messages of unknown type, the ADT does not
 * help us.
 *
 * This type guard checks if the given object adheres to the ADT rules, which
 * are as follows:
 *
 * 1) Must be an object.
 *
 * 2) Must have a "oneofKind" discriminator property.
 *
 * 3) If "oneofKind" is `undefined`, no member field is selected. The object
 * must not have any other properties.
 *
 * 4) If "oneofKind" is a `string`, the member field with this name is
 * selected.
 *
 * 5) If a member field is selected, the object must have a second property
 * with this name. The property must not be `undefined`.
 *
 * 6) No extra properties are allowed. The object has either one property
 * (no selection) or two properties (selection).
 *
 */
function isOneofGroup(any) {
    if (typeof any != 'object' || any === null || !any.hasOwnProperty('oneofKind')) {
        return false;
    }
    switch (typeof any.oneofKind) {
        case "string":
            if (any[any.oneofKind] === undefined)
                return false;
            return Object.keys(any).length == 2;
        case "undefined":
            return Object.keys(any).length == 1;
        default:
            return false;
    }
}
/**
 * Returns the value of the given field in a oneof group.
 */
function getOneofValue(oneof, kind) {
    return oneof[kind];
}
function setOneofValue(oneof, kind, value) {
    if (oneof.oneofKind !== undefined) {
        delete oneof[oneof.oneofKind];
    }
    oneof.oneofKind = kind;
    if (value !== undefined) {
        oneof[kind] = value;
    }
}
function setUnknownOneofValue(oneof, kind, value) {
    if (oneof.oneofKind !== undefined) {
        delete oneof[oneof.oneofKind];
    }
    oneof.oneofKind = kind;
    if (value !== undefined && kind !== undefined) {
        oneof[kind] = value;
    }
}
/**
 * Removes the selected field in a oneof group.
 *
 * Note that the recommended way to modify a oneof group is to set
 * a new object:
 *
 * ```ts
 * message.result = { oneofKind: undefined };
 * ```
 */
function clearOneofValue(oneof) {
    if (oneof.oneofKind !== undefined) {
        delete oneof[oneof.oneofKind];
    }
    oneof.oneofKind = undefined;
}
/**
 * Returns the selected value of the given oneof group.
 *
 * Not that the recommended way to access a oneof group is to check
 * the "oneofKind" property and let TypeScript narrow down the union
 * type for you:
 *
 * ```ts
 * if (message.result.oneofKind === "error") {
 *   message.result.error; // string
 * }
 * ```
 *
 * In the rare case you just need the value, and do not care about
 * which protobuf field is selected, you can use this function
 * for convenience.
 */
function getSelectedOneofValue(oneof) {
    if (oneof.oneofKind === undefined) {
        return undefined;
    }
    return oneof[oneof.oneofKind];
}


/***/ }),

/***/ 766:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PbLong": () => (/* binding */ PbLong),
/* harmony export */   "PbULong": () => (/* binding */ PbULong),
/* harmony export */   "detectBi": () => (/* binding */ detectBi)
/* harmony export */ });
/* harmony import */ var _goog_varint__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7493);

let BI;
function detectBi() {
    const dv = new DataView(new ArrayBuffer(8));
    const ok = globalThis.BigInt !== undefined
        && typeof dv.getBigInt64 === "function"
        && typeof dv.getBigUint64 === "function"
        && typeof dv.setBigInt64 === "function"
        && typeof dv.setBigUint64 === "function";
    BI = ok ? {
        MIN: BigInt("-9223372036854775808"),
        MAX: BigInt("9223372036854775807"),
        UMIN: BigInt("0"),
        UMAX: BigInt("18446744073709551615"),
        C: BigInt,
        V: dv,
    } : undefined;
}
detectBi();
function assertBi(bi) {
    if (!bi)
        throw new Error("BigInt unavailable, see https://github.com/timostamm/protobuf-ts/blob/v1.0.8/MANUAL.md#bigint-support");
}
// used to validate from(string) input (when bigint is unavailable)
const RE_DECIMAL_STR = /^-?[0-9]+$/;
// constants for binary math
const TWO_PWR_32_DBL = 0x100000000;
const HALF_2_PWR_32 = 0x080000000;
// base class for PbLong and PbULong provides shared code
class SharedPbLong {
    /**
     * Create a new instance with the given bits.
     */
    constructor(lo, hi) {
        this.lo = lo | 0;
        this.hi = hi | 0;
    }
    /**
     * Is this instance equal to 0?
     */
    isZero() {
        return this.lo == 0 && this.hi == 0;
    }
    /**
     * Convert to a native number.
     */
    toNumber() {
        let result = this.hi * TWO_PWR_32_DBL + (this.lo >>> 0);
        if (!Number.isSafeInteger(result))
            throw new Error("cannot convert to safe number");
        return result;
    }
}
/**
 * 64-bit unsigned integer as two 32-bit values.
 * Converts between `string`, `number` and `bigint` representations.
 */
class PbULong extends SharedPbLong {
    /**
     * Create instance from a `string`, `number` or `bigint`.
     */
    static from(value) {
        if (BI)
            // noinspection FallThroughInSwitchStatementJS
            switch (typeof value) {
                case "string":
                    if (value == "0")
                        return this.ZERO;
                    if (value == "")
                        throw new Error('string is no integer');
                    value = BI.C(value);
                case "number":
                    if (value === 0)
                        return this.ZERO;
                    value = BI.C(value);
                case "bigint":
                    if (!value)
                        return this.ZERO;
                    if (value < BI.UMIN)
                        throw new Error('signed value for ulong');
                    if (value > BI.UMAX)
                        throw new Error('ulong too large');
                    BI.V.setBigUint64(0, value, true);
                    return new PbULong(BI.V.getInt32(0, true), BI.V.getInt32(4, true));
            }
        else
            switch (typeof value) {
                case "string":
                    if (value == "0")
                        return this.ZERO;
                    value = value.trim();
                    if (!RE_DECIMAL_STR.test(value))
                        throw new Error('string is no integer');
                    let [minus, lo, hi] = (0,_goog_varint__WEBPACK_IMPORTED_MODULE_0__.int64fromString)(value);
                    if (minus)
                        throw new Error('signed value for ulong');
                    return new PbULong(lo, hi);
                case "number":
                    if (value == 0)
                        return this.ZERO;
                    if (!Number.isSafeInteger(value))
                        throw new Error('number is no integer');
                    if (value < 0)
                        throw new Error('signed value for ulong');
                    return new PbULong(value, value / TWO_PWR_32_DBL);
            }
        throw new Error('unknown value ' + typeof value);
    }
    /**
     * Convert to decimal string.
     */
    toString() {
        return BI ? this.toBigInt().toString() : (0,_goog_varint__WEBPACK_IMPORTED_MODULE_0__.int64toString)(this.lo, this.hi);
    }
    /**
     * Convert to native bigint.
     */
    toBigInt() {
        assertBi(BI);
        BI.V.setInt32(0, this.lo, true);
        BI.V.setInt32(4, this.hi, true);
        return BI.V.getBigUint64(0, true);
    }
}
/**
 * ulong 0 singleton.
 */
PbULong.ZERO = new PbULong(0, 0);
/**
 * 64-bit signed integer as two 32-bit values.
 * Converts between `string`, `number` and `bigint` representations.
 */
class PbLong extends SharedPbLong {
    /**
     * Create instance from a `string`, `number` or `bigint`.
     */
    static from(value) {
        if (BI)
            // noinspection FallThroughInSwitchStatementJS
            switch (typeof value) {
                case "string":
                    if (value == "0")
                        return this.ZERO;
                    if (value == "")
                        throw new Error('string is no integer');
                    value = BI.C(value);
                case "number":
                    if (value === 0)
                        return this.ZERO;
                    value = BI.C(value);
                case "bigint":
                    if (!value)
                        return this.ZERO;
                    if (value < BI.MIN)
                        throw new Error('signed long too small');
                    if (value > BI.MAX)
                        throw new Error('signed long too large');
                    BI.V.setBigInt64(0, value, true);
                    return new PbLong(BI.V.getInt32(0, true), BI.V.getInt32(4, true));
            }
        else
            switch (typeof value) {
                case "string":
                    if (value == "0")
                        return this.ZERO;
                    value = value.trim();
                    if (!RE_DECIMAL_STR.test(value))
                        throw new Error('string is no integer');
                    let [minus, lo, hi] = (0,_goog_varint__WEBPACK_IMPORTED_MODULE_0__.int64fromString)(value);
                    if (minus) {
                        if (hi > HALF_2_PWR_32 || (hi == HALF_2_PWR_32 && lo != 0))
                            throw new Error('signed long too small');
                    }
                    else if (hi >= HALF_2_PWR_32)
                        throw new Error('signed long too large');
                    let pbl = new PbLong(lo, hi);
                    return minus ? pbl.negate() : pbl;
                case "number":
                    if (value == 0)
                        return this.ZERO;
                    if (!Number.isSafeInteger(value))
                        throw new Error('number is no integer');
                    return value > 0
                        ? new PbLong(value, value / TWO_PWR_32_DBL)
                        : new PbLong(-value, -value / TWO_PWR_32_DBL).negate();
            }
        throw new Error('unknown value ' + typeof value);
    }
    /**
     * Do we have a minus sign?
     */
    isNegative() {
        return (this.hi & HALF_2_PWR_32) !== 0;
    }
    /**
     * Negate two's complement.
     * Invert all the bits and add one to the result.
     */
    negate() {
        let hi = ~this.hi, lo = this.lo;
        if (lo)
            lo = ~lo + 1;
        else
            hi += 1;
        return new PbLong(lo, hi);
    }
    /**
     * Convert to decimal string.
     */
    toString() {
        if (BI)
            return this.toBigInt().toString();
        if (this.isNegative()) {
            let n = this.negate();
            return '-' + (0,_goog_varint__WEBPACK_IMPORTED_MODULE_0__.int64toString)(n.lo, n.hi);
        }
        return (0,_goog_varint__WEBPACK_IMPORTED_MODULE_0__.int64toString)(this.lo, this.hi);
    }
    /**
     * Convert to native bigint.
     */
    toBigInt() {
        assertBi(BI);
        BI.V.setInt32(0, this.lo, true);
        BI.V.setInt32(4, this.hi, true);
        return BI.V.getBigInt64(0, true);
    }
}
/**
 * long 0 singleton.
 */
PbLong.ZERO = new PbLong(0, 0);


/***/ }),

/***/ 5234:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ReflectionBinaryReader": () => (/* binding */ ReflectionBinaryReader)
/* harmony export */ });
/* harmony import */ var _binary_format_contract__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(299);
/* harmony import */ var _reflection_info__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6304);
/* harmony import */ var _reflection_long_convert__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(6965);
/* harmony import */ var _reflection_scalar_default__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(4253);




/**
 * Reads proto3 messages in binary format using reflection information.
 *
 * https://developers.google.com/protocol-buffers/docs/encoding
 */
class ReflectionBinaryReader {
    constructor(info) {
        this.info = info;
    }
    prepare() {
        var _a;
        if (!this.fieldNoToField) {
            const fieldsInput = (_a = this.info.fields) !== null && _a !== void 0 ? _a : [];
            this.fieldNoToField = new Map(fieldsInput.map(field => [field.no, field]));
        }
    }
    /**
     * Reads a message from binary format into the target message.
     *
     * Repeated fields are appended. Map entries are added, overwriting
     * existing keys.
     *
     * If a message field is already present, it will be merged with the
     * new data.
     */
    read(reader, message, options, length) {
        this.prepare();
        const end = length === undefined ? reader.len : reader.pos + length;
        while (reader.pos < end) {
            // read the tag and find the field
            const [fieldNo, wireType] = reader.tag(), field = this.fieldNoToField.get(fieldNo);
            if (!field) {
                let u = options.readUnknownField;
                if (u == "throw")
                    throw new Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.info.typeName}`);
                let d = reader.skip(wireType);
                if (u !== false)
                    (u === true ? _binary_format_contract__WEBPACK_IMPORTED_MODULE_0__.UnknownFieldHandler.onRead : u)(this.info.typeName, message, fieldNo, wireType, d);
                continue;
            }
            // target object for the field we are reading
            let target = message, repeated = field.repeat, localName = field.localName;
            // if field is member of oneof ADT, use ADT as target
            if (field.oneof) {
                target = target[field.oneof];
                // if other oneof member selected, set new ADT
                if (target.oneofKind !== localName)
                    target = message[field.oneof] = {
                        oneofKind: localName
                    };
            }
            // we have handled oneof above, we just have read the value into `target[localName]`
            switch (field.kind) {
                case "scalar":
                case "enum":
                    let T = field.kind == "enum" ? _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.INT32 : field.T;
                    let L = field.kind == "scalar" ? field.L : undefined;
                    if (repeated) {
                        let arr = target[localName]; // safe to assume presence of array, oneof cannot contain repeated values
                        if (wireType == _binary_format_contract__WEBPACK_IMPORTED_MODULE_0__.WireType.LengthDelimited && T != _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.STRING && T != _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.BYTES) {
                            let e = reader.uint32() + reader.pos;
                            while (reader.pos < e)
                                arr.push(this.scalar(reader, T, L));
                        }
                        else
                            arr.push(this.scalar(reader, T, L));
                    }
                    else
                        target[localName] = this.scalar(reader, T, L);
                    break;
                case "message":
                    if (repeated) {
                        let arr = target[localName]; // safe to assume presence of array, oneof cannot contain repeated values
                        let msg = field.T().internalBinaryRead(reader, reader.uint32(), options);
                        arr.push(msg);
                    }
                    else
                        target[localName] = field.T().internalBinaryRead(reader, reader.uint32(), options, target[localName]);
                    break;
                case "map":
                    let [mapKey, mapVal] = this.mapEntry(field, reader, options);
                    // safe to assume presence of map object, oneof cannot contain repeated values
                    target[localName][mapKey] = mapVal;
                    break;
            }
        }
    }
    /**
     * Read a map field, expecting key field = 1, value field = 2
     */
    mapEntry(field, reader, options) {
        let length = reader.uint32();
        let end = reader.pos + length;
        let key = undefined; // javascript only allows number or string for object properties
        let val = undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    if (field.K == _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.BOOL)
                        key = reader.bool().toString();
                    else
                        // long types are read as string, number types are okay as number
                        key = this.scalar(reader, field.K, _reflection_info__WEBPACK_IMPORTED_MODULE_1__.LongType.STRING);
                    break;
                case 2:
                    switch (field.V.kind) {
                        case "scalar":
                            val = this.scalar(reader, field.V.T, field.V.L);
                            break;
                        case "enum":
                            val = reader.int32();
                            break;
                        case "message":
                            val = field.V.T().internalBinaryRead(reader, reader.uint32(), options);
                            break;
                    }
                    break;
                default:
                    throw new Error(`Unknown field ${fieldNo} (wire type ${wireType}) in map entry for ${this.info.typeName}#${field.name}`);
            }
        }
        if (key === undefined) {
            let keyRaw = (0,_reflection_scalar_default__WEBPACK_IMPORTED_MODULE_2__.reflectionScalarDefault)(field.K);
            key = field.K == _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.BOOL ? keyRaw.toString() : keyRaw;
        }
        if (val === undefined)
            switch (field.V.kind) {
                case "scalar":
                    val = (0,_reflection_scalar_default__WEBPACK_IMPORTED_MODULE_2__.reflectionScalarDefault)(field.V.T, field.V.L);
                    break;
                case "enum":
                    val = 0;
                    break;
                case "message":
                    val = field.V.T().create();
                    break;
            }
        return [key, val];
    }
    scalar(reader, type, longType) {
        switch (type) {
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.INT32:
                return reader.int32();
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.STRING:
                return reader.string();
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.BOOL:
                return reader.bool();
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.DOUBLE:
                return reader.double();
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.FLOAT:
                return reader.float();
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.INT64:
                return (0,_reflection_long_convert__WEBPACK_IMPORTED_MODULE_3__.reflectionLongConvert)(reader.int64(), longType);
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.UINT64:
                return (0,_reflection_long_convert__WEBPACK_IMPORTED_MODULE_3__.reflectionLongConvert)(reader.uint64(), longType);
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.FIXED64:
                return (0,_reflection_long_convert__WEBPACK_IMPORTED_MODULE_3__.reflectionLongConvert)(reader.fixed64(), longType);
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.FIXED32:
                return reader.fixed32();
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.BYTES:
                return reader.bytes();
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.UINT32:
                return reader.uint32();
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.SFIXED32:
                return reader.sfixed32();
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.SFIXED64:
                return (0,_reflection_long_convert__WEBPACK_IMPORTED_MODULE_3__.reflectionLongConvert)(reader.sfixed64(), longType);
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.SINT32:
                return reader.sint32();
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.SINT64:
                return (0,_reflection_long_convert__WEBPACK_IMPORTED_MODULE_3__.reflectionLongConvert)(reader.sint64(), longType);
        }
    }
}


/***/ }),

/***/ 9223:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ReflectionBinaryWriter": () => (/* binding */ ReflectionBinaryWriter)
/* harmony export */ });
/* harmony import */ var _binary_format_contract__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(299);
/* harmony import */ var _reflection_info__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6304);
/* harmony import */ var _assert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9920);
/* harmony import */ var _pb_long__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(766);




/**
 * Writes proto3 messages in binary format using reflection information.
 *
 * https://developers.google.com/protocol-buffers/docs/encoding
 */
class ReflectionBinaryWriter {
    constructor(info) {
        this.info = info;
    }
    prepare() {
        if (!this.fields) {
            const fieldsInput = this.info.fields ? this.info.fields.concat() : [];
            this.fields = fieldsInput.sort((a, b) => a.no - b.no);
        }
    }
    /**
     * Writes the message to binary format.
     */
    write(message, writer, options) {
        this.prepare();
        for (const field of this.fields) {
            let value, // this will be our field value, whether it is member of a oneof or not
            emitDefault, // whether we emit the default value (only true for oneof members)
            repeated = field.repeat, localName = field.localName;
            // handle oneof ADT
            if (field.oneof) {
                const group = message[field.oneof];
                if (group.oneofKind !== localName)
                    continue; // if field is not selected, skip
                value = group[localName];
                emitDefault = true;
            }
            else {
                value = message[localName];
                emitDefault = false;
            }
            // we have handled oneof above. we just have to honor `emitDefault`.
            switch (field.kind) {
                case "scalar":
                case "enum":
                    let T = field.kind == "enum" ? _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.INT32 : field.T;
                    if (repeated) {
                        (0,_assert__WEBPACK_IMPORTED_MODULE_1__.assert)(Array.isArray(value));
                        if (repeated == _reflection_info__WEBPACK_IMPORTED_MODULE_0__.RepeatType.PACKED)
                            this.packed(writer, T, field.no, value);
                        else
                            for (const item of value)
                                this.scalar(writer, T, field.no, item, true);
                    }
                    else if (value === undefined)
                        (0,_assert__WEBPACK_IMPORTED_MODULE_1__.assert)(field.opt);
                    else
                        this.scalar(writer, T, field.no, value, emitDefault || field.opt);
                    break;
                case "message":
                    if (repeated) {
                        (0,_assert__WEBPACK_IMPORTED_MODULE_1__.assert)(Array.isArray(value));
                        for (const item of value)
                            this.message(writer, options, field.T(), field.no, item);
                    }
                    else {
                        this.message(writer, options, field.T(), field.no, value);
                    }
                    break;
                case "map":
                    (0,_assert__WEBPACK_IMPORTED_MODULE_1__.assert)(typeof value == 'object' && value !== null);
                    for (const [key, val] of Object.entries(value))
                        this.mapEntry(writer, options, field, key, val);
                    break;
            }
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u === true ? _binary_format_contract__WEBPACK_IMPORTED_MODULE_2__.UnknownFieldHandler.onWrite : u)(this.info.typeName, message, writer);
    }
    mapEntry(writer, options, field, key, value) {
        writer.tag(field.no, _binary_format_contract__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited);
        writer.fork();
        // javascript only allows number or string for object properties
        // we convert from our representation to the protobuf type
        let keyValue = key;
        switch (field.K) {
            case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.INT32:
            case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.FIXED32:
            case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.UINT32:
            case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.SFIXED32:
            case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.SINT32:
                keyValue = Number.parseInt(key);
                break;
            case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.BOOL:
                (0,_assert__WEBPACK_IMPORTED_MODULE_1__.assert)(key == 'true' || key == 'false');
                keyValue = key == 'true';
                break;
        }
        // write key, expecting key field number = 1
        this.scalar(writer, field.K, 1, keyValue, true);
        // write value, expecting value field number = 2
        switch (field.V.kind) {
            case 'scalar':
                this.scalar(writer, field.V.T, 2, value, true);
                break;
            case 'enum':
                this.scalar(writer, _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.INT32, 2, value, true);
                break;
            case 'message':
                this.message(writer, options, field.V.T(), 2, value);
                break;
        }
        writer.join();
    }
    message(writer, options, handler, fieldNo, value) {
        if (value === undefined)
            return;
        handler.internalBinaryWrite(value, writer.tag(fieldNo, _binary_format_contract__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited).fork(), options);
        writer.join();
    }
    /**
     * Write a single scalar value.
     */
    scalar(writer, type, fieldNo, value, emitDefault) {
        let [wireType, method, isDefault] = this.scalarInfo(type, value);
        if (!isDefault || emitDefault) {
            writer.tag(fieldNo, wireType);
            writer[method](value);
        }
    }
    /**
     * Write an array of scalar values in packed format.
     */
    packed(writer, type, fieldNo, value) {
        if (!value.length)
            return;
        (0,_assert__WEBPACK_IMPORTED_MODULE_1__.assert)(type !== _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.BYTES && type !== _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.STRING);
        // write tag
        writer.tag(fieldNo, _binary_format_contract__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited);
        // begin length-delimited
        writer.fork();
        // write values without tags
        let [, method,] = this.scalarInfo(type);
        for (let i = 0; i < value.length; i++)
            writer[method](value[i]);
        // end length delimited
        writer.join();
    }
    /**
     * Get information for writing a scalar value.
     *
     * Returns tuple:
     * [0]: appropriate WireType
     * [1]: name of the appropriate method of IBinaryWriter
     * [2]: whether the given value is a default value
     *
     * If argument `value` is omitted, [2] is always false.
     */
    scalarInfo(type, value) {
        let t = _binary_format_contract__WEBPACK_IMPORTED_MODULE_2__.WireType.Varint;
        let m;
        let i = value === undefined;
        let d = value === 0;
        switch (type) {
            case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.INT32:
                m = "int32";
                break;
            case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.STRING:
                d = i || !value.length;
                t = _binary_format_contract__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited;
                m = "string";
                break;
            case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.BOOL:
                d = value === false;
                m = "bool";
                break;
            case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.UINT32:
                m = "uint32";
                break;
            case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.DOUBLE:
                t = _binary_format_contract__WEBPACK_IMPORTED_MODULE_2__.WireType.Bit64;
                m = "double";
                break;
            case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.FLOAT:
                t = _binary_format_contract__WEBPACK_IMPORTED_MODULE_2__.WireType.Bit32;
                m = "float";
                break;
            case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.INT64:
                d = i || _pb_long__WEBPACK_IMPORTED_MODULE_3__.PbLong.from(value).isZero();
                m = "int64";
                break;
            case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.UINT64:
                d = i || _pb_long__WEBPACK_IMPORTED_MODULE_3__.PbULong.from(value).isZero();
                m = "uint64";
                break;
            case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.FIXED64:
                d = i || _pb_long__WEBPACK_IMPORTED_MODULE_3__.PbULong.from(value).isZero();
                t = _binary_format_contract__WEBPACK_IMPORTED_MODULE_2__.WireType.Bit64;
                m = "fixed64";
                break;
            case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.BYTES:
                d = i || !value.byteLength;
                t = _binary_format_contract__WEBPACK_IMPORTED_MODULE_2__.WireType.LengthDelimited;
                m = "bytes";
                break;
            case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.FIXED32:
                t = _binary_format_contract__WEBPACK_IMPORTED_MODULE_2__.WireType.Bit32;
                m = "fixed32";
                break;
            case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.SFIXED32:
                t = _binary_format_contract__WEBPACK_IMPORTED_MODULE_2__.WireType.Bit32;
                m = "sfixed32";
                break;
            case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.SFIXED64:
                d = i || _pb_long__WEBPACK_IMPORTED_MODULE_3__.PbLong.from(value).isZero();
                t = _binary_format_contract__WEBPACK_IMPORTED_MODULE_2__.WireType.Bit64;
                m = "sfixed64";
                break;
            case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.SINT32:
                m = "sint32";
                break;
            case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.SINT64:
                d = i || _pb_long__WEBPACK_IMPORTED_MODULE_3__.PbLong.from(value).isZero();
                m = "sint64";
                break;
        }
        return [t, m, i || d];
    }
}


/***/ }),

/***/ 1277:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "reflectionCreate": () => (/* binding */ reflectionCreate)
/* harmony export */ });
/* harmony import */ var _reflection_scalar_default__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4253);
/* harmony import */ var _message_type_contract__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3712);


/**
 * Creates an instance of the generic message, using the field
 * information.
 */
function reflectionCreate(type) {
    /**
     * This ternary can be removed in the next major version.
     * The `Object.create()` code path utilizes a new `messagePrototype`
     * property on the `IMessageType` which has this same `MESSAGE_TYPE`
     * non-enumerable property on it. Doing it this way means that we only
     * pay the cost of `Object.defineProperty()` once per `IMessageType`
     * class of once per "instance". The falsy code path is only provided
     * for backwards compatibility in cases where the runtime library is
     * updated without also updating the generated code.
     */
    const msg = type.messagePrototype
        ? Object.create(type.messagePrototype)
        : Object.defineProperty({}, _message_type_contract__WEBPACK_IMPORTED_MODULE_0__.MESSAGE_TYPE, { value: type });
    for (let field of type.fields) {
        let name = field.localName;
        if (field.opt)
            continue;
        if (field.oneof)
            msg[field.oneof] = { oneofKind: undefined };
        else if (field.repeat)
            msg[name] = [];
        else
            switch (field.kind) {
                case "scalar":
                    msg[name] = (0,_reflection_scalar_default__WEBPACK_IMPORTED_MODULE_1__.reflectionScalarDefault)(field.T, field.L);
                    break;
                case "enum":
                    // we require 0 to be default value for all enums
                    msg[name] = 0;
                    break;
                case "map":
                    msg[name] = {};
                    break;
            }
    }
    return msg;
}


/***/ }),

/***/ 5282:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "reflectionEquals": () => (/* binding */ reflectionEquals)
/* harmony export */ });
/* harmony import */ var _reflection_info__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6304);

/**
 * Determines whether two message of the same type have the same field values.
 * Checks for deep equality, traversing repeated fields, oneof groups, maps
 * and messages recursively.
 * Will also return true if both messages are `undefined`.
 */
function reflectionEquals(info, a, b) {
    if (a === b)
        return true;
    if (!a || !b)
        return false;
    for (let field of info.fields) {
        let localName = field.localName;
        let val_a = field.oneof ? a[field.oneof][localName] : a[localName];
        let val_b = field.oneof ? b[field.oneof][localName] : b[localName];
        switch (field.kind) {
            case "enum":
            case "scalar":
                let t = field.kind == "enum" ? _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.INT32 : field.T;
                if (!(field.repeat
                    ? repeatedPrimitiveEq(t, val_a, val_b)
                    : primitiveEq(t, val_a, val_b)))
                    return false;
                break;
            case "map":
                if (!(field.V.kind == "message"
                    ? repeatedMsgEq(field.V.T(), objectValues(val_a), objectValues(val_b))
                    : repeatedPrimitiveEq(field.V.kind == "enum" ? _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.INT32 : field.V.T, objectValues(val_a), objectValues(val_b))))
                    return false;
                break;
            case "message":
                let T = field.T();
                if (!(field.repeat
                    ? repeatedMsgEq(T, val_a, val_b)
                    : T.equals(val_a, val_b)))
                    return false;
                break;
        }
    }
    return true;
}
const objectValues = Object.values;
function primitiveEq(type, a, b) {
    if (a === b)
        return true;
    if (type !== _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.BYTES)
        return false;
    let ba = a;
    let bb = b;
    if (ba.length !== bb.length)
        return false;
    for (let i = 0; i < ba.length; i++)
        if (ba[i] != bb[i])
            return false;
    return true;
}
function repeatedPrimitiveEq(type, a, b) {
    if (a.length !== b.length)
        return false;
    for (let i = 0; i < a.length; i++)
        if (!primitiveEq(type, a[i], b[i]))
            return false;
    return true;
}
function repeatedMsgEq(type, a, b) {
    if (a.length !== b.length)
        return false;
    for (let i = 0; i < a.length; i++)
        if (!type.equals(a[i], b[i]))
            return false;
    return true;
}


/***/ }),

/***/ 6304:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LongType": () => (/* binding */ LongType),
/* harmony export */   "RepeatType": () => (/* binding */ RepeatType),
/* harmony export */   "ScalarType": () => (/* binding */ ScalarType),
/* harmony export */   "normalizeFieldInfo": () => (/* binding */ normalizeFieldInfo),
/* harmony export */   "readFieldOption": () => (/* binding */ readFieldOption),
/* harmony export */   "readFieldOptions": () => (/* binding */ readFieldOptions),
/* harmony export */   "readMessageOption": () => (/* binding */ readMessageOption)
/* harmony export */ });
/* harmony import */ var _lower_camel_case__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1212);

/**
 * Scalar value types. This is a subset of field types declared by protobuf
 * enum google.protobuf.FieldDescriptorProto.Type The types GROUP and MESSAGE
 * are omitted, but the numerical values are identical.
 */
var ScalarType;
(function (ScalarType) {
    // 0 is reserved for errors.
    // Order is weird for historical reasons.
    ScalarType[ScalarType["DOUBLE"] = 1] = "DOUBLE";
    ScalarType[ScalarType["FLOAT"] = 2] = "FLOAT";
    // Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT64 if
    // negative values are likely.
    ScalarType[ScalarType["INT64"] = 3] = "INT64";
    ScalarType[ScalarType["UINT64"] = 4] = "UINT64";
    // Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT32 if
    // negative values are likely.
    ScalarType[ScalarType["INT32"] = 5] = "INT32";
    ScalarType[ScalarType["FIXED64"] = 6] = "FIXED64";
    ScalarType[ScalarType["FIXED32"] = 7] = "FIXED32";
    ScalarType[ScalarType["BOOL"] = 8] = "BOOL";
    ScalarType[ScalarType["STRING"] = 9] = "STRING";
    // Tag-delimited aggregate.
    // Group type is deprecated and not supported in proto3. However, Proto3
    // implementations should still be able to parse the group wire format and
    // treat group fields as unknown fields.
    // TYPE_GROUP = 10,
    // TYPE_MESSAGE = 11,  // Length-delimited aggregate.
    // New in version 2.
    ScalarType[ScalarType["BYTES"] = 12] = "BYTES";
    ScalarType[ScalarType["UINT32"] = 13] = "UINT32";
    // TYPE_ENUM = 14,
    ScalarType[ScalarType["SFIXED32"] = 15] = "SFIXED32";
    ScalarType[ScalarType["SFIXED64"] = 16] = "SFIXED64";
    ScalarType[ScalarType["SINT32"] = 17] = "SINT32";
    ScalarType[ScalarType["SINT64"] = 18] = "SINT64";
})(ScalarType || (ScalarType = {}));
/**
 * JavaScript representation of 64 bit integral types. Equivalent to the
 * field option "jstype".
 *
 * By default, protobuf-ts represents 64 bit types as `bigint`.
 *
 * You can change the default behaviour by enabling the plugin parameter
 * `long_type_string`, which will represent 64 bit types as `string`.
 *
 * Alternatively, you can change the behaviour for individual fields
 * with the field option "jstype":
 *
 * ```protobuf
 * uint64 my_field = 1 [jstype = JS_STRING];
 * uint64 other_field = 2 [jstype = JS_NUMBER];
 * ```
 */
var LongType;
(function (LongType) {
    /**
     * Use JavaScript `bigint`.
     *
     * Field option `[jstype = JS_NORMAL]`.
     */
    LongType[LongType["BIGINT"] = 0] = "BIGINT";
    /**
     * Use JavaScript `string`.
     *
     * Field option `[jstype = JS_STRING]`.
     */
    LongType[LongType["STRING"] = 1] = "STRING";
    /**
     * Use JavaScript `number`.
     *
     * Large values will loose precision.
     *
     * Field option `[jstype = JS_NUMBER]`.
     */
    LongType[LongType["NUMBER"] = 2] = "NUMBER";
})(LongType || (LongType = {}));
/**
 * Protobuf 2.1.0 introduced packed repeated fields.
 * Setting the field option `[packed = true]` enables packing.
 *
 * In proto3, all repeated fields are packed by default.
 * Setting the field option `[packed = false]` disables packing.
 *
 * Packed repeated fields are encoded with a single tag,
 * then a length-delimiter, then the element values.
 *
 * Unpacked repeated fields are encoded with a tag and
 * value for each element.
 *
 * `bytes` and `string` cannot be packed.
 */
var RepeatType;
(function (RepeatType) {
    /**
     * The field is not repeated.
     */
    RepeatType[RepeatType["NO"] = 0] = "NO";
    /**
     * The field is repeated and should be packed.
     * Invalid for `bytes` and `string`, they cannot be packed.
     */
    RepeatType[RepeatType["PACKED"] = 1] = "PACKED";
    /**
     * The field is repeated but should not be packed.
     * The only valid repeat type for repeated `bytes` and `string`.
     */
    RepeatType[RepeatType["UNPACKED"] = 2] = "UNPACKED";
})(RepeatType || (RepeatType = {}));
/**
 * Turns PartialFieldInfo into FieldInfo.
 */
function normalizeFieldInfo(field) {
    var _a, _b, _c, _d;
    field.localName = (_a = field.localName) !== null && _a !== void 0 ? _a : (0,_lower_camel_case__WEBPACK_IMPORTED_MODULE_0__.lowerCamelCase)(field.name);
    field.jsonName = (_b = field.jsonName) !== null && _b !== void 0 ? _b : (0,_lower_camel_case__WEBPACK_IMPORTED_MODULE_0__.lowerCamelCase)(field.name);
    field.repeat = (_c = field.repeat) !== null && _c !== void 0 ? _c : RepeatType.NO;
    field.opt = (_d = field.opt) !== null && _d !== void 0 ? _d : (field.repeat ? false : field.oneof ? false : field.kind == "message");
    return field;
}
/**
 * Read custom field options from a generated message type.
 *
 * @deprecated use readFieldOption()
 */
function readFieldOptions(messageType, fieldName, extensionName, extensionType) {
    var _a;
    const options = (_a = messageType.fields.find((m, i) => m.localName == fieldName || i == fieldName)) === null || _a === void 0 ? void 0 : _a.options;
    return options && options[extensionName] ? extensionType.fromJson(options[extensionName]) : undefined;
}
function readFieldOption(messageType, fieldName, extensionName, extensionType) {
    var _a;
    const options = (_a = messageType.fields.find((m, i) => m.localName == fieldName || i == fieldName)) === null || _a === void 0 ? void 0 : _a.options;
    if (!options) {
        return undefined;
    }
    const optionVal = options[extensionName];
    if (optionVal === undefined) {
        return optionVal;
    }
    return extensionType ? extensionType.fromJson(optionVal) : optionVal;
}
function readMessageOption(messageType, extensionName, extensionType) {
    const options = messageType.options;
    const optionVal = options[extensionName];
    if (optionVal === undefined) {
        return optionVal;
    }
    return extensionType ? extensionType.fromJson(optionVal) : optionVal;
}


/***/ }),

/***/ 8839:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ReflectionJsonReader": () => (/* binding */ ReflectionJsonReader)
/* harmony export */ });
/* harmony import */ var _json_typings__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(889);
/* harmony import */ var _base64__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(8668);
/* harmony import */ var _reflection_info__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6304);
/* harmony import */ var _pb_long__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(766);
/* harmony import */ var _assert__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(9920);
/* harmony import */ var _reflection_long_convert__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(6965);






/**
 * Reads proto3 messages in canonical JSON format using reflection information.
 *
 * https://developers.google.com/protocol-buffers/docs/proto3#json
 */
class ReflectionJsonReader {
    constructor(info) {
        this.info = info;
    }
    prepare() {
        var _a;
        if (this.fMap === undefined) {
            this.fMap = {};
            const fieldsInput = (_a = this.info.fields) !== null && _a !== void 0 ? _a : [];
            for (const field of fieldsInput) {
                this.fMap[field.name] = field;
                this.fMap[field.jsonName] = field;
                this.fMap[field.localName] = field;
            }
        }
    }
    // Cannot parse JSON <type of jsonValue> for <type name>#<fieldName>.
    assert(condition, fieldName, jsonValue) {
        if (!condition) {
            let what = (0,_json_typings__WEBPACK_IMPORTED_MODULE_0__.typeofJsonValue)(jsonValue);
            if (what == "number" || what == "boolean")
                what = jsonValue.toString();
            throw new Error(`Cannot parse JSON ${what} for ${this.info.typeName}#${fieldName}`);
        }
    }
    /**
     * Reads a message from canonical JSON format into the target message.
     *
     * Repeated fields are appended. Map entries are added, overwriting
     * existing keys.
     *
     * If a message field is already present, it will be merged with the
     * new data.
     */
    read(input, message, options) {
        this.prepare();
        const oneofsHandled = [];
        for (const [jsonKey, jsonValue] of Object.entries(input)) {
            const field = this.fMap[jsonKey];
            if (!field) {
                if (!options.ignoreUnknownFields)
                    throw new Error(`Found unknown field while reading ${this.info.typeName} from JSON format. JSON key: ${jsonKey}`);
                continue;
            }
            const localName = field.localName;
            // handle oneof ADT
            let target; // this will be the target for the field value, whether it is member of a oneof or not
            if (field.oneof) {
                if (jsonValue === null && (field.kind !== 'enum' || field.T()[0] !== 'google.protobuf.NullValue')) {
                    continue;
                }
                // since json objects are unordered by specification, it is not possible to take the last of multiple oneofs
                if (oneofsHandled.includes(field.oneof))
                    throw new Error(`Multiple members of the oneof group "${field.oneof}" of ${this.info.typeName} are present in JSON.`);
                oneofsHandled.push(field.oneof);
                target = message[field.oneof] = {
                    oneofKind: localName
                };
            }
            else {
                target = message;
            }
            // we have handled oneof above. we just have read the value into `target`.
            if (field.kind == 'map') {
                if (jsonValue === null) {
                    continue;
                }
                // check input
                this.assert((0,_json_typings__WEBPACK_IMPORTED_MODULE_0__.isJsonObject)(jsonValue), field.name, jsonValue);
                // our target to put map entries into
                const fieldObj = target[localName];
                // read entries
                for (const [jsonObjKey, jsonObjValue] of Object.entries(jsonValue)) {
                    this.assert(jsonObjValue !== null, field.name + " map value", null);
                    // read value
                    let val;
                    switch (field.V.kind) {
                        case "message":
                            val = field.V.T().internalJsonRead(jsonObjValue, options);
                            break;
                        case "enum":
                            val = this.enum(field.V.T(), jsonObjValue, field.name, options.ignoreUnknownFields);
                            if (val === false)
                                continue;
                            break;
                        case "scalar":
                            val = this.scalar(jsonObjValue, field.V.T, field.V.L, field.name);
                            break;
                    }
                    this.assert(val !== undefined, field.name + " map value", jsonObjValue);
                    // read key
                    let key = jsonObjKey;
                    if (field.K == _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.BOOL)
                        key = key == "true" ? true : key == "false" ? false : key;
                    key = this.scalar(key, field.K, _reflection_info__WEBPACK_IMPORTED_MODULE_1__.LongType.STRING, field.name).toString();
                    fieldObj[key] = val;
                }
            }
            else if (field.repeat) {
                if (jsonValue === null)
                    continue;
                // check input
                this.assert(Array.isArray(jsonValue), field.name, jsonValue);
                // our target to put array entries into
                const fieldArr = target[localName];
                // read array entries
                for (const jsonItem of jsonValue) {
                    this.assert(jsonItem !== null, field.name, null);
                    let val;
                    switch (field.kind) {
                        case "message":
                            val = field.T().internalJsonRead(jsonItem, options);
                            break;
                        case "enum":
                            val = this.enum(field.T(), jsonItem, field.name, options.ignoreUnknownFields);
                            if (val === false)
                                continue;
                            break;
                        case "scalar":
                            val = this.scalar(jsonItem, field.T, field.L, field.name);
                            break;
                    }
                    this.assert(val !== undefined, field.name, jsonValue);
                    fieldArr.push(val);
                }
            }
            else {
                switch (field.kind) {
                    case "message":
                        if (jsonValue === null && field.T().typeName != 'google.protobuf.Value') {
                            this.assert(field.oneof === undefined, field.name + " (oneof member)", null);
                            continue;
                        }
                        target[localName] = field.T().internalJsonRead(jsonValue, options, target[localName]);
                        break;
                    case "enum":
                        let val = this.enum(field.T(), jsonValue, field.name, options.ignoreUnknownFields);
                        if (val === false)
                            continue;
                        target[localName] = val;
                        break;
                    case "scalar":
                        target[localName] = this.scalar(jsonValue, field.T, field.L, field.name);
                        break;
                }
            }
        }
    }
    /**
     * Returns `false` for unrecognized string representations.
     *
     * google.protobuf.NullValue accepts only JSON `null` (or the old `"NULL_VALUE"`).
     */
    enum(type, json, fieldName, ignoreUnknownFields) {
        if (type[0] == 'google.protobuf.NullValue')
            (0,_assert__WEBPACK_IMPORTED_MODULE_2__.assert)(json === null || json === "NULL_VALUE", `Unable to parse field ${this.info.typeName}#${fieldName}, enum ${type[0]} only accepts null.`);
        if (json === null)
            // we require 0 to be default value for all enums
            return 0;
        switch (typeof json) {
            case "number":
                (0,_assert__WEBPACK_IMPORTED_MODULE_2__.assert)(Number.isInteger(json), `Unable to parse field ${this.info.typeName}#${fieldName}, enum can only be integral number, got ${json}.`);
                return json;
            case "string":
                let localEnumName = json;
                if (type[2] && json.substring(0, type[2].length) === type[2])
                    // lookup without the shared prefix
                    localEnumName = json.substring(type[2].length);
                let enumNumber = type[1][localEnumName];
                if (typeof enumNumber === 'undefined' && ignoreUnknownFields) {
                    return false;
                }
                (0,_assert__WEBPACK_IMPORTED_MODULE_2__.assert)(typeof enumNumber == "number", `Unable to parse field ${this.info.typeName}#${fieldName}, enum ${type[0]} has no value for "${json}".`);
                return enumNumber;
        }
        (0,_assert__WEBPACK_IMPORTED_MODULE_2__.assert)(false, `Unable to parse field ${this.info.typeName}#${fieldName}, cannot parse enum value from ${typeof json}".`);
    }
    scalar(json, type, longType, fieldName) {
        let e;
        try {
            switch (type) {
                // float, double: JSON value will be a number or one of the special string values "NaN", "Infinity", and "-Infinity".
                // Either numbers or strings are accepted. Exponent notation is also accepted.
                case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.DOUBLE:
                case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.FLOAT:
                    if (json === null)
                        return .0;
                    if (json === "NaN")
                        return Number.NaN;
                    if (json === "Infinity")
                        return Number.POSITIVE_INFINITY;
                    if (json === "-Infinity")
                        return Number.NEGATIVE_INFINITY;
                    if (json === "") {
                        e = "empty string";
                        break;
                    }
                    if (typeof json == "string" && json.trim().length !== json.length) {
                        e = "extra whitespace";
                        break;
                    }
                    if (typeof json != "string" && typeof json != "number") {
                        break;
                    }
                    let float = Number(json);
                    if (Number.isNaN(float)) {
                        e = "not a number";
                        break;
                    }
                    if (!Number.isFinite(float)) {
                        // infinity and -infinity are handled by string representation above, so this is an error
                        e = "too large or small";
                        break;
                    }
                    if (type == _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.FLOAT)
                        (0,_assert__WEBPACK_IMPORTED_MODULE_2__.assertFloat32)(float);
                    return float;
                // int32, fixed32, uint32: JSON value will be a decimal number. Either numbers or strings are accepted.
                case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.INT32:
                case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.FIXED32:
                case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.SFIXED32:
                case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.SINT32:
                case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.UINT32:
                    if (json === null)
                        return 0;
                    let int32;
                    if (typeof json == "number")
                        int32 = json;
                    else if (json === "")
                        e = "empty string";
                    else if (typeof json == "string") {
                        if (json.trim().length !== json.length)
                            e = "extra whitespace";
                        else
                            int32 = Number(json);
                    }
                    if (int32 === undefined)
                        break;
                    if (type == _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.UINT32)
                        (0,_assert__WEBPACK_IMPORTED_MODULE_2__.assertUInt32)(int32);
                    else
                        (0,_assert__WEBPACK_IMPORTED_MODULE_2__.assertInt32)(int32);
                    return int32;
                // int64, fixed64, uint64: JSON value will be a decimal string. Either numbers or strings are accepted.
                case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.INT64:
                case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.SFIXED64:
                case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.SINT64:
                    if (json === null)
                        return (0,_reflection_long_convert__WEBPACK_IMPORTED_MODULE_3__.reflectionLongConvert)(_pb_long__WEBPACK_IMPORTED_MODULE_4__.PbLong.ZERO, longType);
                    if (typeof json != "number" && typeof json != "string")
                        break;
                    return (0,_reflection_long_convert__WEBPACK_IMPORTED_MODULE_3__.reflectionLongConvert)(_pb_long__WEBPACK_IMPORTED_MODULE_4__.PbLong.from(json), longType);
                case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.FIXED64:
                case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.UINT64:
                    if (json === null)
                        return (0,_reflection_long_convert__WEBPACK_IMPORTED_MODULE_3__.reflectionLongConvert)(_pb_long__WEBPACK_IMPORTED_MODULE_4__.PbULong.ZERO, longType);
                    if (typeof json != "number" && typeof json != "string")
                        break;
                    return (0,_reflection_long_convert__WEBPACK_IMPORTED_MODULE_3__.reflectionLongConvert)(_pb_long__WEBPACK_IMPORTED_MODULE_4__.PbULong.from(json), longType);
                // bool:
                case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.BOOL:
                    if (json === null)
                        return false;
                    if (typeof json !== "boolean")
                        break;
                    return json;
                // string:
                case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.STRING:
                    if (json === null)
                        return "";
                    if (typeof json !== "string") {
                        e = "extra whitespace";
                        break;
                    }
                    try {
                        encodeURIComponent(json);
                    }
                    catch (e) {
                        e = "invalid UTF8";
                        break;
                    }
                    return json;
                // bytes: JSON value will be the data encoded as a string using standard base64 encoding with paddings.
                // Either standard or URL-safe base64 encoding with/without paddings are accepted.
                case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.BYTES:
                    if (json === null || json === "")
                        return new Uint8Array(0);
                    if (typeof json !== 'string')
                        break;
                    return (0,_base64__WEBPACK_IMPORTED_MODULE_5__.base64decode)(json);
            }
        }
        catch (error) {
            e = error.message;
        }
        this.assert(false, fieldName + (e ? " - " + e : ""), json);
    }
}


/***/ }),

/***/ 4332:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ReflectionJsonWriter": () => (/* binding */ ReflectionJsonWriter)
/* harmony export */ });
/* harmony import */ var _base64__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(8668);
/* harmony import */ var _pb_long__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(766);
/* harmony import */ var _reflection_info__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6304);
/* harmony import */ var _assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9920);




/**
 * Writes proto3 messages in canonical JSON format using reflection
 * information.
 *
 * https://developers.google.com/protocol-buffers/docs/proto3#json
 */
class ReflectionJsonWriter {
    constructor(info) {
        var _a;
        this.fields = (_a = info.fields) !== null && _a !== void 0 ? _a : [];
    }
    /**
     * Converts the message to a JSON object, based on the field descriptors.
     */
    write(message, options) {
        const json = {}, source = message;
        for (const field of this.fields) {
            // field is not part of a oneof, simply write as is
            if (!field.oneof) {
                let jsonValue = this.field(field, source[field.localName], options);
                if (jsonValue !== undefined)
                    json[options.useProtoFieldName ? field.name : field.jsonName] = jsonValue;
                continue;
            }
            // field is part of a oneof
            const group = source[field.oneof];
            if (group.oneofKind !== field.localName)
                continue; // not selected, skip
            const opt = field.kind == 'scalar' || field.kind == 'enum'
                ? Object.assign(Object.assign({}, options), { emitDefaultValues: true }) : options;
            let jsonValue = this.field(field, group[field.localName], opt);
            (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assert)(jsonValue !== undefined);
            json[options.useProtoFieldName ? field.name : field.jsonName] = jsonValue;
        }
        return json;
    }
    field(field, value, options) {
        let jsonValue = undefined;
        if (field.kind == 'map') {
            (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assert)(typeof value == "object" && value !== null);
            const jsonObj = {};
            switch (field.V.kind) {
                case "scalar":
                    for (const [entryKey, entryValue] of Object.entries(value)) {
                        const val = this.scalar(field.V.T, entryValue, field.name, false, true);
                        (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assert)(val !== undefined);
                        jsonObj[entryKey.toString()] = val; // JSON standard allows only (double quoted) string as property key
                    }
                    break;
                case "message":
                    const messageType = field.V.T();
                    for (const [entryKey, entryValue] of Object.entries(value)) {
                        const val = this.message(messageType, entryValue, field.name, options);
                        (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assert)(val !== undefined);
                        jsonObj[entryKey.toString()] = val; // JSON standard allows only (double quoted) string as property key
                    }
                    break;
                case "enum":
                    const enumInfo = field.V.T();
                    for (const [entryKey, entryValue] of Object.entries(value)) {
                        (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assert)(entryValue === undefined || typeof entryValue == 'number');
                        const val = this.enum(enumInfo, entryValue, field.name, false, true, options.enumAsInteger);
                        (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assert)(val !== undefined);
                        jsonObj[entryKey.toString()] = val; // JSON standard allows only (double quoted) string as property key
                    }
                    break;
            }
            if (options.emitDefaultValues || Object.keys(jsonObj).length > 0)
                jsonValue = jsonObj;
        }
        else if (field.repeat) {
            (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assert)(Array.isArray(value));
            const jsonArr = [];
            switch (field.kind) {
                case "scalar":
                    for (let i = 0; i < value.length; i++) {
                        const val = this.scalar(field.T, value[i], field.name, field.opt, true);
                        (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assert)(val !== undefined);
                        jsonArr.push(val);
                    }
                    break;
                case "enum":
                    const enumInfo = field.T();
                    for (let i = 0; i < value.length; i++) {
                        (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assert)(value[i] === undefined || typeof value[i] == 'number');
                        const val = this.enum(enumInfo, value[i], field.name, field.opt, true, options.enumAsInteger);
                        (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assert)(val !== undefined);
                        jsonArr.push(val);
                    }
                    break;
                case "message":
                    const messageType = field.T();
                    for (let i = 0; i < value.length; i++) {
                        const val = this.message(messageType, value[i], field.name, options);
                        (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assert)(val !== undefined);
                        jsonArr.push(val);
                    }
                    break;
            }
            // add converted array to json output
            if (options.emitDefaultValues || jsonArr.length > 0 || options.emitDefaultValues)
                jsonValue = jsonArr;
        }
        else {
            switch (field.kind) {
                case "scalar":
                    jsonValue = this.scalar(field.T, value, field.name, field.opt, options.emitDefaultValues);
                    break;
                case "enum":
                    jsonValue = this.enum(field.T(), value, field.name, field.opt, options.emitDefaultValues, options.enumAsInteger);
                    break;
                case "message":
                    jsonValue = this.message(field.T(), value, field.name, options);
                    break;
            }
        }
        return jsonValue;
    }
    /**
     * Returns `null` as the default for google.protobuf.NullValue.
     */
    enum(type, value, fieldName, optional, emitDefaultValues, enumAsInteger) {
        if (type[0] == 'google.protobuf.NullValue')
            return !emitDefaultValues && !optional ? undefined : null;
        if (value === undefined) {
            (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assert)(optional);
            return undefined;
        }
        if (value === 0 && !emitDefaultValues && !optional)
            // we require 0 to be default value for all enums
            return undefined;
        (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assert)(typeof value == 'number');
        (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assert)(Number.isInteger(value));
        if (enumAsInteger || !type[1].hasOwnProperty(value))
            // if we don't now the enum value, just return the number
            return value;
        if (type[2])
            // restore the dropped prefix
            return type[2] + type[1][value];
        return type[1][value];
    }
    message(type, value, fieldName, options) {
        if (value === undefined)
            return options.emitDefaultValues ? null : undefined;
        return type.internalJsonWrite(value, options);
    }
    scalar(type, value, fieldName, optional, emitDefaultValues) {
        if (value === undefined) {
            (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assert)(optional);
            return undefined;
        }
        const ed = emitDefaultValues || optional;
        // noinspection FallThroughInSwitchStatementJS
        switch (type) {
            // int32, fixed32, uint32: JSON value will be a decimal number. Either numbers or strings are accepted.
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.INT32:
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.SFIXED32:
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.SINT32:
                if (value === 0)
                    return ed ? 0 : undefined;
                (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assertInt32)(value);
                return value;
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.FIXED32:
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.UINT32:
                if (value === 0)
                    return ed ? 0 : undefined;
                (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assertUInt32)(value);
                return value;
            // float, double: JSON value will be a number or one of the special string values "NaN", "Infinity", and "-Infinity".
            // Either numbers or strings are accepted. Exponent notation is also accepted.
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.FLOAT:
                (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assertFloat32)(value);
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.DOUBLE:
                if (value === 0)
                    return ed ? 0 : undefined;
                (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assert)(typeof value == 'number');
                if (Number.isNaN(value))
                    return 'NaN';
                if (value === Number.POSITIVE_INFINITY)
                    return 'Infinity';
                if (value === Number.NEGATIVE_INFINITY)
                    return '-Infinity';
                return value;
            // string:
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.STRING:
                if (value === "")
                    return ed ? '' : undefined;
                (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assert)(typeof value == 'string');
                return value;
            // bool:
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.BOOL:
                if (value === false)
                    return ed ? false : undefined;
                (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assert)(typeof value == 'boolean');
                return value;
            // JSON value will be a decimal string. Either numbers or strings are accepted.
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.UINT64:
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.FIXED64:
                (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assert)(typeof value == 'number' || typeof value == 'string' || typeof value == 'bigint');
                let ulong = _pb_long__WEBPACK_IMPORTED_MODULE_2__.PbULong.from(value);
                if (ulong.isZero() && !ed)
                    return undefined;
                return ulong.toString();
            // JSON value will be a decimal string. Either numbers or strings are accepted.
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.INT64:
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.SFIXED64:
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.SINT64:
                (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assert)(typeof value == 'number' || typeof value == 'string' || typeof value == 'bigint');
                let long = _pb_long__WEBPACK_IMPORTED_MODULE_2__.PbLong.from(value);
                if (long.isZero() && !ed)
                    return undefined;
                return long.toString();
            // bytes: JSON value will be the data encoded as a string using standard base64 encoding with paddings.
            // Either standard or URL-safe base64 encoding with/without paddings are accepted.
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.BYTES:
                (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assert)(value instanceof Uint8Array);
                if (!value.byteLength)
                    return ed ? "" : undefined;
                return (0,_base64__WEBPACK_IMPORTED_MODULE_3__.base64encode)(value);
        }
    }
}


/***/ }),

/***/ 6965:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "reflectionLongConvert": () => (/* binding */ reflectionLongConvert)
/* harmony export */ });
/* harmony import */ var _reflection_info__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6304);

/**
 * Utility method to convert a PbLong or PbUlong to a JavaScript
 * representation during runtime.
 *
 * Works with generated field information, `undefined` is equivalent
 * to `STRING`.
 */
function reflectionLongConvert(long, type) {
    switch (type) {
        case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.LongType.BIGINT:
            return long.toBigInt();
        case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.LongType.NUMBER:
            return long.toNumber();
        default:
            // case undefined:
            // case LongType.STRING:
            return long.toString();
    }
}


/***/ }),

/***/ 4548:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "reflectionMergePartial": () => (/* binding */ reflectionMergePartial)
/* harmony export */ });
/**
 * Copy partial data into the target message.
 *
 * If a singular scalar or enum field is present in the source, it
 * replaces the field in the target.
 *
 * If a singular message field is present in the source, it is merged
 * with the target field by calling mergePartial() of the responsible
 * message type.
 *
 * If a repeated field is present in the source, its values replace
 * all values in the target array, removing extraneous values.
 * Repeated message fields are copied, not merged.
 *
 * If a map field is present in the source, entries are added to the
 * target map, replacing entries with the same key. Entries that only
 * exist in the target remain. Entries with message values are copied,
 * not merged.
 *
 * Note that this function differs from protobuf merge semantics,
 * which appends repeated fields.
 */
function reflectionMergePartial(info, target, source) {
    let fieldValue, // the field value we are working with
    input = source, output; // where we want our field value to go
    for (let field of info.fields) {
        let name = field.localName;
        if (field.oneof) {
            const group = input[field.oneof]; // this is the oneof`s group in the source
            if ((group === null || group === void 0 ? void 0 : group.oneofKind) == undefined) { // the user is free to omit
                continue; // we skip this field, and all other members too
            }
            fieldValue = group[name]; // our value comes from the the oneof group of the source
            output = target[field.oneof]; // and our output is the oneof group of the target
            output.oneofKind = group.oneofKind; // always update discriminator
            if (fieldValue == undefined) {
                delete output[name]; // remove any existing value
                continue; // skip further work on field
            }
        }
        else {
            fieldValue = input[name]; // we are using the source directly
            output = target; // we want our field value to go directly into the target
            if (fieldValue == undefined) {
                continue; // skip further work on field, existing value is used as is
            }
        }
        if (field.repeat)
            output[name].length = fieldValue.length; // resize target array to match source array
        // now we just work with `fieldValue` and `output` to merge the value
        switch (field.kind) {
            case "scalar":
            case "enum":
                if (field.repeat)
                    for (let i = 0; i < fieldValue.length; i++)
                        output[name][i] = fieldValue[i]; // not a reference type
                else
                    output[name] = fieldValue; // not a reference type
                break;
            case "message":
                let T = field.T();
                if (field.repeat)
                    for (let i = 0; i < fieldValue.length; i++)
                        output[name][i] = T.create(fieldValue[i]);
                else if (output[name] === undefined)
                    output[name] = T.create(fieldValue); // nothing to merge with
                else
                    T.mergePartial(output[name], fieldValue);
                break;
            case "map":
                // Map and repeated fields are simply overwritten, not appended or merged
                switch (field.V.kind) {
                    case "scalar":
                    case "enum":
                        Object.assign(output[name], fieldValue); // elements are not reference types
                        break;
                    case "message":
                        let T = field.V.T();
                        for (let k of Object.keys(fieldValue))
                            output[name][k] = T.create(fieldValue[k]);
                        break;
                }
                break;
        }
    }
}


/***/ }),

/***/ 4253:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "reflectionScalarDefault": () => (/* binding */ reflectionScalarDefault)
/* harmony export */ });
/* harmony import */ var _reflection_info__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6304);
/* harmony import */ var _reflection_long_convert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6965);
/* harmony import */ var _pb_long__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(766);



/**
 * Creates the default value for a scalar type.
 */
function reflectionScalarDefault(type, longType = _reflection_info__WEBPACK_IMPORTED_MODULE_0__.LongType.STRING) {
    switch (type) {
        case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.BOOL:
            return false;
        case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.UINT64:
        case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.FIXED64:
            return (0,_reflection_long_convert__WEBPACK_IMPORTED_MODULE_1__.reflectionLongConvert)(_pb_long__WEBPACK_IMPORTED_MODULE_2__.PbULong.ZERO, longType);
        case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.INT64:
        case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.SFIXED64:
        case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.SINT64:
            return (0,_reflection_long_convert__WEBPACK_IMPORTED_MODULE_1__.reflectionLongConvert)(_pb_long__WEBPACK_IMPORTED_MODULE_2__.PbLong.ZERO, longType);
        case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.DOUBLE:
        case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.FLOAT:
            return 0.0;
        case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.BYTES:
            return new Uint8Array(0);
        case _reflection_info__WEBPACK_IMPORTED_MODULE_0__.ScalarType.STRING:
            return "";
        default:
            // case ScalarType.INT32:
            // case ScalarType.UINT32:
            // case ScalarType.SINT32:
            // case ScalarType.FIXED32:
            // case ScalarType.SFIXED32:
            return 0;
    }
}


/***/ }),

/***/ 8125:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ReflectionTypeCheck": () => (/* binding */ ReflectionTypeCheck)
/* harmony export */ });
/* harmony import */ var _reflection_info__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6304);
/* harmony import */ var _oneof__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3008);


// noinspection JSMethodCanBeStatic
class ReflectionTypeCheck {
    constructor(info) {
        var _a;
        this.fields = (_a = info.fields) !== null && _a !== void 0 ? _a : [];
    }
    prepare() {
        if (this.data)
            return;
        const req = [], known = [], oneofs = [];
        for (let field of this.fields) {
            if (field.oneof) {
                if (!oneofs.includes(field.oneof)) {
                    oneofs.push(field.oneof);
                    req.push(field.oneof);
                    known.push(field.oneof);
                }
            }
            else {
                known.push(field.localName);
                switch (field.kind) {
                    case "scalar":
                    case "enum":
                        if (!field.opt || field.repeat)
                            req.push(field.localName);
                        break;
                    case "message":
                        if (field.repeat)
                            req.push(field.localName);
                        break;
                    case "map":
                        req.push(field.localName);
                        break;
                }
            }
        }
        this.data = { req, known, oneofs: Object.values(oneofs) };
    }
    /**
     * Is the argument a valid message as specified by the
     * reflection information?
     *
     * Checks all field types recursively. The `depth`
     * specifies how deep into the structure the check will be.
     *
     * With a depth of 0, only the presence of fields
     * is checked.
     *
     * With a depth of 1 or more, the field types are checked.
     *
     * With a depth of 2 or more, the members of map, repeated
     * and message fields are checked.
     *
     * Message fields will be checked recursively with depth - 1.
     *
     * The number of map entries / repeated values being checked
     * is < depth.
     */
    is(message, depth, allowExcessProperties = false) {
        if (depth < 0)
            return true;
        if (message === null || message === undefined || typeof message != 'object')
            return false;
        this.prepare();
        let keys = Object.keys(message), data = this.data;
        // if a required field is missing in arg, this cannot be a T
        if (keys.length < data.req.length || data.req.some(n => !keys.includes(n)))
            return false;
        if (!allowExcessProperties) {
            // if the arg contains a key we dont know, this is not a literal T
            if (keys.some(k => !data.known.includes(k)))
                return false;
        }
        // "With a depth of 0, only the presence and absence of fields is checked."
        // "With a depth of 1 or more, the field types are checked."
        if (depth < 1) {
            return true;
        }
        // check oneof group
        for (const name of data.oneofs) {
            const group = message[name];
            if (!(0,_oneof__WEBPACK_IMPORTED_MODULE_0__.isOneofGroup)(group))
                return false;
            if (group.oneofKind === undefined)
                continue;
            const field = this.fields.find(f => f.localName === group.oneofKind);
            if (!field)
                return false; // we found no field, but have a kind, something is wrong
            if (!this.field(group[group.oneofKind], field, allowExcessProperties, depth))
                return false;
        }
        // check types
        for (const field of this.fields) {
            if (field.oneof !== undefined)
                continue;
            if (!this.field(message[field.localName], field, allowExcessProperties, depth))
                return false;
        }
        return true;
    }
    field(arg, field, allowExcessProperties, depth) {
        let repeated = field.repeat;
        switch (field.kind) {
            case "scalar":
                if (arg === undefined)
                    return field.opt;
                if (repeated)
                    return this.scalars(arg, field.T, depth, field.L);
                return this.scalar(arg, field.T, field.L);
            case "enum":
                if (arg === undefined)
                    return field.opt;
                if (repeated)
                    return this.scalars(arg, _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.INT32, depth);
                return this.scalar(arg, _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.INT32);
            case "message":
                if (arg === undefined)
                    return true;
                if (repeated)
                    return this.messages(arg, field.T(), allowExcessProperties, depth);
                return this.message(arg, field.T(), allowExcessProperties, depth);
            case "map":
                if (typeof arg != 'object' || arg === null)
                    return false;
                if (depth < 2)
                    return true;
                if (!this.mapKeys(arg, field.K, depth))
                    return false;
                switch (field.V.kind) {
                    case "scalar":
                        return this.scalars(Object.values(arg), field.V.T, depth, field.V.L);
                    case "enum":
                        return this.scalars(Object.values(arg), _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.INT32, depth);
                    case "message":
                        return this.messages(Object.values(arg), field.V.T(), allowExcessProperties, depth);
                }
                break;
        }
        return true;
    }
    message(arg, type, allowExcessProperties, depth) {
        if (allowExcessProperties) {
            return type.isAssignable(arg, depth);
        }
        return type.is(arg, depth);
    }
    messages(arg, type, allowExcessProperties, depth) {
        if (!Array.isArray(arg))
            return false;
        if (depth < 2)
            return true;
        if (allowExcessProperties) {
            for (let i = 0; i < arg.length && i < depth; i++)
                if (!type.isAssignable(arg[i], depth - 1))
                    return false;
        }
        else {
            for (let i = 0; i < arg.length && i < depth; i++)
                if (!type.is(arg[i], depth - 1))
                    return false;
        }
        return true;
    }
    scalar(arg, type, longType) {
        let argType = typeof arg;
        switch (type) {
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.UINT64:
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.FIXED64:
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.INT64:
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.SFIXED64:
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.SINT64:
                switch (longType) {
                    case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.LongType.BIGINT:
                        return argType == "bigint";
                    case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.LongType.NUMBER:
                        return argType == "number" && !isNaN(arg);
                    default:
                        return argType == "string";
                }
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.BOOL:
                return argType == 'boolean';
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.STRING:
                return argType == 'string';
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.BYTES:
                return arg instanceof Uint8Array;
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.DOUBLE:
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.FLOAT:
                return argType == 'number' && !isNaN(arg);
            default:
                // case ScalarType.UINT32:
                // case ScalarType.FIXED32:
                // case ScalarType.INT32:
                // case ScalarType.SINT32:
                // case ScalarType.SFIXED32:
                return argType == 'number' && Number.isInteger(arg);
        }
    }
    scalars(arg, type, depth, longType) {
        if (!Array.isArray(arg))
            return false;
        if (depth < 2)
            return true;
        if (Array.isArray(arg))
            for (let i = 0; i < arg.length && i < depth; i++)
                if (!this.scalar(arg[i], type, longType))
                    return false;
        return true;
    }
    mapKeys(map, type, depth) {
        let keys = Object.keys(map);
        switch (type) {
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.INT32:
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.FIXED32:
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.SFIXED32:
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.SINT32:
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.UINT32:
                return this.scalars(keys.slice(0, depth).map(k => parseInt(k)), type, depth);
            case _reflection_info__WEBPACK_IMPORTED_MODULE_1__.ScalarType.BOOL:
                return this.scalars(keys.slice(0, depth).map(k => k == 'true' ? true : k == 'false' ? false : k), type, depth);
            default:
                return this.scalars(keys, type, depth, _reflection_info__WEBPACK_IMPORTED_MODULE_1__.LongType.STRING);
        }
    }
}


/***/ }),

/***/ 3882:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ requiredArgs)
/* harmony export */ });
function requiredArgs(required, args) {
  if (args.length < required) {
    throw new TypeError(required + ' argument' + (required > 1 ? 's' : '') + ' required, but only ' + args.length + ' present');
  }
}

/***/ }),

/***/ 3946:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ toInteger)
/* harmony export */ });
function toInteger(dirtyNumber) {
  if (dirtyNumber === null || dirtyNumber === true || dirtyNumber === false) {
    return NaN;
  }
  var number = Number(dirtyNumber);
  if (isNaN(number)) {
    return number;
  }
  return number < 0 ? Math.ceil(number) : Math.floor(number);
}

/***/ }),

/***/ 1820:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ addMilliseconds)
/* harmony export */ });
/* harmony import */ var _lib_toInteger_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3946);
/* harmony import */ var _toDate_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9013);
/* harmony import */ var _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3882);



/**
 * @name addMilliseconds
 * @category Millisecond Helpers
 * @summary Add the specified number of milliseconds to the given date.
 *
 * @description
 * Add the specified number of milliseconds to the given date.
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} amount - the amount of milliseconds to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
 * @returns {Date} the new date with the milliseconds added
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Add 750 milliseconds to 10 July 2014 12:45:30.000:
 * const result = addMilliseconds(new Date(2014, 6, 10, 12, 45, 30, 0), 750)
 * //=> Thu Jul 10 2014 12:45:30.750
 */
function addMilliseconds(dirtyDate, dirtyAmount) {
  (0,_lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(2, arguments);
  var timestamp = (0,_toDate_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyDate).getTime();
  var amount = (0,_lib_toInteger_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(dirtyAmount);
  return new Date(timestamp + amount);
}

/***/ }),

/***/ 1973:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ addSeconds)
/* harmony export */ });
/* harmony import */ var _lib_toInteger_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3946);
/* harmony import */ var _addMilliseconds_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(1820);
/* harmony import */ var _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3882);



/**
 * @name addSeconds
 * @category Second Helpers
 * @summary Add the specified number of seconds to the given date.
 *
 * @description
 * Add the specified number of seconds to the given date.
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} amount - the amount of seconds to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
 * @returns {Date} the new date with the seconds added
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Add 30 seconds to 10 July 2014 12:45:00:
 * const result = addSeconds(new Date(2014, 6, 10, 12, 45, 0), 30)
 * //=> Thu Jul 10 2014 12:45:30
 */
function addSeconds(dirtyDate, dirtyAmount) {
  (0,_lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(2, arguments);
  var amount = (0,_lib_toInteger_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyAmount);
  return (0,_addMilliseconds_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(dirtyDate, amount * 1000);
}

/***/ }),

/***/ 313:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isBefore)
/* harmony export */ });
/* harmony import */ var _toDate_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9013);
/* harmony import */ var _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3882);


/**
 * @name isBefore
 * @category Common Helpers
 * @summary Is the first date before the second one?
 *
 * @description
 * Is the first date before the second one?
 *
 * @param {Date|Number} date - the date that should be before the other one to return true
 * @param {Date|Number} dateToCompare - the date to compare with
 * @returns {Boolean} the first date is before the second date
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Is 10 July 1989 before 11 February 1987?
 * const result = isBefore(new Date(1989, 6, 10), new Date(1987, 1, 11))
 * //=> false
 */
function isBefore(dirtyDate, dirtyDateToCompare) {
  (0,_lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(2, arguments);
  var date = (0,_toDate_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyDate);
  var dateToCompare = (0,_toDate_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyDateToCompare);
  return date.getTime() < dateToCompare.getTime();
}

/***/ }),

/***/ 9013:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ toDate)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1002);
/* harmony import */ var _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3882);


/**
 * @name toDate
 * @category Common Helpers
 * @summary Convert the given argument to an instance of Date.
 *
 * @description
 * Convert the given argument to an instance of Date.
 *
 * If the argument is an instance of Date, the function returns its clone.
 *
 * If the argument is a number, it is treated as a timestamp.
 *
 * If the argument is none of the above, the function returns Invalid Date.
 *
 * **Note**: *all* Date arguments passed to any *date-fns* function is processed by `toDate`.
 *
 * @param {Date|Number} argument - the value to convert
 * @returns {Date} the parsed date in the local time zone
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Clone the date:
 * const result = toDate(new Date(2014, 1, 11, 11, 30, 30))
 * //=> Tue Feb 11 2014 11:30:30
 *
 * @example
 * // Convert the timestamp to date:
 * const result = toDate(1392098430000)
 * //=> Tue Feb 11 2014 11:30:30
 */
function toDate(argument) {
  (0,_lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(1, arguments);
  var argStr = Object.prototype.toString.call(argument);

  // Clone the date
  if (argument instanceof Date || (0,_babel_runtime_helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_1__["default"])(argument) === 'object' && argStr === '[object Date]') {
    // Prevent the date to lose the milliseconds when passed to new Date() in IE10
    return new Date(argument.getTime());
  } else if (typeof argument === 'number' || argStr === '[object Number]') {
    return new Date(argument);
  } else {
    if ((typeof argument === 'string' || argStr === '[object String]') && typeof console !== 'undefined') {
      // eslint-disable-next-line no-console
      console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#string-arguments");
      // eslint-disable-next-line no-console
      console.warn(new Error().stack);
    }
    return new Date(NaN);
  }
}

/***/ }),

/***/ 5477:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* eslint-disable no-var, prefer-template */
var uppercasePattern = /[A-Z]/g
var msPattern = /^ms-/
var cache = {}

function toHyphenLower(match) {
  return '-' + match.toLowerCase()
}

function hyphenateStyleName(name) {
  if (cache.hasOwnProperty(name)) {
    return cache[name]
  }

  var hName = name.replace(uppercasePattern, toHyphenLower)
  return (cache[name] = msPattern.test(hName) ? '-' + hName : hName)
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (hyphenateStyleName);


/***/ }),

/***/ 3827:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "isBrowser": () => (/* binding */ isBrowser)
/* harmony export */ });
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var isBrowser = (typeof window === "undefined" ? "undefined" : _typeof(window)) === "object" && (typeof document === "undefined" ? "undefined" : _typeof(document)) === 'object' && document.nodeType === 9;

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isBrowser);


/***/ }),

/***/ 314:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var hyphenate_style_name__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5477);


/**
 * Convert camel cased property names to dash separated.
 */

function convertCase(style) {
  var converted = {};

  for (var prop in style) {
    var key = prop.indexOf('--') === 0 ? prop : (0,hyphenate_style_name__WEBPACK_IMPORTED_MODULE_0__["default"])(prop);
    converted[key] = style[prop];
  }

  if (style.fallbacks) {
    if (Array.isArray(style.fallbacks)) converted.fallbacks = style.fallbacks.map(convertCase);else converted.fallbacks = convertCase(style.fallbacks);
  }

  return converted;
}
/**
 * Allow camel cased property names by converting them back to dasherized.
 */


function camelCase() {
  function onProcessStyle(style) {
    if (Array.isArray(style)) {
      // Handle rules like @font-face, which can have multiple styles in an array
      for (var index = 0; index < style.length; index++) {
        style[index] = convertCase(style[index]);
      }

      return style;
    }

    return convertCase(style);
  }

  function onChangeValue(value, prop, rule) {
    if (prop.indexOf('--') === 0) {
      return value;
    }

    var hyphenatedProp = (0,hyphenate_style_name__WEBPACK_IMPORTED_MODULE_0__["default"])(prop); // There was no camel case in place

    if (prop === hyphenatedProp) return value;
    rule.prop(hyphenatedProp, value); // Core will ignore that property value we set the proper one above.

    return null;
  }

  return {
    onProcessStyle: onProcessStyle,
    onChangeValue: onChangeValue
  };
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (camelCase);


/***/ }),

/***/ 5019:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7462);
/* harmony import */ var jss__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4013);



var at = '@global';
var atPrefix = '@global ';

var GlobalContainerRule =
/*#__PURE__*/
function () {
  function GlobalContainerRule(key, styles, options) {
    this.type = 'global';
    this.at = at;
    this.isProcessed = false;
    this.key = key;
    this.options = options;
    this.rules = new jss__WEBPACK_IMPORTED_MODULE_0__.RuleList((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_1__["default"])({}, options, {
      parent: this
    }));

    for (var selector in styles) {
      this.rules.add(selector, styles[selector]);
    }

    this.rules.process();
  }
  /**
   * Get a rule.
   */


  var _proto = GlobalContainerRule.prototype;

  _proto.getRule = function getRule(name) {
    return this.rules.get(name);
  }
  /**
   * Create and register rule, run plugins.
   */
  ;

  _proto.addRule = function addRule(name, style, options) {
    var rule = this.rules.add(name, style, options);
    if (rule) this.options.jss.plugins.onProcessRule(rule);
    return rule;
  }
  /**
   * Replace rule, run plugins.
   */
  ;

  _proto.replaceRule = function replaceRule(name, style, options) {
    var newRule = this.rules.replace(name, style, options);
    if (newRule) this.options.jss.plugins.onProcessRule(newRule);
    return newRule;
  }
  /**
   * Get index of a rule.
   */
  ;

  _proto.indexOf = function indexOf(rule) {
    return this.rules.indexOf(rule);
  }
  /**
   * Generates a CSS string.
   */
  ;

  _proto.toString = function toString(options) {
    return this.rules.toString(options);
  };

  return GlobalContainerRule;
}();

var GlobalPrefixedRule =
/*#__PURE__*/
function () {
  function GlobalPrefixedRule(key, style, options) {
    this.type = 'global';
    this.at = at;
    this.isProcessed = false;
    this.key = key;
    this.options = options;
    var selector = key.substr(atPrefix.length);
    this.rule = options.jss.createRule(selector, style, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_1__["default"])({}, options, {
      parent: this
    }));
  }

  var _proto2 = GlobalPrefixedRule.prototype;

  _proto2.toString = function toString(options) {
    return this.rule ? this.rule.toString(options) : '';
  };

  return GlobalPrefixedRule;
}();

var separatorRegExp = /\s*,\s*/g;

function addScope(selector, scope) {
  var parts = selector.split(separatorRegExp);
  var scoped = '';

  for (var i = 0; i < parts.length; i++) {
    scoped += scope + " " + parts[i].trim();
    if (parts[i + 1]) scoped += ', ';
  }

  return scoped;
}

function handleNestedGlobalContainerRule(rule, sheet) {
  var options = rule.options,
      style = rule.style;
  var rules = style ? style[at] : null;
  if (!rules) return;

  for (var name in rules) {
    sheet.addRule(name, rules[name], (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_1__["default"])({}, options, {
      selector: addScope(name, rule.selector)
    }));
  }

  delete style[at];
}

function handlePrefixedGlobalRule(rule, sheet) {
  var options = rule.options,
      style = rule.style;

  for (var prop in style) {
    if (prop[0] !== '@' || prop.substr(0, at.length) !== at) continue;
    var selector = addScope(prop.substr(at.length), rule.selector);
    sheet.addRule(selector, style[prop], (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_1__["default"])({}, options, {
      selector: selector
    }));
    delete style[prop];
  }
}
/**
 * Convert nested rules to separate, remove them from original styles.
 */


function jssGlobal() {
  function onCreateRule(name, styles, options) {
    if (!name) return null;

    if (name === at) {
      return new GlobalContainerRule(name, styles, options);
    }

    if (name[0] === '@' && name.substr(0, atPrefix.length) === atPrefix) {
      return new GlobalPrefixedRule(name, styles, options);
    }

    var parent = options.parent;

    if (parent) {
      if (parent.type === 'global' || parent.options.parent && parent.options.parent.type === 'global') {
        options.scoped = false;
      }
    }

    if (!options.selector && options.scoped === false) {
      options.selector = name;
    }

    return null;
  }

  function onProcessRule(rule, sheet) {
    if (rule.type !== 'style' || !sheet) return;
    handleNestedGlobalContainerRule(rule, sheet);
    handlePrefixedGlobalRule(rule, sheet);
  }

  return {
    onCreateRule: onCreateRule,
    onProcessRule: onProcessRule
  };
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (jssGlobal);


/***/ }),

/***/ 4013:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RuleList": () => (/* binding */ RuleList),
/* harmony export */   "SheetsManager": () => (/* binding */ SheetsManager),
/* harmony export */   "SheetsRegistry": () => (/* binding */ SheetsRegistry),
/* harmony export */   "create": () => (/* binding */ createJss),
/* harmony export */   "createGenerateId": () => (/* binding */ createGenerateId),
/* harmony export */   "createRule": () => (/* binding */ createRule),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "getDynamicStyles": () => (/* binding */ getDynamicStyles),
/* harmony export */   "hasCSSTOMSupport": () => (/* binding */ hasCSSTOMSupport),
/* harmony export */   "sheets": () => (/* binding */ sheets),
/* harmony export */   "toCssValue": () => (/* binding */ toCssValue)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(7462);
/* harmony import */ var is_in_browser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3827);
/* harmony import */ var tiny_warning__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(5298);
/* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(3144);
/* harmony import */ var _babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4578);
/* harmony import */ var _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7326);
/* harmony import */ var _babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(3366);








var plainObjectConstrurctor = {}.constructor;
function cloneStyle(style) {
  if (style == null || typeof style !== 'object') return style;
  if (Array.isArray(style)) return style.map(cloneStyle);
  if (style.constructor !== plainObjectConstrurctor) return style;
  var newStyle = {};

  for (var name in style) {
    newStyle[name] = cloneStyle(style[name]);
  }

  return newStyle;
}

/**
 * Create a rule instance.
 */

function createRule(name, decl, options) {
  if (name === void 0) {
    name = 'unnamed';
  }

  var jss = options.jss;
  var declCopy = cloneStyle(decl);
  var rule = jss.plugins.onCreateRule(name, declCopy, options);
  if (rule) return rule; // It is an at-rule and it has no instance.

  if (name[0] === '@') {
     false ? 0 : void 0;
  }

  return null;
}

var join = function join(value, by) {
  var result = '';

  for (var i = 0; i < value.length; i++) {
    // Remove !important from the value, it will be readded later.
    if (value[i] === '!important') break;
    if (result) result += by;
    result += value[i];
  }

  return result;
};
/**
 * Converts JSS array value to a CSS string.
 *
 * `margin: [['5px', '10px']]` > `margin: 5px 10px;`
 * `border: ['1px', '2px']` > `border: 1px, 2px;`
 * `margin: [['5px', '10px'], '!important']` > `margin: 5px 10px !important;`
 * `color: ['red', !important]` > `color: red !important;`
 */


var toCssValue = function toCssValue(value) {
  if (!Array.isArray(value)) return value;
  var cssValue = ''; // Support space separated values via `[['5px', '10px']]`.

  if (Array.isArray(value[0])) {
    for (var i = 0; i < value.length; i++) {
      if (value[i] === '!important') break;
      if (cssValue) cssValue += ', ';
      cssValue += join(value[i], ' ');
    }
  } else cssValue = join(value, ', '); // Add !important, because it was ignored.


  if (value[value.length - 1] === '!important') {
    cssValue += ' !important';
  }

  return cssValue;
};

function getWhitespaceSymbols(options) {
  if (options && options.format === false) {
    return {
      linebreak: '',
      space: ''
    };
  }

  return {
    linebreak: '\n',
    space: ' '
  };
}

/**
 * Indent a string.
 * http://jsperf.com/array-join-vs-for
 */

function indentStr(str, indent) {
  var result = '';

  for (var index = 0; index < indent; index++) {
    result += '  ';
  }

  return result + str;
}
/**
 * Converts a Rule to CSS string.
 */


function toCss(selector, style, options) {
  if (options === void 0) {
    options = {};
  }

  var result = '';
  if (!style) return result;
  var _options = options,
      _options$indent = _options.indent,
      indent = _options$indent === void 0 ? 0 : _options$indent;
  var fallbacks = style.fallbacks;

  if (options.format === false) {
    indent = -Infinity;
  }

  var _getWhitespaceSymbols = getWhitespaceSymbols(options),
      linebreak = _getWhitespaceSymbols.linebreak,
      space = _getWhitespaceSymbols.space;

  if (selector) indent++; // Apply fallbacks first.

  if (fallbacks) {
    // Array syntax {fallbacks: [{prop: value}]}
    if (Array.isArray(fallbacks)) {
      for (var index = 0; index < fallbacks.length; index++) {
        var fallback = fallbacks[index];

        for (var prop in fallback) {
          var value = fallback[prop];

          if (value != null) {
            if (result) result += linebreak;
            result += indentStr(prop + ":" + space + toCssValue(value) + ";", indent);
          }
        }
      }
    } else {
      // Object syntax {fallbacks: {prop: value}}
      for (var _prop in fallbacks) {
        var _value = fallbacks[_prop];

        if (_value != null) {
          if (result) result += linebreak;
          result += indentStr(_prop + ":" + space + toCssValue(_value) + ";", indent);
        }
      }
    }
  }

  for (var _prop2 in style) {
    var _value2 = style[_prop2];

    if (_value2 != null && _prop2 !== 'fallbacks') {
      if (result) result += linebreak;
      result += indentStr(_prop2 + ":" + space + toCssValue(_value2) + ";", indent);
    }
  } // Allow empty style in this case, because properties will be added dynamically.


  if (!result && !options.allowEmpty) return result; // When rule is being stringified before selector was defined.

  if (!selector) return result;
  indent--;
  if (result) result = "" + linebreak + result + linebreak;
  return indentStr("" + selector + space + "{" + result, indent) + indentStr('}', indent);
}

var escapeRegex = /([[\].#*$><+~=|^:(),"'`\s])/g;
var nativeEscape = typeof CSS !== 'undefined' && CSS.escape;
var escape = (function (str) {
  return nativeEscape ? nativeEscape(str) : str.replace(escapeRegex, '\\$1');
});

var BaseStyleRule =
/*#__PURE__*/
function () {
  function BaseStyleRule(key, style, options) {
    this.type = 'style';
    this.isProcessed = false;
    var sheet = options.sheet,
        Renderer = options.Renderer;
    this.key = key;
    this.options = options;
    this.style = style;
    if (sheet) this.renderer = sheet.renderer;else if (Renderer) this.renderer = new Renderer();
  }
  /**
   * Get or set a style property.
   */


  var _proto = BaseStyleRule.prototype;

  _proto.prop = function prop(name, value, options) {
    // It's a getter.
    if (value === undefined) return this.style[name]; // Don't do anything if the value has not changed.

    var force = options ? options.force : false;
    if (!force && this.style[name] === value) return this;
    var newValue = value;

    if (!options || options.process !== false) {
      newValue = this.options.jss.plugins.onChangeValue(value, name, this);
    }

    var isEmpty = newValue == null || newValue === false;
    var isDefined = name in this.style; // Value is empty and wasn't defined before.

    if (isEmpty && !isDefined && !force) return this; // We are going to remove this value.

    var remove = isEmpty && isDefined;
    if (remove) delete this.style[name];else this.style[name] = newValue; // Renderable is defined if StyleSheet option `link` is true.

    if (this.renderable && this.renderer) {
      if (remove) this.renderer.removeProperty(this.renderable, name);else this.renderer.setProperty(this.renderable, name, newValue);
      return this;
    }

    var sheet = this.options.sheet;

    if (sheet && sheet.attached) {
       false ? 0 : void 0;
    }

    return this;
  };

  return BaseStyleRule;
}();
var StyleRule =
/*#__PURE__*/
function (_BaseStyleRule) {
  (0,_babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_1__["default"])(StyleRule, _BaseStyleRule);

  function StyleRule(key, style, options) {
    var _this;

    _this = _BaseStyleRule.call(this, key, style, options) || this;
    var selector = options.selector,
        scoped = options.scoped,
        sheet = options.sheet,
        generateId = options.generateId;

    if (selector) {
      _this.selectorText = selector;
    } else if (scoped !== false) {
      _this.id = generateId((0,_babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__["default"])((0,_babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__["default"])(_this)), sheet);
      _this.selectorText = "." + escape(_this.id);
    }

    return _this;
  }
  /**
   * Set selector string.
   * Attention: use this with caution. Most browsers didn't implement
   * selectorText setter, so this may result in rerendering of entire Style Sheet.
   */


  var _proto2 = StyleRule.prototype;

  /**
   * Apply rule to an element inline.
   */
  _proto2.applyTo = function applyTo(renderable) {
    var renderer = this.renderer;

    if (renderer) {
      var json = this.toJSON();

      for (var prop in json) {
        renderer.setProperty(renderable, prop, json[prop]);
      }
    }

    return this;
  }
  /**
   * Returns JSON representation of the rule.
   * Fallbacks are not supported.
   * Useful for inline styles.
   */
  ;

  _proto2.toJSON = function toJSON() {
    var json = {};

    for (var prop in this.style) {
      var value = this.style[prop];
      if (typeof value !== 'object') json[prop] = value;else if (Array.isArray(value)) json[prop] = toCssValue(value);
    }

    return json;
  }
  /**
   * Generates a CSS string.
   */
  ;

  _proto2.toString = function toString(options) {
    var sheet = this.options.sheet;
    var link = sheet ? sheet.options.link : false;
    var opts = link ? (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_3__["default"])({}, options, {
      allowEmpty: true
    }) : options;
    return toCss(this.selectorText, this.style, opts);
  };

  (0,_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_4__["default"])(StyleRule, [{
    key: "selector",
    set: function set(selector) {
      if (selector === this.selectorText) return;
      this.selectorText = selector;
      var renderer = this.renderer,
          renderable = this.renderable;
      if (!renderable || !renderer) return;
      var hasChanged = renderer.setSelector(renderable, selector); // If selector setter is not implemented, rerender the rule.

      if (!hasChanged) {
        renderer.replaceRule(renderable, this);
      }
    }
    /**
     * Get selector string.
     */
    ,
    get: function get() {
      return this.selectorText;
    }
  }]);

  return StyleRule;
}(BaseStyleRule);
var pluginStyleRule = {
  onCreateRule: function onCreateRule(key, style, options) {
    if (key[0] === '@' || options.parent && options.parent.type === 'keyframes') {
      return null;
    }

    return new StyleRule(key, style, options);
  }
};

var defaultToStringOptions = {
  indent: 1,
  children: true
};
var atRegExp = /@([\w-]+)/;
/**
 * Conditional rule for @media, @supports
 */

var ConditionalRule =
/*#__PURE__*/
function () {
  function ConditionalRule(key, styles, options) {
    this.type = 'conditional';
    this.isProcessed = false;
    this.key = key;
    var atMatch = key.match(atRegExp);
    this.at = atMatch ? atMatch[1] : 'unknown'; // Key might contain a unique suffix in case the `name` passed by user was duplicate.

    this.query = options.name || "@" + this.at;
    this.options = options;
    this.rules = new RuleList((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_3__["default"])({}, options, {
      parent: this
    }));

    for (var name in styles) {
      this.rules.add(name, styles[name]);
    }

    this.rules.process();
  }
  /**
   * Get a rule.
   */


  var _proto = ConditionalRule.prototype;

  _proto.getRule = function getRule(name) {
    return this.rules.get(name);
  }
  /**
   * Get index of a rule.
   */
  ;

  _proto.indexOf = function indexOf(rule) {
    return this.rules.indexOf(rule);
  }
  /**
   * Create and register rule, run plugins.
   */
  ;

  _proto.addRule = function addRule(name, style, options) {
    var rule = this.rules.add(name, style, options);
    if (!rule) return null;
    this.options.jss.plugins.onProcessRule(rule);
    return rule;
  }
  /**
   * Replace rule, run plugins.
   */
  ;

  _proto.replaceRule = function replaceRule(name, style, options) {
    var newRule = this.rules.replace(name, style, options);
    if (newRule) this.options.jss.plugins.onProcessRule(newRule);
    return newRule;
  }
  /**
   * Generates a CSS string.
   */
  ;

  _proto.toString = function toString(options) {
    if (options === void 0) {
      options = defaultToStringOptions;
    }

    var _getWhitespaceSymbols = getWhitespaceSymbols(options),
        linebreak = _getWhitespaceSymbols.linebreak;

    if (options.indent == null) options.indent = defaultToStringOptions.indent;
    if (options.children == null) options.children = defaultToStringOptions.children;

    if (options.children === false) {
      return this.query + " {}";
    }

    var children = this.rules.toString(options);
    return children ? this.query + " {" + linebreak + children + linebreak + "}" : '';
  };

  return ConditionalRule;
}();
var keyRegExp = /@container|@media|@supports\s+/;
var pluginConditionalRule = {
  onCreateRule: function onCreateRule(key, styles, options) {
    return keyRegExp.test(key) ? new ConditionalRule(key, styles, options) : null;
  }
};

var defaultToStringOptions$1 = {
  indent: 1,
  children: true
};
var nameRegExp = /@keyframes\s+([\w-]+)/;
/**
 * Rule for @keyframes
 */

var KeyframesRule =
/*#__PURE__*/
function () {
  function KeyframesRule(key, frames, options) {
    this.type = 'keyframes';
    this.at = '@keyframes';
    this.isProcessed = false;
    var nameMatch = key.match(nameRegExp);

    if (nameMatch && nameMatch[1]) {
      this.name = nameMatch[1];
    } else {
      this.name = 'noname';
       false ? 0 : void 0;
    }

    this.key = this.type + "-" + this.name;
    this.options = options;
    var scoped = options.scoped,
        sheet = options.sheet,
        generateId = options.generateId;
    this.id = scoped === false ? this.name : escape(generateId(this, sheet));
    this.rules = new RuleList((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_3__["default"])({}, options, {
      parent: this
    }));

    for (var name in frames) {
      this.rules.add(name, frames[name], (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_3__["default"])({}, options, {
        parent: this
      }));
    }

    this.rules.process();
  }
  /**
   * Generates a CSS string.
   */


  var _proto = KeyframesRule.prototype;

  _proto.toString = function toString(options) {
    if (options === void 0) {
      options = defaultToStringOptions$1;
    }

    var _getWhitespaceSymbols = getWhitespaceSymbols(options),
        linebreak = _getWhitespaceSymbols.linebreak;

    if (options.indent == null) options.indent = defaultToStringOptions$1.indent;
    if (options.children == null) options.children = defaultToStringOptions$1.children;

    if (options.children === false) {
      return this.at + " " + this.id + " {}";
    }

    var children = this.rules.toString(options);
    if (children) children = "" + linebreak + children + linebreak;
    return this.at + " " + this.id + " {" + children + "}";
  };

  return KeyframesRule;
}();
var keyRegExp$1 = /@keyframes\s+/;
var refRegExp = /\$([\w-]+)/g;

var findReferencedKeyframe = function findReferencedKeyframe(val, keyframes) {
  if (typeof val === 'string') {
    return val.replace(refRegExp, function (match, name) {
      if (name in keyframes) {
        return keyframes[name];
      }

       false ? 0 : void 0;
      return match;
    });
  }

  return val;
};
/**
 * Replace the reference for a animation name.
 */


var replaceRef = function replaceRef(style, prop, keyframes) {
  var value = style[prop];
  var refKeyframe = findReferencedKeyframe(value, keyframes);

  if (refKeyframe !== value) {
    style[prop] = refKeyframe;
  }
};

var pluginKeyframesRule = {
  onCreateRule: function onCreateRule(key, frames, options) {
    return typeof key === 'string' && keyRegExp$1.test(key) ? new KeyframesRule(key, frames, options) : null;
  },
  // Animation name ref replacer.
  onProcessStyle: function onProcessStyle(style, rule, sheet) {
    if (rule.type !== 'style' || !sheet) return style;
    if ('animation-name' in style) replaceRef(style, 'animation-name', sheet.keyframes);
    if ('animation' in style) replaceRef(style, 'animation', sheet.keyframes);
    return style;
  },
  onChangeValue: function onChangeValue(val, prop, rule) {
    var sheet = rule.options.sheet;

    if (!sheet) {
      return val;
    }

    switch (prop) {
      case 'animation':
        return findReferencedKeyframe(val, sheet.keyframes);

      case 'animation-name':
        return findReferencedKeyframe(val, sheet.keyframes);

      default:
        return val;
    }
  }
};

var KeyframeRule =
/*#__PURE__*/
function (_BaseStyleRule) {
  (0,_babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_1__["default"])(KeyframeRule, _BaseStyleRule);

  function KeyframeRule() {
    return _BaseStyleRule.apply(this, arguments) || this;
  }

  var _proto = KeyframeRule.prototype;

  /**
   * Generates a CSS string.
   */
  _proto.toString = function toString(options) {
    var sheet = this.options.sheet;
    var link = sheet ? sheet.options.link : false;
    var opts = link ? (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_3__["default"])({}, options, {
      allowEmpty: true
    }) : options;
    return toCss(this.key, this.style, opts);
  };

  return KeyframeRule;
}(BaseStyleRule);
var pluginKeyframeRule = {
  onCreateRule: function onCreateRule(key, style, options) {
    if (options.parent && options.parent.type === 'keyframes') {
      return new KeyframeRule(key, style, options);
    }

    return null;
  }
};

var FontFaceRule =
/*#__PURE__*/
function () {
  function FontFaceRule(key, style, options) {
    this.type = 'font-face';
    this.at = '@font-face';
    this.isProcessed = false;
    this.key = key;
    this.style = style;
    this.options = options;
  }
  /**
   * Generates a CSS string.
   */


  var _proto = FontFaceRule.prototype;

  _proto.toString = function toString(options) {
    var _getWhitespaceSymbols = getWhitespaceSymbols(options),
        linebreak = _getWhitespaceSymbols.linebreak;

    if (Array.isArray(this.style)) {
      var str = '';

      for (var index = 0; index < this.style.length; index++) {
        str += toCss(this.at, this.style[index]);
        if (this.style[index + 1]) str += linebreak;
      }

      return str;
    }

    return toCss(this.at, this.style, options);
  };

  return FontFaceRule;
}();
var keyRegExp$2 = /@font-face/;
var pluginFontFaceRule = {
  onCreateRule: function onCreateRule(key, style, options) {
    return keyRegExp$2.test(key) ? new FontFaceRule(key, style, options) : null;
  }
};

var ViewportRule =
/*#__PURE__*/
function () {
  function ViewportRule(key, style, options) {
    this.type = 'viewport';
    this.at = '@viewport';
    this.isProcessed = false;
    this.key = key;
    this.style = style;
    this.options = options;
  }
  /**
   * Generates a CSS string.
   */


  var _proto = ViewportRule.prototype;

  _proto.toString = function toString(options) {
    return toCss(this.key, this.style, options);
  };

  return ViewportRule;
}();
var pluginViewportRule = {
  onCreateRule: function onCreateRule(key, style, options) {
    return key === '@viewport' || key === '@-ms-viewport' ? new ViewportRule(key, style, options) : null;
  }
};

var SimpleRule =
/*#__PURE__*/
function () {
  function SimpleRule(key, value, options) {
    this.type = 'simple';
    this.isProcessed = false;
    this.key = key;
    this.value = value;
    this.options = options;
  }
  /**
   * Generates a CSS string.
   */
  // eslint-disable-next-line no-unused-vars


  var _proto = SimpleRule.prototype;

  _proto.toString = function toString(options) {
    if (Array.isArray(this.value)) {
      var str = '';

      for (var index = 0; index < this.value.length; index++) {
        str += this.key + " " + this.value[index] + ";";
        if (this.value[index + 1]) str += '\n';
      }

      return str;
    }

    return this.key + " " + this.value + ";";
  };

  return SimpleRule;
}();
var keysMap = {
  '@charset': true,
  '@import': true,
  '@namespace': true
};
var pluginSimpleRule = {
  onCreateRule: function onCreateRule(key, value, options) {
    return key in keysMap ? new SimpleRule(key, value, options) : null;
  }
};

var plugins = [pluginStyleRule, pluginConditionalRule, pluginKeyframesRule, pluginKeyframeRule, pluginFontFaceRule, pluginViewportRule, pluginSimpleRule];

var defaultUpdateOptions = {
  process: true
};
var forceUpdateOptions = {
  force: true,
  process: true
  /**
   * Contains rules objects and allows adding/removing etc.
   * Is used for e.g. by `StyleSheet` or `ConditionalRule`.
   */

};

var RuleList =
/*#__PURE__*/
function () {
  // Rules registry for access by .get() method.
  // It contains the same rule registered by name and by selector.
  // Original styles object.
  // Used to ensure correct rules order.
  function RuleList(options) {
    this.map = {};
    this.raw = {};
    this.index = [];
    this.counter = 0;
    this.options = options;
    this.classes = options.classes;
    this.keyframes = options.keyframes;
  }
  /**
   * Create and register rule.
   *
   * Will not render after Style Sheet was rendered the first time.
   */


  var _proto = RuleList.prototype;

  _proto.add = function add(name, decl, ruleOptions) {
    var _this$options = this.options,
        parent = _this$options.parent,
        sheet = _this$options.sheet,
        jss = _this$options.jss,
        Renderer = _this$options.Renderer,
        generateId = _this$options.generateId,
        scoped = _this$options.scoped;

    var options = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_3__["default"])({
      classes: this.classes,
      parent: parent,
      sheet: sheet,
      jss: jss,
      Renderer: Renderer,
      generateId: generateId,
      scoped: scoped,
      name: name,
      keyframes: this.keyframes,
      selector: undefined
    }, ruleOptions); // When user uses .createStyleSheet(), duplicate names are not possible, but
    // `sheet.addRule()` opens the door for any duplicate rule name. When this happens
    // we need to make the key unique within this RuleList instance scope.


    var key = name;

    if (name in this.raw) {
      key = name + "-d" + this.counter++;
    } // We need to save the original decl before creating the rule
    // because cache plugin needs to use it as a key to return a cached rule.


    this.raw[key] = decl;

    if (key in this.classes) {
      // E.g. rules inside of @media container
      options.selector = "." + escape(this.classes[key]);
    }

    var rule = createRule(key, decl, options);
    if (!rule) return null;
    this.register(rule);
    var index = options.index === undefined ? this.index.length : options.index;
    this.index.splice(index, 0, rule);
    return rule;
  }
  /**
   * Replace rule.
   * Create a new rule and remove old one instead of overwriting
   * because we want to invoke onCreateRule hook to make plugins work.
   */
  ;

  _proto.replace = function replace(name, decl, ruleOptions) {
    var oldRule = this.get(name);
    var oldIndex = this.index.indexOf(oldRule);

    if (oldRule) {
      this.remove(oldRule);
    }

    var options = ruleOptions;
    if (oldIndex !== -1) options = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_3__["default"])({}, ruleOptions, {
      index: oldIndex
    });
    return this.add(name, decl, options);
  }
  /**
   * Get a rule by name or selector.
   */
  ;

  _proto.get = function get(nameOrSelector) {
    return this.map[nameOrSelector];
  }
  /**
   * Delete a rule.
   */
  ;

  _proto.remove = function remove(rule) {
    this.unregister(rule);
    delete this.raw[rule.key];
    this.index.splice(this.index.indexOf(rule), 1);
  }
  /**
   * Get index of a rule.
   */
  ;

  _proto.indexOf = function indexOf(rule) {
    return this.index.indexOf(rule);
  }
  /**
   * Run `onProcessRule()` plugins on every rule.
   */
  ;

  _proto.process = function process() {
    var plugins = this.options.jss.plugins; // We need to clone array because if we modify the index somewhere else during a loop
    // we end up with very hard-to-track-down side effects.

    this.index.slice(0).forEach(plugins.onProcessRule, plugins);
  }
  /**
   * Register a rule in `.map`, `.classes` and `.keyframes` maps.
   */
  ;

  _proto.register = function register(rule) {
    this.map[rule.key] = rule;

    if (rule instanceof StyleRule) {
      this.map[rule.selector] = rule;
      if (rule.id) this.classes[rule.key] = rule.id;
    } else if (rule instanceof KeyframesRule && this.keyframes) {
      this.keyframes[rule.name] = rule.id;
    }
  }
  /**
   * Unregister a rule.
   */
  ;

  _proto.unregister = function unregister(rule) {
    delete this.map[rule.key];

    if (rule instanceof StyleRule) {
      delete this.map[rule.selector];
      delete this.classes[rule.key];
    } else if (rule instanceof KeyframesRule) {
      delete this.keyframes[rule.name];
    }
  }
  /**
   * Update the function values with a new data.
   */
  ;

  _proto.update = function update() {
    var name;
    var data;
    var options;

    if (typeof (arguments.length <= 0 ? undefined : arguments[0]) === 'string') {
      name = arguments.length <= 0 ? undefined : arguments[0];
      data = arguments.length <= 1 ? undefined : arguments[1];
      options = arguments.length <= 2 ? undefined : arguments[2];
    } else {
      data = arguments.length <= 0 ? undefined : arguments[0];
      options = arguments.length <= 1 ? undefined : arguments[1];
      name = null;
    }

    if (name) {
      this.updateOne(this.get(name), data, options);
    } else {
      for (var index = 0; index < this.index.length; index++) {
        this.updateOne(this.index[index], data, options);
      }
    }
  }
  /**
   * Execute plugins, update rule props.
   */
  ;

  _proto.updateOne = function updateOne(rule, data, options) {
    if (options === void 0) {
      options = defaultUpdateOptions;
    }

    var _this$options2 = this.options,
        plugins = _this$options2.jss.plugins,
        sheet = _this$options2.sheet; // It is a rules container like for e.g. ConditionalRule.

    if (rule.rules instanceof RuleList) {
      rule.rules.update(data, options);
      return;
    }

    var style = rule.style;
    plugins.onUpdate(data, rule, sheet, options); // We rely on a new `style` ref in case it was mutated during onUpdate hook.

    if (options.process && style && style !== rule.style) {
      // We need to run the plugins in case new `style` relies on syntax plugins.
      plugins.onProcessStyle(rule.style, rule, sheet); // Update and add props.

      for (var prop in rule.style) {
        var nextValue = rule.style[prop];
        var prevValue = style[prop]; // We need to use `force: true` because `rule.style` has been updated during onUpdate hook, so `rule.prop()` will not update the CSSOM rule.
        // We do this comparison to avoid unneeded `rule.prop()` calls, since we have the old `style` object here.

        if (nextValue !== prevValue) {
          rule.prop(prop, nextValue, forceUpdateOptions);
        }
      } // Remove props.


      for (var _prop in style) {
        var _nextValue = rule.style[_prop];
        var _prevValue = style[_prop]; // We need to use `force: true` because `rule.style` has been updated during onUpdate hook, so `rule.prop()` will not update the CSSOM rule.
        // We do this comparison to avoid unneeded `rule.prop()` calls, since we have the old `style` object here.

        if (_nextValue == null && _nextValue !== _prevValue) {
          rule.prop(_prop, null, forceUpdateOptions);
        }
      }
    }
  }
  /**
   * Convert rules to a CSS string.
   */
  ;

  _proto.toString = function toString(options) {
    var str = '';
    var sheet = this.options.sheet;
    var link = sheet ? sheet.options.link : false;

    var _getWhitespaceSymbols = getWhitespaceSymbols(options),
        linebreak = _getWhitespaceSymbols.linebreak;

    for (var index = 0; index < this.index.length; index++) {
      var rule = this.index[index];
      var css = rule.toString(options); // No need to render an empty rule.

      if (!css && !link) continue;
      if (str) str += linebreak;
      str += css;
    }

    return str;
  };

  return RuleList;
}();

var StyleSheet =
/*#__PURE__*/
function () {
  function StyleSheet(styles, options) {
    this.attached = false;
    this.deployed = false;
    this.classes = {};
    this.keyframes = {};
    this.options = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_3__["default"])({}, options, {
      sheet: this,
      parent: this,
      classes: this.classes,
      keyframes: this.keyframes
    });

    if (options.Renderer) {
      this.renderer = new options.Renderer(this);
    }

    this.rules = new RuleList(this.options);

    for (var name in styles) {
      this.rules.add(name, styles[name]);
    }

    this.rules.process();
  }
  /**
   * Attach renderable to the render tree.
   */


  var _proto = StyleSheet.prototype;

  _proto.attach = function attach() {
    if (this.attached) return this;
    if (this.renderer) this.renderer.attach();
    this.attached = true; // Order is important, because we can't use insertRule API if style element is not attached.

    if (!this.deployed) this.deploy();
    return this;
  }
  /**
   * Remove renderable from render tree.
   */
  ;

  _proto.detach = function detach() {
    if (!this.attached) return this;
    if (this.renderer) this.renderer.detach();
    this.attached = false;
    return this;
  }
  /**
   * Add a rule to the current stylesheet.
   * Will insert a rule also after the stylesheet has been rendered first time.
   */
  ;

  _proto.addRule = function addRule(name, decl, options) {
    var queue = this.queue; // Plugins can create rules.
    // In order to preserve the right order, we need to queue all `.addRule` calls,
    // which happen after the first `rules.add()` call.

    if (this.attached && !queue) this.queue = [];
    var rule = this.rules.add(name, decl, options);
    if (!rule) return null;
    this.options.jss.plugins.onProcessRule(rule);

    if (this.attached) {
      if (!this.deployed) return rule; // Don't insert rule directly if there is no stringified version yet.
      // It will be inserted all together when .attach is called.

      if (queue) queue.push(rule);else {
        this.insertRule(rule);

        if (this.queue) {
          this.queue.forEach(this.insertRule, this);
          this.queue = undefined;
        }
      }
      return rule;
    } // We can't add rules to a detached style node.
    // We will redeploy the sheet once user will attach it.


    this.deployed = false;
    return rule;
  }
  /**
   * Replace a rule in the current stylesheet.
   */
  ;

  _proto.replaceRule = function replaceRule(nameOrSelector, decl, options) {
    var oldRule = this.rules.get(nameOrSelector);
    if (!oldRule) return this.addRule(nameOrSelector, decl, options);
    var newRule = this.rules.replace(nameOrSelector, decl, options);

    if (newRule) {
      this.options.jss.plugins.onProcessRule(newRule);
    }

    if (this.attached) {
      if (!this.deployed) return newRule; // Don't replace / delete rule directly if there is no stringified version yet.
      // It will be inserted all together when .attach is called.

      if (this.renderer) {
        if (!newRule) {
          this.renderer.deleteRule(oldRule);
        } else if (oldRule.renderable) {
          this.renderer.replaceRule(oldRule.renderable, newRule);
        }
      }

      return newRule;
    } // We can't replace rules to a detached style node.
    // We will redeploy the sheet once user will attach it.


    this.deployed = false;
    return newRule;
  }
  /**
   * Insert rule into the StyleSheet
   */
  ;

  _proto.insertRule = function insertRule(rule) {
    if (this.renderer) {
      this.renderer.insertRule(rule);
    }
  }
  /**
   * Create and add rules.
   * Will render also after Style Sheet was rendered the first time.
   */
  ;

  _proto.addRules = function addRules(styles, options) {
    var added = [];

    for (var name in styles) {
      var rule = this.addRule(name, styles[name], options);
      if (rule) added.push(rule);
    }

    return added;
  }
  /**
   * Get a rule by name or selector.
   */
  ;

  _proto.getRule = function getRule(nameOrSelector) {
    return this.rules.get(nameOrSelector);
  }
  /**
   * Delete a rule by name.
   * Returns `true`: if rule has been deleted from the DOM.
   */
  ;

  _proto.deleteRule = function deleteRule(name) {
    var rule = typeof name === 'object' ? name : this.rules.get(name);

    if (!rule || // Style sheet was created without link: true and attached, in this case we
    // won't be able to remove the CSS rule from the DOM.
    this.attached && !rule.renderable) {
      return false;
    }

    this.rules.remove(rule);

    if (this.attached && rule.renderable && this.renderer) {
      return this.renderer.deleteRule(rule.renderable);
    }

    return true;
  }
  /**
   * Get index of a rule.
   */
  ;

  _proto.indexOf = function indexOf(rule) {
    return this.rules.indexOf(rule);
  }
  /**
   * Deploy pure CSS string to a renderable.
   */
  ;

  _proto.deploy = function deploy() {
    if (this.renderer) this.renderer.deploy();
    this.deployed = true;
    return this;
  }
  /**
   * Update the function values with a new data.
   */
  ;

  _proto.update = function update() {
    var _this$rules;

    (_this$rules = this.rules).update.apply(_this$rules, arguments);

    return this;
  }
  /**
   * Updates a single rule.
   */
  ;

  _proto.updateOne = function updateOne(rule, data, options) {
    this.rules.updateOne(rule, data, options);
    return this;
  }
  /**
   * Convert rules to a CSS string.
   */
  ;

  _proto.toString = function toString(options) {
    return this.rules.toString(options);
  };

  return StyleSheet;
}();

var PluginsRegistry =
/*#__PURE__*/
function () {
  function PluginsRegistry() {
    this.plugins = {
      internal: [],
      external: []
    };
    this.registry = {};
  }

  var _proto = PluginsRegistry.prototype;

  /**
   * Call `onCreateRule` hooks and return an object if returned by a hook.
   */
  _proto.onCreateRule = function onCreateRule(name, decl, options) {
    for (var i = 0; i < this.registry.onCreateRule.length; i++) {
      var rule = this.registry.onCreateRule[i](name, decl, options);
      if (rule) return rule;
    }

    return null;
  }
  /**
   * Call `onProcessRule` hooks.
   */
  ;

  _proto.onProcessRule = function onProcessRule(rule) {
    if (rule.isProcessed) return;
    var sheet = rule.options.sheet;

    for (var i = 0; i < this.registry.onProcessRule.length; i++) {
      this.registry.onProcessRule[i](rule, sheet);
    }

    if (rule.style) this.onProcessStyle(rule.style, rule, sheet);
    rule.isProcessed = true;
  }
  /**
   * Call `onProcessStyle` hooks.
   */
  ;

  _proto.onProcessStyle = function onProcessStyle(style, rule, sheet) {
    for (var i = 0; i < this.registry.onProcessStyle.length; i++) {
      rule.style = this.registry.onProcessStyle[i](rule.style, rule, sheet);
    }
  }
  /**
   * Call `onProcessSheet` hooks.
   */
  ;

  _proto.onProcessSheet = function onProcessSheet(sheet) {
    for (var i = 0; i < this.registry.onProcessSheet.length; i++) {
      this.registry.onProcessSheet[i](sheet);
    }
  }
  /**
   * Call `onUpdate` hooks.
   */
  ;

  _proto.onUpdate = function onUpdate(data, rule, sheet, options) {
    for (var i = 0; i < this.registry.onUpdate.length; i++) {
      this.registry.onUpdate[i](data, rule, sheet, options);
    }
  }
  /**
   * Call `onChangeValue` hooks.
   */
  ;

  _proto.onChangeValue = function onChangeValue(value, prop, rule) {
    var processedValue = value;

    for (var i = 0; i < this.registry.onChangeValue.length; i++) {
      processedValue = this.registry.onChangeValue[i](processedValue, prop, rule);
    }

    return processedValue;
  }
  /**
   * Register a plugin.
   */
  ;

  _proto.use = function use(newPlugin, options) {
    if (options === void 0) {
      options = {
        queue: 'external'
      };
    }

    var plugins = this.plugins[options.queue]; // Avoids applying same plugin twice, at least based on ref.

    if (plugins.indexOf(newPlugin) !== -1) {
      return;
    }

    plugins.push(newPlugin);
    this.registry = [].concat(this.plugins.external, this.plugins.internal).reduce(function (registry, plugin) {
      for (var name in plugin) {
        if (name in registry) {
          registry[name].push(plugin[name]);
        } else {
           false ? 0 : void 0;
        }
      }

      return registry;
    }, {
      onCreateRule: [],
      onProcessRule: [],
      onProcessStyle: [],
      onProcessSheet: [],
      onChangeValue: [],
      onUpdate: []
    });
  };

  return PluginsRegistry;
}();

/**
 * Sheets registry to access all instances in one place.
 */

var SheetsRegistry =
/*#__PURE__*/
function () {
  function SheetsRegistry() {
    this.registry = [];
  }

  var _proto = SheetsRegistry.prototype;

  /**
   * Register a Style Sheet.
   */
  _proto.add = function add(sheet) {
    var registry = this.registry;
    var index = sheet.options.index;
    if (registry.indexOf(sheet) !== -1) return;

    if (registry.length === 0 || index >= this.index) {
      registry.push(sheet);
      return;
    } // Find a position.


    for (var i = 0; i < registry.length; i++) {
      if (registry[i].options.index > index) {
        registry.splice(i, 0, sheet);
        return;
      }
    }
  }
  /**
   * Reset the registry.
   */
  ;

  _proto.reset = function reset() {
    this.registry = [];
  }
  /**
   * Remove a Style Sheet.
   */
  ;

  _proto.remove = function remove(sheet) {
    var index = this.registry.indexOf(sheet);
    this.registry.splice(index, 1);
  }
  /**
   * Convert all attached sheets to a CSS string.
   */
  ;

  _proto.toString = function toString(_temp) {
    var _ref = _temp === void 0 ? {} : _temp,
        attached = _ref.attached,
        options = (0,_babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_5__["default"])(_ref, ["attached"]);

    var _getWhitespaceSymbols = getWhitespaceSymbols(options),
        linebreak = _getWhitespaceSymbols.linebreak;

    var css = '';

    for (var i = 0; i < this.registry.length; i++) {
      var sheet = this.registry[i];

      if (attached != null && sheet.attached !== attached) {
        continue;
      }

      if (css) css += linebreak;
      css += sheet.toString(options);
    }

    return css;
  };

  (0,_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_4__["default"])(SheetsRegistry, [{
    key: "index",

    /**
     * Current highest index number.
     */
    get: function get() {
      return this.registry.length === 0 ? 0 : this.registry[this.registry.length - 1].options.index;
    }
  }]);

  return SheetsRegistry;
}();

/**
 * This is a global sheets registry. Only DomRenderer will add sheets to it.
 * On the server one should use an own SheetsRegistry instance and add the
 * sheets to it, because you need to make sure to create a new registry for
 * each request in order to not leak sheets across requests.
 */

var sheets = new SheetsRegistry();

/* eslint-disable */

/**
 * Now that `globalThis` is available on most platforms
 * (https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/globalThis#browser_compatibility)
 * we check for `globalThis` first. `globalThis` is necessary for jss
 * to run in Agoric's secure version of JavaScript (SES). Under SES,
 * `globalThis` exists, but `window`, `self`, and `Function('return
 * this')()` are all undefined for security reasons.
 *
 * https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
 */
var globalThis$1 = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' && window.Math === Math ? window : typeof self !== 'undefined' && self.Math === Math ? self : Function('return this')();

var ns = '2f1acc6c3a606b082e5eef5e54414ffb';
if (globalThis$1[ns] == null) globalThis$1[ns] = 0; // Bundle may contain multiple JSS versions at the same time. In order to identify
// the current version with just one short number and use it for classes generation
// we use a counter. Also it is more accurate, because user can manually reevaluate
// the module.

var moduleId = globalThis$1[ns]++;

var maxRules = 1e10;
/**
 * Returns a function which generates unique class names based on counters.
 * When new generator function is created, rule counter is reseted.
 * We need to reset the rule counter for SSR for each request.
 */

var createGenerateId = function createGenerateId(options) {
  if (options === void 0) {
    options = {};
  }

  var ruleCounter = 0;

  var generateId = function generateId(rule, sheet) {
    ruleCounter += 1;

    if (ruleCounter > maxRules) {
       false ? 0 : void 0;
    }

    var jssId = '';
    var prefix = '';

    if (sheet) {
      if (sheet.options.classNamePrefix) {
        prefix = sheet.options.classNamePrefix;
      }

      if (sheet.options.jss.id != null) {
        jssId = String(sheet.options.jss.id);
      }
    }

    if (options.minify) {
      // Using "c" because a number can't be the first char in a class name.
      return "" + (prefix || 'c') + moduleId + jssId + ruleCounter;
    }

    return prefix + rule.key + "-" + moduleId + (jssId ? "-" + jssId : '') + "-" + ruleCounter;
  };

  return generateId;
};

/**
 * Cache the value from the first time a function is called.
 */

var memoize = function memoize(fn) {
  var value;
  return function () {
    if (!value) value = fn();
    return value;
  };
};
/**
 * Get a style property value.
 */


var getPropertyValue = function getPropertyValue(cssRule, prop) {
  try {
    // Support CSSTOM.
    if (cssRule.attributeStyleMap) {
      return cssRule.attributeStyleMap.get(prop);
    }

    return cssRule.style.getPropertyValue(prop);
  } catch (err) {
    // IE may throw if property is unknown.
    return '';
  }
};
/**
 * Set a style property.
 */


var setProperty = function setProperty(cssRule, prop, value) {
  try {
    var cssValue = value;

    if (Array.isArray(value)) {
      cssValue = toCssValue(value);
    } // Support CSSTOM.


    if (cssRule.attributeStyleMap) {
      cssRule.attributeStyleMap.set(prop, cssValue);
    } else {
      var indexOfImportantFlag = cssValue ? cssValue.indexOf('!important') : -1;
      var cssValueWithoutImportantFlag = indexOfImportantFlag > -1 ? cssValue.substr(0, indexOfImportantFlag - 1) : cssValue;
      cssRule.style.setProperty(prop, cssValueWithoutImportantFlag, indexOfImportantFlag > -1 ? 'important' : '');
    }
  } catch (err) {
    // IE may throw if property is unknown.
    return false;
  }

  return true;
};
/**
 * Remove a style property.
 */


var removeProperty = function removeProperty(cssRule, prop) {
  try {
    // Support CSSTOM.
    if (cssRule.attributeStyleMap) {
      cssRule.attributeStyleMap.delete(prop);
    } else {
      cssRule.style.removeProperty(prop);
    }
  } catch (err) {
     false ? 0 : void 0;
  }
};
/**
 * Set the selector.
 */


var setSelector = function setSelector(cssRule, selectorText) {
  cssRule.selectorText = selectorText; // Return false if setter was not successful.
  // Currently works in chrome only.

  return cssRule.selectorText === selectorText;
};
/**
 * Gets the `head` element upon the first call and caches it.
 * We assume it can't be null.
 */


var getHead = memoize(function () {
  return document.querySelector('head');
});
/**
 * Find attached sheet with an index higher than the passed one.
 */

function findHigherSheet(registry, options) {
  for (var i = 0; i < registry.length; i++) {
    var sheet = registry[i];

    if (sheet.attached && sheet.options.index > options.index && sheet.options.insertionPoint === options.insertionPoint) {
      return sheet;
    }
  }

  return null;
}
/**
 * Find attached sheet with the highest index.
 */


function findHighestSheet(registry, options) {
  for (var i = registry.length - 1; i >= 0; i--) {
    var sheet = registry[i];

    if (sheet.attached && sheet.options.insertionPoint === options.insertionPoint) {
      return sheet;
    }
  }

  return null;
}
/**
 * Find a comment with "jss" inside.
 */


function findCommentNode(text) {
  var head = getHead();

  for (var i = 0; i < head.childNodes.length; i++) {
    var node = head.childNodes[i];

    if (node.nodeType === 8 && node.nodeValue.trim() === text) {
      return node;
    }
  }

  return null;
}
/**
 * Find a node before which we can insert the sheet.
 */


function findPrevNode(options) {
  var registry = sheets.registry;

  if (registry.length > 0) {
    // Try to insert before the next higher sheet.
    var sheet = findHigherSheet(registry, options);

    if (sheet && sheet.renderer) {
      return {
        parent: sheet.renderer.element.parentNode,
        node: sheet.renderer.element
      };
    } // Otherwise insert after the last attached.


    sheet = findHighestSheet(registry, options);

    if (sheet && sheet.renderer) {
      return {
        parent: sheet.renderer.element.parentNode,
        node: sheet.renderer.element.nextSibling
      };
    }
  } // Try to find a comment placeholder if registry is empty.


  var insertionPoint = options.insertionPoint;

  if (insertionPoint && typeof insertionPoint === 'string') {
    var comment = findCommentNode(insertionPoint);

    if (comment) {
      return {
        parent: comment.parentNode,
        node: comment.nextSibling
      };
    } // If user specifies an insertion point and it can't be found in the document -
    // bad specificity issues may appear.


     false ? 0 : void 0;
  }

  return false;
}
/**
 * Insert style element into the DOM.
 */


function insertStyle(style, options) {
  var insertionPoint = options.insertionPoint;
  var nextNode = findPrevNode(options);

  if (nextNode !== false && nextNode.parent) {
    nextNode.parent.insertBefore(style, nextNode.node);
    return;
  } // Works with iframes and any node types.


  if (insertionPoint && typeof insertionPoint.nodeType === 'number') {
    var insertionPointElement = insertionPoint;
    var parentNode = insertionPointElement.parentNode;
    if (parentNode) parentNode.insertBefore(style, insertionPointElement.nextSibling);else  false ? 0 : void 0;
    return;
  }

  getHead().appendChild(style);
}
/**
 * Read jss nonce setting from the page if the user has set it.
 */


var getNonce = memoize(function () {
  var node = document.querySelector('meta[property="csp-nonce"]');
  return node ? node.getAttribute('content') : null;
});

var _insertRule = function insertRule(container, rule, index) {
  try {
    if ('insertRule' in container) {
      container.insertRule(rule, index);
    } // Keyframes rule.
    else if ('appendRule' in container) {
        container.appendRule(rule);
      }
  } catch (err) {
     false ? 0 : void 0;
    return false;
  }

  return container.cssRules[index];
};

var getValidRuleInsertionIndex = function getValidRuleInsertionIndex(container, index) {
  var maxIndex = container.cssRules.length; // In case previous insertion fails, passed index might be wrong

  if (index === undefined || index > maxIndex) {
    // eslint-disable-next-line no-param-reassign
    return maxIndex;
  }

  return index;
};

var createStyle = function createStyle() {
  var el = document.createElement('style'); // Without it, IE will have a broken source order specificity if we
  // insert rules after we insert the style tag.
  // It seems to kick-off the source order specificity algorithm.

  el.textContent = '\n';
  return el;
};

var DomRenderer =
/*#__PURE__*/
function () {
  // Will be empty if link: true option is not set, because
  // it is only for use together with insertRule API.
  function DomRenderer(sheet) {
    this.getPropertyValue = getPropertyValue;
    this.setProperty = setProperty;
    this.removeProperty = removeProperty;
    this.setSelector = setSelector;
    this.hasInsertedRules = false;
    this.cssRules = [];
    // There is no sheet when the renderer is used from a standalone StyleRule.
    if (sheet) sheets.add(sheet);
    this.sheet = sheet;

    var _ref = this.sheet ? this.sheet.options : {},
        media = _ref.media,
        meta = _ref.meta,
        element = _ref.element;

    this.element = element || createStyle();
    this.element.setAttribute('data-jss', '');
    if (media) this.element.setAttribute('media', media);
    if (meta) this.element.setAttribute('data-meta', meta);
    var nonce = getNonce();
    if (nonce) this.element.setAttribute('nonce', nonce);
  }
  /**
   * Insert style element into render tree.
   */


  var _proto = DomRenderer.prototype;

  _proto.attach = function attach() {
    // In the case the element node is external and it is already in the DOM.
    if (this.element.parentNode || !this.sheet) return;
    insertStyle(this.element, this.sheet.options); // When rules are inserted using `insertRule` API, after `sheet.detach().attach()`
    // most browsers create a new CSSStyleSheet, except of all IEs.

    var deployed = Boolean(this.sheet && this.sheet.deployed);

    if (this.hasInsertedRules && deployed) {
      this.hasInsertedRules = false;
      this.deploy();
    }
  }
  /**
   * Remove style element from render tree.
   */
  ;

  _proto.detach = function detach() {
    if (!this.sheet) return;
    var parentNode = this.element.parentNode;
    if (parentNode) parentNode.removeChild(this.element); // In the most browsers, rules inserted using insertRule() API will be lost when style element is removed.
    // Though IE will keep them and we need a consistent behavior.

    if (this.sheet.options.link) {
      this.cssRules = [];
      this.element.textContent = '\n';
    }
  }
  /**
   * Inject CSS string into element.
   */
  ;

  _proto.deploy = function deploy() {
    var sheet = this.sheet;
    if (!sheet) return;

    if (sheet.options.link) {
      this.insertRules(sheet.rules);
      return;
    }

    this.element.textContent = "\n" + sheet.toString() + "\n";
  }
  /**
   * Insert RuleList into an element.
   */
  ;

  _proto.insertRules = function insertRules(rules, nativeParent) {
    for (var i = 0; i < rules.index.length; i++) {
      this.insertRule(rules.index[i], i, nativeParent);
    }
  }
  /**
   * Insert a rule into element.
   */
  ;

  _proto.insertRule = function insertRule(rule, index, nativeParent) {
    if (nativeParent === void 0) {
      nativeParent = this.element.sheet;
    }

    if (rule.rules) {
      var parent = rule;
      var latestNativeParent = nativeParent;

      if (rule.type === 'conditional' || rule.type === 'keyframes') {
        var _insertionIndex = getValidRuleInsertionIndex(nativeParent, index); // We need to render the container without children first.


        latestNativeParent = _insertRule(nativeParent, parent.toString({
          children: false
        }), _insertionIndex);

        if (latestNativeParent === false) {
          return false;
        }

        this.refCssRule(rule, _insertionIndex, latestNativeParent);
      }

      this.insertRules(parent.rules, latestNativeParent);
      return latestNativeParent;
    }

    var ruleStr = rule.toString();
    if (!ruleStr) return false;
    var insertionIndex = getValidRuleInsertionIndex(nativeParent, index);

    var nativeRule = _insertRule(nativeParent, ruleStr, insertionIndex);

    if (nativeRule === false) {
      return false;
    }

    this.hasInsertedRules = true;
    this.refCssRule(rule, insertionIndex, nativeRule);
    return nativeRule;
  };

  _proto.refCssRule = function refCssRule(rule, index, cssRule) {
    rule.renderable = cssRule; // We only want to reference the top level rules, deleteRule API doesn't support removing nested rules
    // like rules inside media queries or keyframes

    if (rule.options.parent instanceof StyleSheet) {
      this.cssRules.splice(index, 0, cssRule);
    }
  }
  /**
   * Delete a rule.
   */
  ;

  _proto.deleteRule = function deleteRule(cssRule) {
    var sheet = this.element.sheet;
    var index = this.indexOf(cssRule);
    if (index === -1) return false;
    sheet.deleteRule(index);
    this.cssRules.splice(index, 1);
    return true;
  }
  /**
   * Get index of a CSS Rule.
   */
  ;

  _proto.indexOf = function indexOf(cssRule) {
    return this.cssRules.indexOf(cssRule);
  }
  /**
   * Generate a new CSS rule and replace the existing one.
   */
  ;

  _proto.replaceRule = function replaceRule(cssRule, rule) {
    var index = this.indexOf(cssRule);
    if (index === -1) return false;
    this.element.sheet.deleteRule(index);
    this.cssRules.splice(index, 1);
    return this.insertRule(rule, index);
  }
  /**
   * Get all rules elements.
   */
  ;

  _proto.getRules = function getRules() {
    return this.element.sheet.cssRules;
  };

  return DomRenderer;
}();

var instanceCounter = 0;

var Jss =
/*#__PURE__*/
function () {
  function Jss(options) {
    this.id = instanceCounter++;
    this.version = "10.10.0";
    this.plugins = new PluginsRegistry();
    this.options = {
      id: {
        minify: false
      },
      createGenerateId: createGenerateId,
      Renderer: is_in_browser__WEBPACK_IMPORTED_MODULE_0__["default"] ? DomRenderer : null,
      plugins: []
    };
    this.generateId = createGenerateId({
      minify: false
    });

    for (var i = 0; i < plugins.length; i++) {
      this.plugins.use(plugins[i], {
        queue: 'internal'
      });
    }

    this.setup(options);
  }
  /**
   * Prepares various options, applies plugins.
   * Should not be used twice on the same instance, because there is no plugins
   * deduplication logic.
   */


  var _proto = Jss.prototype;

  _proto.setup = function setup(options) {
    if (options === void 0) {
      options = {};
    }

    if (options.createGenerateId) {
      this.options.createGenerateId = options.createGenerateId;
    }

    if (options.id) {
      this.options.id = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_3__["default"])({}, this.options.id, options.id);
    }

    if (options.createGenerateId || options.id) {
      this.generateId = this.options.createGenerateId(this.options.id);
    }

    if (options.insertionPoint != null) this.options.insertionPoint = options.insertionPoint;

    if ('Renderer' in options) {
      this.options.Renderer = options.Renderer;
    } // eslint-disable-next-line prefer-spread


    if (options.plugins) this.use.apply(this, options.plugins);
    return this;
  }
  /**
   * Create a Style Sheet.
   */
  ;

  _proto.createStyleSheet = function createStyleSheet(styles, options) {
    if (options === void 0) {
      options = {};
    }

    var _options = options,
        index = _options.index;

    if (typeof index !== 'number') {
      index = sheets.index === 0 ? 0 : sheets.index + 1;
    }

    var sheet = new StyleSheet(styles, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_3__["default"])({}, options, {
      jss: this,
      generateId: options.generateId || this.generateId,
      insertionPoint: this.options.insertionPoint,
      Renderer: this.options.Renderer,
      index: index
    }));
    this.plugins.onProcessSheet(sheet);
    return sheet;
  }
  /**
   * Detach the Style Sheet and remove it from the registry.
   */
  ;

  _proto.removeStyleSheet = function removeStyleSheet(sheet) {
    sheet.detach();
    sheets.remove(sheet);
    return this;
  }
  /**
   * Create a rule without a Style Sheet.
   * [Deprecated] will be removed in the next major version.
   */
  ;

  _proto.createRule = function createRule$1(name, style, options) {
    if (style === void 0) {
      style = {};
    }

    if (options === void 0) {
      options = {};
    }

    // Enable rule without name for inline styles.
    if (typeof name === 'object') {
      return this.createRule(undefined, name, style);
    }

    var ruleOptions = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_3__["default"])({}, options, {
      name: name,
      jss: this,
      Renderer: this.options.Renderer
    });

    if (!ruleOptions.generateId) ruleOptions.generateId = this.generateId;
    if (!ruleOptions.classes) ruleOptions.classes = {};
    if (!ruleOptions.keyframes) ruleOptions.keyframes = {};

    var rule = createRule(name, style, ruleOptions);

    if (rule) this.plugins.onProcessRule(rule);
    return rule;
  }
  /**
   * Register plugin. Passed function will be invoked with a rule instance.
   */
  ;

  _proto.use = function use() {
    var _this = this;

    for (var _len = arguments.length, plugins = new Array(_len), _key = 0; _key < _len; _key++) {
      plugins[_key] = arguments[_key];
    }

    plugins.forEach(function (plugin) {
      _this.plugins.use(plugin);
    });
    return this;
  };

  return Jss;
}();

var createJss = function createJss(options) {
  return new Jss(options);
};

/**
 * SheetsManager is like a WeakMap which is designed to count StyleSheet
 * instances and attach/detach automatically.
 * Used in react-jss.
 */

var SheetsManager =
/*#__PURE__*/
function () {
  function SheetsManager() {
    this.length = 0;
    this.sheets = new WeakMap();
  }

  var _proto = SheetsManager.prototype;

  _proto.get = function get(key) {
    var entry = this.sheets.get(key);
    return entry && entry.sheet;
  };

  _proto.add = function add(key, sheet) {
    if (this.sheets.has(key)) return;
    this.length++;
    this.sheets.set(key, {
      sheet: sheet,
      refs: 0
    });
  };

  _proto.manage = function manage(key) {
    var entry = this.sheets.get(key);

    if (entry) {
      if (entry.refs === 0) {
        entry.sheet.attach();
      }

      entry.refs++;
      return entry.sheet;
    }

    (0,tiny_warning__WEBPACK_IMPORTED_MODULE_6__["default"])(false, "[JSS] SheetsManager: can't find sheet to manage");
    return undefined;
  };

  _proto.unmanage = function unmanage(key) {
    var entry = this.sheets.get(key);

    if (entry) {
      if (entry.refs > 0) {
        entry.refs--;
        if (entry.refs === 0) entry.sheet.detach();
      }
    } else {
      (0,tiny_warning__WEBPACK_IMPORTED_MODULE_6__["default"])(false, "SheetsManager: can't find sheet to unmanage");
    }
  };

  (0,_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_4__["default"])(SheetsManager, [{
    key: "size",
    get: function get() {
      return this.length;
    }
  }]);

  return SheetsManager;
}();

/**
* Export a constant indicating if this browser has CSSTOM support.
* https://developers.google.com/web/updates/2018/03/cssom
*/
var hasCSSTOMSupport = typeof CSS === 'object' && CSS != null && 'number' in CSS;

/**
 * Extracts a styles object with only props that contain function values.
 */
function getDynamicStyles(styles) {
  var to = null;

  for (var key in styles) {
    var value = styles[key];
    var type = typeof value;

    if (type === 'function') {
      if (!to) to = {};
      to[key] = value;
    } else if (type === 'object' && value !== null && !Array.isArray(value)) {
      var extracted = getDynamicStyles(value);

      if (extracted) {
        if (!to) to = {};
        to[key] = extracted;
      }
    }
  }

  return to;
}

/**
 * A better abstraction over CSS.
 *
 * @copyright Oleg Isonen (Slobodskoi) / Isonen 2014-present
 * @website https://github.com/cssinjs/jss
 * @license MIT
 */
var index = createJss();

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (index);



/***/ }),

/***/ 7539:
/***/ ((module) => {

/* eslint-env node */


// SDP helpers.
const SDPUtils = {};

// Generate an alphanumeric identifier for cname or mids.
// TODO: use UUIDs instead? https://gist.github.com/jed/982883
SDPUtils.generateIdentifier = function() {
  return Math.random().toString(36).substring(2, 12);
};

// The RTCP CNAME used by all peerconnections from the same JS.
SDPUtils.localCName = SDPUtils.generateIdentifier();

// Splits SDP into lines, dealing with both CRLF and LF.
SDPUtils.splitLines = function(blob) {
  return blob.trim().split('\n').map(line => line.trim());
};
// Splits SDP into sessionpart and mediasections. Ensures CRLF.
SDPUtils.splitSections = function(blob) {
  const parts = blob.split('\nm=');
  return parts.map((part, index) => (index > 0 ?
    'm=' + part : part).trim() + '\r\n');
};

// Returns the session description.
SDPUtils.getDescription = function(blob) {
  const sections = SDPUtils.splitSections(blob);
  return sections && sections[0];
};

// Returns the individual media sections.
SDPUtils.getMediaSections = function(blob) {
  const sections = SDPUtils.splitSections(blob);
  sections.shift();
  return sections;
};

// Returns lines that start with a certain prefix.
SDPUtils.matchPrefix = function(blob, prefix) {
  return SDPUtils.splitLines(blob).filter(line => line.indexOf(prefix) === 0);
};

// Parses an ICE candidate line. Sample input:
// candidate:702786350 2 udp 41819902 8.8.8.8 60769 typ relay raddr 8.8.8.8
// rport 55996"
// Input can be prefixed with a=.
SDPUtils.parseCandidate = function(line) {
  let parts;
  // Parse both variants.
  if (line.indexOf('a=candidate:') === 0) {
    parts = line.substring(12).split(' ');
  } else {
    parts = line.substring(10).split(' ');
  }

  const candidate = {
    foundation: parts[0],
    component: {1: 'rtp', 2: 'rtcp'}[parts[1]] || parts[1],
    protocol: parts[2].toLowerCase(),
    priority: parseInt(parts[3], 10),
    ip: parts[4],
    address: parts[4], // address is an alias for ip.
    port: parseInt(parts[5], 10),
    // skip parts[6] == 'typ'
    type: parts[7],
  };

  for (let i = 8; i < parts.length; i += 2) {
    switch (parts[i]) {
      case 'raddr':
        candidate.relatedAddress = parts[i + 1];
        break;
      case 'rport':
        candidate.relatedPort = parseInt(parts[i + 1], 10);
        break;
      case 'tcptype':
        candidate.tcpType = parts[i + 1];
        break;
      case 'ufrag':
        candidate.ufrag = parts[i + 1]; // for backward compatibility.
        candidate.usernameFragment = parts[i + 1];
        break;
      default: // extension handling, in particular ufrag. Don't overwrite.
        if (candidate[parts[i]] === undefined) {
          candidate[parts[i]] = parts[i + 1];
        }
        break;
    }
  }
  return candidate;
};

// Translates a candidate object into SDP candidate attribute.
// This does not include the a= prefix!
SDPUtils.writeCandidate = function(candidate) {
  const sdp = [];
  sdp.push(candidate.foundation);

  const component = candidate.component;
  if (component === 'rtp') {
    sdp.push(1);
  } else if (component === 'rtcp') {
    sdp.push(2);
  } else {
    sdp.push(component);
  }
  sdp.push(candidate.protocol.toUpperCase());
  sdp.push(candidate.priority);
  sdp.push(candidate.address || candidate.ip);
  sdp.push(candidate.port);

  const type = candidate.type;
  sdp.push('typ');
  sdp.push(type);
  if (type !== 'host' && candidate.relatedAddress &&
      candidate.relatedPort) {
    sdp.push('raddr');
    sdp.push(candidate.relatedAddress);
    sdp.push('rport');
    sdp.push(candidate.relatedPort);
  }
  if (candidate.tcpType && candidate.protocol.toLowerCase() === 'tcp') {
    sdp.push('tcptype');
    sdp.push(candidate.tcpType);
  }
  if (candidate.usernameFragment || candidate.ufrag) {
    sdp.push('ufrag');
    sdp.push(candidate.usernameFragment || candidate.ufrag);
  }
  return 'candidate:' + sdp.join(' ');
};

// Parses an ice-options line, returns an array of option tags.
// Sample input:
// a=ice-options:foo bar
SDPUtils.parseIceOptions = function(line) {
  return line.substring(14).split(' ');
};

// Parses a rtpmap line, returns RTCRtpCoddecParameters. Sample input:
// a=rtpmap:111 opus/48000/2
SDPUtils.parseRtpMap = function(line) {
  let parts = line.substring(9).split(' ');
  const parsed = {
    payloadType: parseInt(parts.shift(), 10), // was: id
  };

  parts = parts[0].split('/');

  parsed.name = parts[0];
  parsed.clockRate = parseInt(parts[1], 10); // was: clockrate
  parsed.channels = parts.length === 3 ? parseInt(parts[2], 10) : 1;
  // legacy alias, got renamed back to channels in ORTC.
  parsed.numChannels = parsed.channels;
  return parsed;
};

// Generates a rtpmap line from RTCRtpCodecCapability or
// RTCRtpCodecParameters.
SDPUtils.writeRtpMap = function(codec) {
  let pt = codec.payloadType;
  if (codec.preferredPayloadType !== undefined) {
    pt = codec.preferredPayloadType;
  }
  const channels = codec.channels || codec.numChannels || 1;
  return 'a=rtpmap:' + pt + ' ' + codec.name + '/' + codec.clockRate +
      (channels !== 1 ? '/' + channels : '') + '\r\n';
};

// Parses a extmap line (headerextension from RFC 5285). Sample input:
// a=extmap:2 urn:ietf:params:rtp-hdrext:toffset
// a=extmap:2/sendonly urn:ietf:params:rtp-hdrext:toffset
SDPUtils.parseExtmap = function(line) {
  const parts = line.substring(9).split(' ');
  return {
    id: parseInt(parts[0], 10),
    direction: parts[0].indexOf('/') > 0 ? parts[0].split('/')[1] : 'sendrecv',
    uri: parts[1],
    attributes: parts.slice(2).join(' '),
  };
};

// Generates an extmap line from RTCRtpHeaderExtensionParameters or
// RTCRtpHeaderExtension.
SDPUtils.writeExtmap = function(headerExtension) {
  return 'a=extmap:' + (headerExtension.id || headerExtension.preferredId) +
      (headerExtension.direction && headerExtension.direction !== 'sendrecv'
        ? '/' + headerExtension.direction
        : '') +
      ' ' + headerExtension.uri +
      (headerExtension.attributes ? ' ' + headerExtension.attributes : '') +
      '\r\n';
};

// Parses a fmtp line, returns dictionary. Sample input:
// a=fmtp:96 vbr=on;cng=on
// Also deals with vbr=on; cng=on
SDPUtils.parseFmtp = function(line) {
  const parsed = {};
  let kv;
  const parts = line.substring(line.indexOf(' ') + 1).split(';');
  for (let j = 0; j < parts.length; j++) {
    kv = parts[j].trim().split('=');
    parsed[kv[0].trim()] = kv[1];
  }
  return parsed;
};

// Generates a fmtp line from RTCRtpCodecCapability or RTCRtpCodecParameters.
SDPUtils.writeFmtp = function(codec) {
  let line = '';
  let pt = codec.payloadType;
  if (codec.preferredPayloadType !== undefined) {
    pt = codec.preferredPayloadType;
  }
  if (codec.parameters && Object.keys(codec.parameters).length) {
    const params = [];
    Object.keys(codec.parameters).forEach(param => {
      if (codec.parameters[param] !== undefined) {
        params.push(param + '=' + codec.parameters[param]);
      } else {
        params.push(param);
      }
    });
    line += 'a=fmtp:' + pt + ' ' + params.join(';') + '\r\n';
  }
  return line;
};

// Parses a rtcp-fb line, returns RTCPRtcpFeedback object. Sample input:
// a=rtcp-fb:98 nack rpsi
SDPUtils.parseRtcpFb = function(line) {
  const parts = line.substring(line.indexOf(' ') + 1).split(' ');
  return {
    type: parts.shift(),
    parameter: parts.join(' '),
  };
};

// Generate a=rtcp-fb lines from RTCRtpCodecCapability or RTCRtpCodecParameters.
SDPUtils.writeRtcpFb = function(codec) {
  let lines = '';
  let pt = codec.payloadType;
  if (codec.preferredPayloadType !== undefined) {
    pt = codec.preferredPayloadType;
  }
  if (codec.rtcpFeedback && codec.rtcpFeedback.length) {
    // FIXME: special handling for trr-int?
    codec.rtcpFeedback.forEach(fb => {
      lines += 'a=rtcp-fb:' + pt + ' ' + fb.type +
      (fb.parameter && fb.parameter.length ? ' ' + fb.parameter : '') +
          '\r\n';
    });
  }
  return lines;
};

// Parses a RFC 5576 ssrc media attribute. Sample input:
// a=ssrc:3735928559 cname:something
SDPUtils.parseSsrcMedia = function(line) {
  const sp = line.indexOf(' ');
  const parts = {
    ssrc: parseInt(line.substring(7, sp), 10),
  };
  const colon = line.indexOf(':', sp);
  if (colon > -1) {
    parts.attribute = line.substring(sp + 1, colon);
    parts.value = line.substring(colon + 1);
  } else {
    parts.attribute = line.substring(sp + 1);
  }
  return parts;
};

// Parse a ssrc-group line (see RFC 5576). Sample input:
// a=ssrc-group:semantics 12 34
SDPUtils.parseSsrcGroup = function(line) {
  const parts = line.substring(13).split(' ');
  return {
    semantics: parts.shift(),
    ssrcs: parts.map(ssrc => parseInt(ssrc, 10)),
  };
};

// Extracts the MID (RFC 5888) from a media section.
// Returns the MID or undefined if no mid line was found.
SDPUtils.getMid = function(mediaSection) {
  const mid = SDPUtils.matchPrefix(mediaSection, 'a=mid:')[0];
  if (mid) {
    return mid.substring(6);
  }
};

// Parses a fingerprint line for DTLS-SRTP.
SDPUtils.parseFingerprint = function(line) {
  const parts = line.substring(14).split(' ');
  return {
    algorithm: parts[0].toLowerCase(), // algorithm is case-sensitive in Edge.
    value: parts[1].toUpperCase(), // the definition is upper-case in RFC 4572.
  };
};

// Extracts DTLS parameters from SDP media section or sessionpart.
// FIXME: for consistency with other functions this should only
//   get the fingerprint line as input. See also getIceParameters.
SDPUtils.getDtlsParameters = function(mediaSection, sessionpart) {
  const lines = SDPUtils.matchPrefix(mediaSection + sessionpart,
    'a=fingerprint:');
  // Note: a=setup line is ignored since we use the 'auto' role in Edge.
  return {
    role: 'auto',
    fingerprints: lines.map(SDPUtils.parseFingerprint),
  };
};

// Serializes DTLS parameters to SDP.
SDPUtils.writeDtlsParameters = function(params, setupType) {
  let sdp = 'a=setup:' + setupType + '\r\n';
  params.fingerprints.forEach(fp => {
    sdp += 'a=fingerprint:' + fp.algorithm + ' ' + fp.value + '\r\n';
  });
  return sdp;
};

// Parses a=crypto lines into
//   https://rawgit.com/aboba/edgertc/master/msortc-rs4.html#dictionary-rtcsrtpsdesparameters-members
SDPUtils.parseCryptoLine = function(line) {
  const parts = line.substring(9).split(' ');
  return {
    tag: parseInt(parts[0], 10),
    cryptoSuite: parts[1],
    keyParams: parts[2],
    sessionParams: parts.slice(3),
  };
};

SDPUtils.writeCryptoLine = function(parameters) {
  return 'a=crypto:' + parameters.tag + ' ' +
    parameters.cryptoSuite + ' ' +
    (typeof parameters.keyParams === 'object'
      ? SDPUtils.writeCryptoKeyParams(parameters.keyParams)
      : parameters.keyParams) +
    (parameters.sessionParams ? ' ' + parameters.sessionParams.join(' ') : '') +
    '\r\n';
};

// Parses the crypto key parameters into
//   https://rawgit.com/aboba/edgertc/master/msortc-rs4.html#rtcsrtpkeyparam*
SDPUtils.parseCryptoKeyParams = function(keyParams) {
  if (keyParams.indexOf('inline:') !== 0) {
    return null;
  }
  const parts = keyParams.substring(7).split('|');
  return {
    keyMethod: 'inline',
    keySalt: parts[0],
    lifeTime: parts[1],
    mkiValue: parts[2] ? parts[2].split(':')[0] : undefined,
    mkiLength: parts[2] ? parts[2].split(':')[1] : undefined,
  };
};

SDPUtils.writeCryptoKeyParams = function(keyParams) {
  return keyParams.keyMethod + ':'
    + keyParams.keySalt +
    (keyParams.lifeTime ? '|' + keyParams.lifeTime : '') +
    (keyParams.mkiValue && keyParams.mkiLength
      ? '|' + keyParams.mkiValue + ':' + keyParams.mkiLength
      : '');
};

// Extracts all SDES parameters.
SDPUtils.getCryptoParameters = function(mediaSection, sessionpart) {
  const lines = SDPUtils.matchPrefix(mediaSection + sessionpart,
    'a=crypto:');
  return lines.map(SDPUtils.parseCryptoLine);
};

// Parses ICE information from SDP media section or sessionpart.
// FIXME: for consistency with other functions this should only
//   get the ice-ufrag and ice-pwd lines as input.
SDPUtils.getIceParameters = function(mediaSection, sessionpart) {
  const ufrag = SDPUtils.matchPrefix(mediaSection + sessionpart,
    'a=ice-ufrag:')[0];
  const pwd = SDPUtils.matchPrefix(mediaSection + sessionpart,
    'a=ice-pwd:')[0];
  if (!(ufrag && pwd)) {
    return null;
  }
  return {
    usernameFragment: ufrag.substring(12),
    password: pwd.substring(10),
  };
};

// Serializes ICE parameters to SDP.
SDPUtils.writeIceParameters = function(params) {
  let sdp = 'a=ice-ufrag:' + params.usernameFragment + '\r\n' +
      'a=ice-pwd:' + params.password + '\r\n';
  if (params.iceLite) {
    sdp += 'a=ice-lite\r\n';
  }
  return sdp;
};

// Parses the SDP media section and returns RTCRtpParameters.
SDPUtils.parseRtpParameters = function(mediaSection) {
  const description = {
    codecs: [],
    headerExtensions: [],
    fecMechanisms: [],
    rtcp: [],
  };
  const lines = SDPUtils.splitLines(mediaSection);
  const mline = lines[0].split(' ');
  description.profile = mline[2];
  for (let i = 3; i < mline.length; i++) { // find all codecs from mline[3..]
    const pt = mline[i];
    const rtpmapline = SDPUtils.matchPrefix(
      mediaSection, 'a=rtpmap:' + pt + ' ')[0];
    if (rtpmapline) {
      const codec = SDPUtils.parseRtpMap(rtpmapline);
      const fmtps = SDPUtils.matchPrefix(
        mediaSection, 'a=fmtp:' + pt + ' ');
      // Only the first a=fmtp:<pt> is considered.
      codec.parameters = fmtps.length ? SDPUtils.parseFmtp(fmtps[0]) : {};
      codec.rtcpFeedback = SDPUtils.matchPrefix(
        mediaSection, 'a=rtcp-fb:' + pt + ' ')
        .map(SDPUtils.parseRtcpFb);
      description.codecs.push(codec);
      // parse FEC mechanisms from rtpmap lines.
      switch (codec.name.toUpperCase()) {
        case 'RED':
        case 'ULPFEC':
          description.fecMechanisms.push(codec.name.toUpperCase());
          break;
        default: // only RED and ULPFEC are recognized as FEC mechanisms.
          break;
      }
    }
  }
  SDPUtils.matchPrefix(mediaSection, 'a=extmap:').forEach(line => {
    description.headerExtensions.push(SDPUtils.parseExtmap(line));
  });
  const wildcardRtcpFb = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-fb:* ')
    .map(SDPUtils.parseRtcpFb);
  description.codecs.forEach(codec => {
    wildcardRtcpFb.forEach(fb=> {
      const duplicate = codec.rtcpFeedback.find(existingFeedback => {
        return existingFeedback.type === fb.type &&
          existingFeedback.parameter === fb.parameter;
      });
      if (!duplicate) {
        codec.rtcpFeedback.push(fb);
      }
    });
  });
  // FIXME: parse rtcp.
  return description;
};

// Generates parts of the SDP media section describing the capabilities /
// parameters.
SDPUtils.writeRtpDescription = function(kind, caps) {
  let sdp = '';

  // Build the mline.
  sdp += 'm=' + kind + ' ';
  sdp += caps.codecs.length > 0 ? '9' : '0'; // reject if no codecs.
  sdp += ' ' + (caps.profile || 'UDP/TLS/RTP/SAVPF') + ' ';
  sdp += caps.codecs.map(codec => {
    if (codec.preferredPayloadType !== undefined) {
      return codec.preferredPayloadType;
    }
    return codec.payloadType;
  }).join(' ') + '\r\n';

  sdp += 'c=IN IP4 0.0.0.0\r\n';
  sdp += 'a=rtcp:9 IN IP4 0.0.0.0\r\n';

  // Add a=rtpmap lines for each codec. Also fmtp and rtcp-fb.
  caps.codecs.forEach(codec => {
    sdp += SDPUtils.writeRtpMap(codec);
    sdp += SDPUtils.writeFmtp(codec);
    sdp += SDPUtils.writeRtcpFb(codec);
  });
  let maxptime = 0;
  caps.codecs.forEach(codec => {
    if (codec.maxptime > maxptime) {
      maxptime = codec.maxptime;
    }
  });
  if (maxptime > 0) {
    sdp += 'a=maxptime:' + maxptime + '\r\n';
  }

  if (caps.headerExtensions) {
    caps.headerExtensions.forEach(extension => {
      sdp += SDPUtils.writeExtmap(extension);
    });
  }
  // FIXME: write fecMechanisms.
  return sdp;
};

// Parses the SDP media section and returns an array of
// RTCRtpEncodingParameters.
SDPUtils.parseRtpEncodingParameters = function(mediaSection) {
  const encodingParameters = [];
  const description = SDPUtils.parseRtpParameters(mediaSection);
  const hasRed = description.fecMechanisms.indexOf('RED') !== -1;
  const hasUlpfec = description.fecMechanisms.indexOf('ULPFEC') !== -1;

  // filter a=ssrc:... cname:, ignore PlanB-msid
  const ssrcs = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')
    .map(line => SDPUtils.parseSsrcMedia(line))
    .filter(parts => parts.attribute === 'cname');
  const primarySsrc = ssrcs.length > 0 && ssrcs[0].ssrc;
  let secondarySsrc;

  const flows = SDPUtils.matchPrefix(mediaSection, 'a=ssrc-group:FID')
    .map(line => {
      const parts = line.substring(17).split(' ');
      return parts.map(part => parseInt(part, 10));
    });
  if (flows.length > 0 && flows[0].length > 1 && flows[0][0] === primarySsrc) {
    secondarySsrc = flows[0][1];
  }

  description.codecs.forEach(codec => {
    if (codec.name.toUpperCase() === 'RTX' && codec.parameters.apt) {
      let encParam = {
        ssrc: primarySsrc,
        codecPayloadType: parseInt(codec.parameters.apt, 10),
      };
      if (primarySsrc && secondarySsrc) {
        encParam.rtx = {ssrc: secondarySsrc};
      }
      encodingParameters.push(encParam);
      if (hasRed) {
        encParam = JSON.parse(JSON.stringify(encParam));
        encParam.fec = {
          ssrc: primarySsrc,
          mechanism: hasUlpfec ? 'red+ulpfec' : 'red',
        };
        encodingParameters.push(encParam);
      }
    }
  });
  if (encodingParameters.length === 0 && primarySsrc) {
    encodingParameters.push({
      ssrc: primarySsrc,
    });
  }

  // we support both b=AS and b=TIAS but interpret AS as TIAS.
  let bandwidth = SDPUtils.matchPrefix(mediaSection, 'b=');
  if (bandwidth.length) {
    if (bandwidth[0].indexOf('b=TIAS:') === 0) {
      bandwidth = parseInt(bandwidth[0].substring(7), 10);
    } else if (bandwidth[0].indexOf('b=AS:') === 0) {
      // use formula from JSEP to convert b=AS to TIAS value.
      bandwidth = parseInt(bandwidth[0].substring(5), 10) * 1000 * 0.95
          - (50 * 40 * 8);
    } else {
      bandwidth = undefined;
    }
    encodingParameters.forEach(params => {
      params.maxBitrate = bandwidth;
    });
  }
  return encodingParameters;
};

// parses http://draft.ortc.org/#rtcrtcpparameters*
SDPUtils.parseRtcpParameters = function(mediaSection) {
  const rtcpParameters = {};

  // Gets the first SSRC. Note that with RTX there might be multiple
  // SSRCs.
  const remoteSsrc = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')
    .map(line => SDPUtils.parseSsrcMedia(line))
    .filter(obj => obj.attribute === 'cname')[0];
  if (remoteSsrc) {
    rtcpParameters.cname = remoteSsrc.value;
    rtcpParameters.ssrc = remoteSsrc.ssrc;
  }

  // Edge uses the compound attribute instead of reducedSize
  // compound is !reducedSize
  const rsize = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-rsize');
  rtcpParameters.reducedSize = rsize.length > 0;
  rtcpParameters.compound = rsize.length === 0;

  // parses the rtcp-mux attrbute.
  // Note that Edge does not support unmuxed RTCP.
  const mux = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-mux');
  rtcpParameters.mux = mux.length > 0;

  return rtcpParameters;
};

SDPUtils.writeRtcpParameters = function(rtcpParameters) {
  let sdp = '';
  if (rtcpParameters.reducedSize) {
    sdp += 'a=rtcp-rsize\r\n';
  }
  if (rtcpParameters.mux) {
    sdp += 'a=rtcp-mux\r\n';
  }
  if (rtcpParameters.ssrc !== undefined && rtcpParameters.cname) {
    sdp += 'a=ssrc:' + rtcpParameters.ssrc +
      ' cname:' + rtcpParameters.cname + '\r\n';
  }
  return sdp;
};


// parses either a=msid: or a=ssrc:... msid lines and returns
// the id of the MediaStream and MediaStreamTrack.
SDPUtils.parseMsid = function(mediaSection) {
  let parts;
  const spec = SDPUtils.matchPrefix(mediaSection, 'a=msid:');
  if (spec.length === 1) {
    parts = spec[0].substring(7).split(' ');
    return {stream: parts[0], track: parts[1]};
  }
  const planB = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')
    .map(line => SDPUtils.parseSsrcMedia(line))
    .filter(msidParts => msidParts.attribute === 'msid');
  if (planB.length > 0) {
    parts = planB[0].value.split(' ');
    return {stream: parts[0], track: parts[1]};
  }
};

// SCTP
// parses draft-ietf-mmusic-sctp-sdp-26 first and falls back
// to draft-ietf-mmusic-sctp-sdp-05
SDPUtils.parseSctpDescription = function(mediaSection) {
  const mline = SDPUtils.parseMLine(mediaSection);
  const maxSizeLine = SDPUtils.matchPrefix(mediaSection, 'a=max-message-size:');
  let maxMessageSize;
  if (maxSizeLine.length > 0) {
    maxMessageSize = parseInt(maxSizeLine[0].substring(19), 10);
  }
  if (isNaN(maxMessageSize)) {
    maxMessageSize = 65536;
  }
  const sctpPort = SDPUtils.matchPrefix(mediaSection, 'a=sctp-port:');
  if (sctpPort.length > 0) {
    return {
      port: parseInt(sctpPort[0].substring(12), 10),
      protocol: mline.fmt,
      maxMessageSize,
    };
  }
  const sctpMapLines = SDPUtils.matchPrefix(mediaSection, 'a=sctpmap:');
  if (sctpMapLines.length > 0) {
    const parts = sctpMapLines[0]
      .substring(10)
      .split(' ');
    return {
      port: parseInt(parts[0], 10),
      protocol: parts[1],
      maxMessageSize,
    };
  }
};

// SCTP
// outputs the draft-ietf-mmusic-sctp-sdp-26 version that all browsers
// support by now receiving in this format, unless we originally parsed
// as the draft-ietf-mmusic-sctp-sdp-05 format (indicated by the m-line
// protocol of DTLS/SCTP -- without UDP/ or TCP/)
SDPUtils.writeSctpDescription = function(media, sctp) {
  let output = [];
  if (media.protocol !== 'DTLS/SCTP') {
    output = [
      'm=' + media.kind + ' 9 ' + media.protocol + ' ' + sctp.protocol + '\r\n',
      'c=IN IP4 0.0.0.0\r\n',
      'a=sctp-port:' + sctp.port + '\r\n',
    ];
  } else {
    output = [
      'm=' + media.kind + ' 9 ' + media.protocol + ' ' + sctp.port + '\r\n',
      'c=IN IP4 0.0.0.0\r\n',
      'a=sctpmap:' + sctp.port + ' ' + sctp.protocol + ' 65535\r\n',
    ];
  }
  if (sctp.maxMessageSize !== undefined) {
    output.push('a=max-message-size:' + sctp.maxMessageSize + '\r\n');
  }
  return output.join('');
};

// Generate a session ID for SDP.
// https://tools.ietf.org/html/draft-ietf-rtcweb-jsep-20#section-5.2.1
// recommends using a cryptographically random +ve 64-bit value
// but right now this should be acceptable and within the right range
SDPUtils.generateSessionId = function() {
  return Math.random().toString().substr(2, 22);
};

// Write boiler plate for start of SDP
// sessId argument is optional - if not supplied it will
// be generated randomly
// sessVersion is optional and defaults to 2
// sessUser is optional and defaults to 'thisisadapterortc'
SDPUtils.writeSessionBoilerplate = function(sessId, sessVer, sessUser) {
  let sessionId;
  const version = sessVer !== undefined ? sessVer : 2;
  if (sessId) {
    sessionId = sessId;
  } else {
    sessionId = SDPUtils.generateSessionId();
  }
  const user = sessUser || 'thisisadapterortc';
  // FIXME: sess-id should be an NTP timestamp.
  return 'v=0\r\n' +
      'o=' + user + ' ' + sessionId + ' ' + version +
        ' IN IP4 127.0.0.1\r\n' +
      's=-\r\n' +
      't=0 0\r\n';
};

// Gets the direction from the mediaSection or the sessionpart.
SDPUtils.getDirection = function(mediaSection, sessionpart) {
  // Look for sendrecv, sendonly, recvonly, inactive, default to sendrecv.
  const lines = SDPUtils.splitLines(mediaSection);
  for (let i = 0; i < lines.length; i++) {
    switch (lines[i]) {
      case 'a=sendrecv':
      case 'a=sendonly':
      case 'a=recvonly':
      case 'a=inactive':
        return lines[i].substring(2);
      default:
        // FIXME: What should happen here?
    }
  }
  if (sessionpart) {
    return SDPUtils.getDirection(sessionpart);
  }
  return 'sendrecv';
};

SDPUtils.getKind = function(mediaSection) {
  const lines = SDPUtils.splitLines(mediaSection);
  const mline = lines[0].split(' ');
  return mline[0].substring(2);
};

SDPUtils.isRejected = function(mediaSection) {
  return mediaSection.split(' ', 2)[1] === '0';
};

SDPUtils.parseMLine = function(mediaSection) {
  const lines = SDPUtils.splitLines(mediaSection);
  const parts = lines[0].substring(2).split(' ');
  return {
    kind: parts[0],
    port: parseInt(parts[1], 10),
    protocol: parts[2],
    fmt: parts.slice(3).join(' '),
  };
};

SDPUtils.parseOLine = function(mediaSection) {
  const line = SDPUtils.matchPrefix(mediaSection, 'o=')[0];
  const parts = line.substring(2).split(' ');
  return {
    username: parts[0],
    sessionId: parts[1],
    sessionVersion: parseInt(parts[2], 10),
    netType: parts[3],
    addressType: parts[4],
    address: parts[5],
  };
};

// a very naive interpretation of a valid SDP.
SDPUtils.isValidSDP = function(blob) {
  if (typeof blob !== 'string' || blob.length === 0) {
    return false;
  }
  const lines = SDPUtils.splitLines(blob);
  for (let i = 0; i < lines.length; i++) {
    if (lines[i].length < 2 || lines[i].charAt(1) !== '=') {
      return false;
    }
    // TODO: check the modifier a bit more.
  }
  return true;
};

// Expose public methods.
if (true) {
  module.exports = SDPUtils;
}


/***/ }),

/***/ 5298:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var isProduction = "production" === 'production';
function warning(condition, message) {
  if (!isProduction) {
    if (condition) {
      return;
    }

    var text = "Warning: " + message;

    if (typeof console !== 'undefined') {
      console.warn(text);
    }

    try {
      throw Error(text);
    } catch (x) {}
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (warning);


/***/ }),

/***/ 9980:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __webpack_require__(655);
tslib_1.__exportStar(__webpack_require__(693), exports);
tslib_1.__exportStar(__webpack_require__(4366), exports);
tslib_1.__exportStar(__webpack_require__(9399), exports);


/***/ }),

/***/ 4790:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ApplyUrlHack = exports.UrlBuilder = void 0;
const lib_pixelstreamingfrontend_ue5_5_1 = __webpack_require__(693);
function UrlBuilder(input, urlFlags) {
    const url = new URL(decodeURIComponent(input()));
    const params = url.searchParams;
    let flags = urlFlags;
    if (flags) {
        if (flags.startsWith("?"))
            flags = flags.substring(1);
        flags.split("&").forEach((val) => {
            const [key, value] = val.split("=");
            // Ensure the value is encoded
            params.set(key, value);
        });
    }
    return url.toString();
}
exports.UrlBuilder = UrlBuilder;
// Hack
function ApplyUrlHack() {
    const setWebRtcPlayerController = lib_pixelstreamingfrontend_ue5_5_1.PixelStreaming.prototype["setWebRtcPlayerController"];
    lib_pixelstreamingfrontend_ue5_5_1.PixelStreaming.prototype["setWebRtcPlayerController"] = function setWebRtcPlayerControllerOverride(webRtcPlayerController) {
        /** The default url builder will simply add a query-parameter without checking the initial url.
         * To fix that if the url already comes with query-parameters the output has to be rewritten. */
        const signallingUrlBuilder = webRtcPlayerController.signallingUrlBuilder;
        webRtcPlayerController.signallingUrlBuilder = () => {
            return UrlBuilder(signallingUrlBuilder, this.config.urlFlags);
        };
        setWebRtcPlayerController.call(this, webRtcPlayerController);
    };
}
exports.ApplyUrlHack = ApplyUrlHack;


/***/ }),

/***/ 9783:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ArcwareApplication = void 0;
const tslib_1 = __webpack_require__(655);
const lib_pixelstreamingfrontend_ue5_5_1 = __webpack_require__(693);
const lib_pixelstreamingfrontend_ui_ue5_5_1 = __webpack_require__(4366);
const ArcwarePixelStreamingApplicationStyles_1 = __webpack_require__(2299);
const AudioButton_1 = __webpack_require__(7734);
const MicButton_1 = __webpack_require__(2293);
const StopButton_1 = __webpack_require__(9684);
const ArcwareEventUtil_1 = __webpack_require__(471);
const ArcwareFileTransferUtil_1 = __webpack_require__(2768);
const common_1 = __webpack_require__(2483);
const DEBUG = false;
const TextKeyRegex = /^(\['([a-zA-Z 0-9-_]+)'\] )/;
function findElementByTextContent(root, selector) {
    const match = TextKeyRegex.exec(selector);
    if (!match)
        return null;
    const actualSelector = selector.replace(match[1], "");
    const text = match[2].trim();
    const elements = (root || document).querySelectorAll(actualSelector);
    let result = null;
    elements.forEach((element) => {
        var _a;
        const elementText = element === null || element === void 0 ? void 0 : element.innerHTML.trim();
        if (!result && ((_a = element === null || element === void 0 ? void 0 : element.innerHTML) === null || _a === void 0 ? void 0 : _a.includes(`>${text}<`))) {
            result = element;
        }
    });
    return result;
}
const removals = {
    // Is not used by Arcware system - may need additional checking.
    "#StreamerId": true,
    // Signalling-Server
    "#ss": true,
    // Is not working with our AFK Setup.
    "#TimeoutIfIdle": true,
    // OfferToReceive needs to be enabled in Arcware cloud environment.
    "#OfferToReceive": true,
    // SFU can't be handled in cloud environment.
    "#preferSFU": true,
    // STUN / TURN can't be handled in cloud environment.
    "#ForceTURN": true,
    // Arcware UI does not support Light or Dark mode.
    "#LightMode": true,
    // By default the UseMic setting should be disabled, since the won't work with 4.27 anyway.
    "#UseMic": true,
    // By default the MatchViewportRes setting should be disabled, since we have a custom method for that.
    "#MatchViewportRes": true,
    // By default the HoveringMouse setting should be disabled, since we have a custom method for that.
    "#HoveringMouse": true,
    // AFK Idle time.
    "['AFK timeout'] div.setting.form-group:not([id])": true,
    // By default the encoder settings should be disabled, since the won't work with 4.27 anyway.
    "['Encoder'] section.settingsContainer:not([id])": true,
    // By default the WebRTC settings should be disabled, since the won't work with 4.27 anyway.
    "['WebRTC'] section.settingsContainer:not([id])": true,
    // By default the UI settings should be disabled, since we have a custom method for them.
    "['UI'] section.settingsContainer:not([id])": true,
    // Hide option of start audio muted or not
    "#StartVideoMuted": true
};
if (DEBUG)
    Object.keys(removals).forEach((key) => {
        removals[key] = false;
    });
function remove(key, element) {
    if (removals[key] === true) {
        if (element) {
            element.style.display = "none";
        }
    }
    else if (DEBUG) {
        if (element) {
            element.style.color = "red";
        }
    }
}
class ArcwareApplication extends lib_pixelstreamingfrontend_ui_ue5_5_1.Application {
    get rootElement() {
        return super.rootElement;
    }
    constructor(options) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        super(options);
        this.responseCallback = null;
        this.analyticsEventCallback = null;
        this.fileDownloadCallback = null;
        this.ArcwareSection = this.configUI.buildSectionWithHeading(this.settingsPanel.settingsContentElement, "Arcware Cloud");
        this.stream = options === null || options === void 0 ? void 0 : options.stream;
        this.emitUIInteraction = this.emitUIInteraction.bind(this);
        this.adjustSettingsPanel();
        this.createAudioToggleButton();
        this.createMicToggleButton();
        this.createStopButton();
        this.applyArcwareStyles();
        this.videoElementParent = (_a = this === null || this === void 0 ? void 0 : this.stream) === null || _a === void 0 ? void 0 : _a.videoElementParent;
        this.parentElement = (_b = this === null || this === void 0 ? void 0 : this.videoElementParent) === null || _b === void 0 ? void 0 : _b.parentElement;
        this.webRtcController = (_c = this === null || this === void 0 ? void 0 : this.stream) === null || _c === void 0 ? void 0 : _c["_webRtcController"];
        this.addLoveLetterhandler();
        (_d = this === null || this === void 0 ? void 0 : this.stream) === null || _d === void 0 ? void 0 : _d.addResponseEventListener("ue-response-internal", (response) => this.applicationResponse(response));
        (_f = (_e = this === null || this === void 0 ? void 0 : this.stream) === null || _e === void 0 ? void 0 : _e.sessionIdHandler) === null || _f === void 0 ? void 0 : _f.add((sessionId) => {
            var _a;
            (_a = this === null || this === void 0 ? void 0 : this.statsPanel) === null || _a === void 0 ? void 0 : _a.addOrUpdateSessionStat("sessionId", "SessionId", sessionId);
        });
        (_h = (_g = this === null || this === void 0 ? void 0 : this.stream) === null || _g === void 0 ? void 0 : _g.videoInitializedHandler) === null || _h === void 0 ? void 0 : _h.add(() => {
            var _a, _b, _c;
            (_a = this === null || this === void 0 ? void 0 : this.currentOverlay) === null || _a === void 0 ? void 0 : _a.hide();
            if ((_b = this === null || this === void 0 ? void 0 : this.stream) === null || _b === void 0 ? void 0 : _b.streamInfo)
                this === null || this === void 0 ? void 0 : this.autoPlayHandler((_c = this === null || this === void 0 ? void 0 : this.stream) === null || _c === void 0 ? void 0 : _c.streamInfo);
        });
        const uiHandler = () => {
            // Remove fullscreen UI Default buttons from DOM
            this === null || this === void 0 ? void 0 : this.uiDefaultButtonVisibilty("fullscreenButton", "#fullscreen-btn");
            this === null || this === void 0 ? void 0 : this.uiDefaultButtonVisibilty("settingsButton", "#settingsBtn");
            this === null || this === void 0 ? void 0 : this.uiDefaultButtonVisibilty("infoButton", "#statsBtn");
            this === null || this === void 0 ? void 0 : this.uiDefaultButtonVisibilty("audioButton", "#audioBtn");
            this === null || this === void 0 ? void 0 : this.uiDefaultButtonVisibilty("stopButton", "#stopBtn");
            this === null || this === void 0 ? void 0 : this.uiDefaultButtonVisibilty("connectionStrengthIcon", "#connection");
            this === null || this === void 0 ? void 0 : this.uiDefaultButtonVisibilty("micButton", "#micBtn");
            this.uiElementsVisibility(true);
        };
        // Either on streamInfo
        // this?.stream.streamInfoHandler.add(uiHandler.bind(this));
        // Or on initialize.
        (_k = (_j = this === null || this === void 0 ? void 0 : this.stream) === null || _j === void 0 ? void 0 : _j.videoInitializedHandler) === null || _k === void 0 ? void 0 : _k.add(uiHandler.bind(this));
        this.uiElementsVisibility(false);
        this.addTextToConnectOverlay();
        this.preventDefaultKeyboardEvents();
        this.analyticsEventCallback = this.analyticsEvent;
        this.fileDownloadCallback = this.fileDownload;
    }
    addLoveLetterhandler() {
        var _a, _b;
        (_b = (_a = this === null || this === void 0 ? void 0 : this.stream) === null || _a === void 0 ? void 0 : _a.loveLetterHandler) === null || _b === void 0 ? void 0 : _b.add((loveLetter) => {
            var _a, _b, _c;
            if ((this === null || this === void 0 ? void 0 : this.playOverlay) && loveLetter && (this === null || this === void 0 ? void 0 : this.parentElement)) {
                const infoOverlay = (_a = this === null || this === void 0 ? void 0 : this.parentElement) === null || _a === void 0 ? void 0 : _a.querySelector("#infoOverlay");
                if (infoOverlay) {
                    (_b = infoOverlay === null || infoOverlay === void 0 ? void 0 : infoOverlay.classList) === null || _b === void 0 ? void 0 : _b.remove("hiddenState");
                    const message = infoOverlay === null || infoOverlay === void 0 ? void 0 : infoOverlay.querySelector("#messageOverlayInner");
                    if (message) {
                        message.innerHTML = (_c = loveLetter === null || loveLetter === void 0 ? void 0 : loveLetter.reason) === null || _c === void 0 ? void 0 : _c.replace("LL: ", "");
                    }
                }
                // this.playOverlay.textElement.innerText = loveLetter.reason.replace("LL: ", "");
            }
        });
    }
    /** Set's and resets hidden state of "additional" UI Elements.
     * For example buttons or connection icon.
     * These will fade in through css animation upon the videoInitialized event.
     * At this point in time the streamInfo is already processed.
     */
    uiElementsVisibility(state) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        const controls = (_a = this === null || this === void 0 ? void 0 : this.parentElement) === null || _a === void 0 ? void 0 : _a.querySelector("#controls");
        if (controls) {
            if (state) {
                (_b = controls === null || controls === void 0 ? void 0 : controls.classList) === null || _b === void 0 ? void 0 : _b.remove("hidden");
                (_c = controls === null || controls === void 0 ? void 0 : controls.classList) === null || _c === void 0 ? void 0 : _c.add("visible");
            }
            else {
                (_d = controls === null || controls === void 0 ? void 0 : controls.classList) === null || _d === void 0 ? void 0 : _d.remove("visible");
                (_e = controls === null || controls === void 0 ? void 0 : controls.classList) === null || _e === void 0 ? void 0 : _e.add("hidden");
            }
        }
        const connection = (_f = this === null || this === void 0 ? void 0 : this.parentElement) === null || _f === void 0 ? void 0 : _f.querySelector("#connection");
        if (connection) {
            if (state) {
                (_g = connection === null || connection === void 0 ? void 0 : connection.classList) === null || _g === void 0 ? void 0 : _g.remove("hidden");
                (_h = connection === null || connection === void 0 ? void 0 : connection.classList) === null || _h === void 0 ? void 0 : _h.add("visible");
            }
            else {
                (_j = connection === null || connection === void 0 ? void 0 : connection.classList) === null || _j === void 0 ? void 0 : _j.remove("visible");
                (_k = connection === null || connection === void 0 ? void 0 : connection.classList) === null || _k === void 0 ? void 0 : _k.add("hidden");
            }
        }
    }
    adjustSettingsPanel() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
        // Make Arcware Cloud settings the first element of the settings panel.
        const parent = (_a = this === null || this === void 0 ? void 0 : this.ArcwareSection) === null || _a === void 0 ? void 0 : _a.parentElement;
        if (parent) {
            parent === null || parent === void 0 ? void 0 : parent.removeChild(this === null || this === void 0 ? void 0 : this.ArcwareSection);
            parent === null || parent === void 0 ? void 0 : parent.insertBefore(this === null || this === void 0 ? void 0 : this.ArcwareSection, parent === null || parent === void 0 ? void 0 : parent.firstChild);
        }
        // Remove all the settings specified by "removals" object.
        const SettingsContent = (_b = this === null || this === void 0 ? void 0 : this.settingsPanel) === null || _b === void 0 ? void 0 : _b.settingsContentElement;
        if (SettingsContent) {
            SettingsContent.style.minWidth = "400px";
            for (const key in removals) {
                if (TextKeyRegex.test(key)) {
                    const element = findElementByTextContent(SettingsContent, key);
                    remove(key, element);
                }
                else {
                    const element = SettingsContent.querySelector(key);
                    remove(key, element);
                }
            }
            // Renaming the "Restart Stream" button to "Reconnect to Stream".
            const restartStreamButton = findElementByTextContent(SettingsContent, "['Restart Stream'] section > div.setting");
            if (restartStreamButton) {
                const label = restartStreamButton === null || restartStreamButton === void 0 ? void 0 : restartStreamButton.querySelector("div");
                if (label)
                    label.textContent = "Reconnect to Stream";
                const button = restartStreamButton === null || restartStreamButton === void 0 ? void 0 : restartStreamButton.querySelector("label > input");
                if (button)
                    button.value = "reconnect";
            }
        }
        // Append disclaimer
        {
            const disclaimer = document.createElement("div");
            (_c = disclaimer === null || disclaimer === void 0 ? void 0 : disclaimer.classList) === null || _c === void 0 ? void 0 : _c.add("setting");
            disclaimer.textContent = "Keep in mind, these settings will be applied in your current session only.";
            disclaimer.style.paddingBottom = "15px";
            (_d = this === null || this === void 0 ? void 0 : this.ArcwareSection) === null || _d === void 0 ? void 0 : _d.appendChild(disclaimer);
        }
        // Add disable SessionId button.
        (_e = this === null || this === void 0 ? void 0 : this.ArcwareSection) === null || _e === void 0 ? void 0 : _e.appendChild(new lib_pixelstreamingfrontend_ui_ue5_5_1.SettingUIFlag(new lib_pixelstreamingfrontend_ue5_5_1.SettingFlag((_f = ArcwareApplication === null || ArcwareApplication === void 0 ? void 0 : ArcwareApplication.Flags) === null || _f === void 0 ? void 0 : _f.noSession, "Disable SessionId", "Disable sessionId based reconnection.", (_h = (_g = this === null || this === void 0 ? void 0 : this.stream) === null || _g === void 0 ? void 0 : _g.session) === null || _h === void 0 ? void 0 : _h.noSession, true)).rootElement);
        // Add rephrasing of signalling Url.
        (_j = this === null || this === void 0 ? void 0 : this.ArcwareSection) === null || _j === void 0 ? void 0 : _j.appendChild(new lib_pixelstreamingfrontend_ui_ue5_5_1.SettingUIText(new lib_pixelstreamingfrontend_ue5_5_1.SettingText("signalling-url", "Signalling URL", "Signalling URL", `${(_l = (_k = this === null || this === void 0 ? void 0 : this.stream) === null || _k === void 0 ? void 0 : _k.config) === null || _l === void 0 ? void 0 : _l.getTextSettingValue("ss")}?${(_p = (_o = (_m = this === null || this === void 0 ? void 0 : this.stream) === null || _m === void 0 ? void 0 : _m.config) === null || _o === void 0 ? void 0 : _o.urlFlags) === null || _p === void 0 ? void 0 : _p.slice(1)}`, false)).rootElement);
        if (DEBUG)
            setTimeout(() => {
                var _a;
                (_a = document.querySelector("#settingsBtn")) === null || _a === void 0 ? void 0 : _a.click();
            }, 2000);
    }
    createAudioToggleButton() {
        var _a;
        const audioButton = new AudioButton_1.AudioButton(this === null || this === void 0 ? void 0 : this.stream);
        const videoElementParent = (_a = this === null || this === void 0 ? void 0 : this.stream) === null || _a === void 0 ? void 0 : _a.videoElementParent;
        const playerUI = videoElementParent.parentElement;
        // Append the button to the videoElementParent
        if (playerUI) {
            const uiFeatures = playerUI === null || playerUI === void 0 ? void 0 : playerUI.querySelector("#uiFeatures");
            if (uiFeatures) {
                const uiControls = uiFeatures === null || uiFeatures === void 0 ? void 0 : uiFeatures.querySelector("#controls");
                if (uiControls) {
                    uiControls === null || uiControls === void 0 ? void 0 : uiControls.appendChild(audioButton === null || audioButton === void 0 ? void 0 : audioButton.element);
                }
            }
        }
    }
    createMicToggleButton() {
        var _a;
        const micButton = new MicButton_1.MicButton(this === null || this === void 0 ? void 0 : this.stream);
        const videoElementParent = (_a = this === null || this === void 0 ? void 0 : this.stream) === null || _a === void 0 ? void 0 : _a.videoElementParent;
        const playerUI = videoElementParent.parentElement;
        // Append the button to the videoElementParent
        if (playerUI) {
            const uiFeatures = playerUI === null || playerUI === void 0 ? void 0 : playerUI.querySelector("#uiFeatures");
            if (uiFeatures) {
                const uiControls = uiFeatures === null || uiFeatures === void 0 ? void 0 : uiFeatures.querySelector("#controls");
                if (uiControls) {
                    uiControls === null || uiControls === void 0 ? void 0 : uiControls.appendChild(micButton === null || micButton === void 0 ? void 0 : micButton.element);
                }
            }
        }
    }
    createStopButton() {
        var _a, _b, _c, _d;
        if (((_c = (_b = (_a = this.stream) === null || _a === void 0 ? void 0 : _a.config) === null || _b === void 0 ? void 0 : _b.settings) === null || _c === void 0 ? void 0 : _c.stopButton) === true) {
            const stopButton = new StopButton_1.StopButton(this === null || this === void 0 ? void 0 : this.stream);
            const videoElementParent = (_d = this === null || this === void 0 ? void 0 : this.stream) === null || _d === void 0 ? void 0 : _d.videoElementParent;
            const playerUI = videoElementParent.parentElement;
            // Append the button to the videoElementParent
            if (playerUI) {
                const uiFeatures = playerUI === null || playerUI === void 0 ? void 0 : playerUI.querySelector("#uiFeatures");
                if (uiFeatures) {
                    const uiControls = uiFeatures === null || uiFeatures === void 0 ? void 0 : uiFeatures.querySelector("#controls");
                    if (uiControls) {
                        uiControls === null || uiControls === void 0 ? void 0 : uiControls.appendChild(stopButton === null || stopButton === void 0 ? void 0 : stopButton.element);
                    }
                }
            }
        }
    }
    uiDefaultButtonVisibilty(buttonType, id) {
        var _a, _b, _c;
        if (this === null || this === void 0 ? void 0 : this.parentElement) {
            const button = (_a = this === null || this === void 0 ? void 0 : this.parentElement) === null || _a === void 0 ? void 0 : _a.querySelector(id);
            if (((_c = (_b = this === null || this === void 0 ? void 0 : this.stream) === null || _b === void 0 ? void 0 : _b.config) === null || _c === void 0 ? void 0 : _c.settings[buttonType]) === false) {
                if (button) {
                    button === null || button === void 0 ? void 0 : button.remove();
                    const uiFeaturesElement = this.uiFeaturesElement;
                    const statsPanel = uiFeaturesElement.querySelector("#stats-panel");
                    const settingsPanel = uiFeaturesElement.querySelector("#settings-panel");
                    if (uiFeaturesElement) {
                        if (buttonType === "infoButton") {
                            statsPanel === null || statsPanel === void 0 ? void 0 : statsPanel.remove();
                        }
                        if (buttonType === "settingsButton") {
                            settingsPanel === null || settingsPanel === void 0 ? void 0 : settingsPanel.remove();
                        }
                    }
                }
            }
            const isIOS = /iPad|iPhone|iPod/.test(navigator === null || navigator === void 0 ? void 0 : navigator.userAgent);
            if (buttonType === "fullscreenButton" && isIOS && button) {
                button === null || button === void 0 ? void 0 : button.remove();
            }
        }
    }
    preventDefaultKeyboardEvents() {
        if (this.videoElementParent) {
            this.videoElementParent.addEventListener("keydown", function (event) {
                if (event.key === "Tab" || event.key === " " || event.key === "Spacebar") {
                    // Prevent the default action and stop propagation
                    event.preventDefault();
                    event.stopPropagation();
                }
            }, true); // Use capturing instead of bubbling
            const buttons = this.uiFeaturesElement.querySelectorAll("button");
            buttons.forEach((button) => {
                button.addEventListener("keydown", function (event) {
                    if (event.key === " " || event.key === "Spacebar") {
                        event.preventDefault();
                        button.blur();
                    }
                });
            });
        }
    }
    autoPlayHandler(streamInfo) {
        var _a;
        const { videoPlayer } = this === null || this === void 0 ? void 0 : this.webRtcController;
        const autoPlay = (_a = streamInfo === null || streamInfo === void 0 ? void 0 : streamInfo.streamInfo) === null || _a === void 0 ? void 0 : _a.autoPlay;
        const isPaused = videoPlayer === null || videoPlayer === void 0 ? void 0 : videoPlayer.isPaused();
        if (autoPlay && isPaused) {
            if (videoPlayer) {
                const videoElement = videoPlayer === null || videoPlayer === void 0 ? void 0 : videoPlayer.getVideoElement();
                if (videoElement) {
                    const parentElement = videoElement === null || videoElement === void 0 ? void 0 : videoElement.parentElement;
                    if (parentElement) {
                        const playOverlay = parentElement === null || parentElement === void 0 ? void 0 : parentElement.querySelector("#playOverlay");
                        if (playOverlay)
                            playOverlay === null || playOverlay === void 0 ? void 0 : playOverlay.remove();
                    }
                    videoElement === null || videoElement === void 0 ? void 0 : videoElement.play();
                }
            }
        }
    }
    /** Request a response from you UE Application.
     * The returned response depends on the implementation of your UE Application.
     * It can be used to request information from the application, such as:
     * - a state to update your custom ui
     * - get the url to the pdf it uploaded to some remote service of yours
     * - the id of the save-game
     * .. anything else you could imagine.
     */
    getApplicationResponse(callback) {
        var _a;
        (_a = this === null || this === void 0 ? void 0 : this.stream) === null || _a === void 0 ? void 0 : _a.addResponseEventListener("ue-response", (response) => {
            callback(response);
        });
    }
    applicationResponse(response) {
        var _a, _b, _c, _d;
        let obj;
        try {
            obj = (0, common_1.parseUnknownToObject)(response, { allowJsonish: true });
        }
        catch (_e) {
            // not parseable  just send to generic handler and bail out
            (_a = this.responseCallback) === null || _a === void 0 ? void 0 : _a.call(this, response);
            return;
        }
        const t = (0, common_1.normalizeType)(obj["type"]);
        // route to exactly one callback
        if (t === "event") {
            (_b = this.analyticsEventCallback) === null || _b === void 0 ? void 0 : _b.call(this, response);
            return;
        }
        if (t === "filetransfer" || t === "createscreenshot") {
            (_c = this.fileDownloadCallback) === null || _c === void 0 ? void 0 : _c.call(this, response);
            return;
        }
        // fallback: unknown type  generic callback
        (_d = this.responseCallback) === null || _d === void 0 ? void 0 : _d.call(this, response);
    }
    applyArcwareStyles() {
        const PixelStreamingApplicationStyles = new lib_pixelstreamingfrontend_ui_ue5_5_1.PixelStreamingApplicationStyle(ArcwarePixelStreamingApplicationStyles_1.ArcwareStyles);
        PixelStreamingApplicationStyles === null || PixelStreamingApplicationStyles === void 0 ? void 0 : PixelStreamingApplicationStyles.applyStyleSheet();
    }
    /** Emit an event towards the UE Application.
     * Mainly used to bubble events like a button press or other command inputs towards the UE Application.
     */
    emitUIInteraction(descriptor) {
        var _a;
        if (descriptor) {
            (_a = this === null || this === void 0 ? void 0 : this.webRtcController) === null || _a === void 0 ? void 0 : _a.emitUIInteraction(descriptor);
        }
    }
    // Creates a helper text for the Connection Overlay
    addTextToConnectOverlay() {
        var _a, _b, _c, _d;
        if (!((_c = (_b = (_a = this === null || this === void 0 ? void 0 : this.stream) === null || _a === void 0 ? void 0 : _a.config) === null || _b === void 0 ? void 0 : _b.initialSettings) === null || _c === void 0 ? void 0 : _c.AutoConnect)) {
            if (this.videoElementParent) {
                const connectOverlay = (_d = this === null || this === void 0 ? void 0 : this.parentElement) === null || _d === void 0 ? void 0 : _d.querySelector("#connectOverlay");
                if (connectOverlay) {
                    const connectionText = document.createElement("div");
                    connectionText.className = "connection-text";
                    connectOverlay.appendChild(connectionText);
                    const title = document.createElement("p");
                    title.className = "title";
                    title.textContent = "Click on the button below to start the connection to the streaming.";
                    connectionText.appendChild(title);
                    const subtitle = document.createElement("p");
                    subtitle.className = "subtitle";
                    subtitle.textContent =
                        "After clicking the button, it may take a few seconds for the connection to start. Don't worry if you don't see an immediate reaction.";
                    connectionText.appendChild(subtitle);
                }
            }
        }
    }
    analyticsEvent(response) {
        var _a;
        const event = (0, ArcwareEventUtil_1.toAnalyticsEvent)(response, { maxPayloadBytes: 512, allowJsonish: true });
        if (event.ok === false) {
            console.warn("Invalid AnalyticsEvent:", event.error, response);
            return;
        }
        (_a = this.stream) === null || _a === void 0 ? void 0 : _a.send(event.value); // send the sanitized object
    }
    fileDownload(response) {
        var _a;
        let msg;
        try {
            msg = (0, ArcwareFileTransferUtil_1.parseControl)(response, ArcwareFileTransferUtil_1.ZFileTransfer);
        }
        catch (e) {
            console.warn("Invalid control message:", e);
            return;
        }
        const file = (_a = this.webRtcController) === null || _a === void 0 ? void 0 : _a.file;
        if (!file || !file.data || !file.mimetype)
            return;
        const ext = (0, common_1.extFromMime)(file.mimetype);
        const base = msg.filename && msg.filename.trim() ? (0, common_1.sanitizeFilename)(msg.filename) : (0, common_1.randomHash)();
        const name = base + ext;
        try {
            //  Make safe Blob parts (clone each chunk to ensure regular ArrayBuffer)
            const chunks = file.data; // <-- remove the generic
            const safeParts = chunks.map((u8) => u8.slice()); // fresh ArrayBuffers
            const blob = new Blob(safeParts, { type: file.mimetype });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = name;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            setTimeout(() => URL.revokeObjectURL(url), 0);
        }
        catch (err) {
            console.error("Download failed:", err);
        }
    }
}
ArcwareApplication.Flags = (_a = class {
    },
    tslib_1.__setFunctionName(_a, "Flags"),
    _a.noSession = "noSession",
    _a);
exports.ArcwareApplication = ArcwareApplication;


/***/ }),

/***/ 3995:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ArcwareConfig = exports.DefaultUrl = void 0;
const zod_1 = __webpack_require__(8754);
const lib_pixelstreamingfrontend_ue5_5_1 = __webpack_require__(693);
const Session_1 = __webpack_require__(2469);
const ArcwareSettingsSchema_1 = __webpack_require__(5602);
/** Default arcware signalling endpoint. */
exports.DefaultUrl = `wss://signalling-client.ragnarok.arcware.cloud`;
// The below Logger overrides can likely be removed as PSInfra 5.5 logger supports setting log verbosity
// and these overrides are matching the default logging behaviour anyway (except info).
/*Logger.Info = (message: string) => {
  // console.info(message);
};
Logger.Warning = (message: string) => {
  console.warn(message);
};
Logger.Error = (message: string) => {
  if (message?.startsWith("unhandled Stat Type")) return;
  console.error(message);
};*/
lib_pixelstreamingfrontend_ue5_5_1.Logger.InitLogging(2, false);
class ArcwareConfig extends lib_pixelstreamingfrontend_ue5_5_1.Config {
    /**
     * Can be used to fetch projectId and shareId from the current url.
     * Example:
     * /something/:projectId/:shareId/something?something => { projectId, shareId }
     * /:projectId => { projectId }
     * /:shareId => { shareId }
     * /:shareId/:projectId => { projectId, shareId }
     *
     * The projectId must be uuidv4.
     * The shareId must be "shareId-" prefixed.
     *
     * Usage:
     * // This will spread the projectId and the shareId into the settings. Define anything you want to override after the spread operation.
     * new ArcwareConfig({ settings: { ...ArcwareConfig.PickIdsOfUrl() } });
     */
    static PickIdsOfUrl() {
        const { pathname } = new URL(window.location.href);
        const sections = pathname.split("/");
        const projectId = sections.find((section) => zod_1.z.string().uuid().safeParse(section).success);
        const shareId = sections.find((section) => zod_1.z.string().startsWith("share-").safeParse(section).success);
        return {
            projectId,
            shareId
        };
    }
    constructor(config) {
        var _a, _b;
        const dfToken = new URL(window.location.href).search
            .slice(1)
            .split("&")
            .find((qp) => qp.startsWith("df-"));
        if (!dfToken && !config.settings.shareId && !config.settings.projectId) {
            throw new Error(`ShareId or ProjectId must be specified.`);
        }
        // Validate settings input.
        const settings = ArcwareSettingsSchema_1.ArcwareSettingsSchema.parse(config.settings);
        // Setup arcware default settings.
        if (!config.initialSettings)
            config.initialSettings = {};
        if (!((_a = config.initialSettings) === null || _a === void 0 ? void 0 : _a.hasOwnProperty("AutoConnect")))
            config.initialSettings.AutoConnect = false;
        // if (!config.initialSettings?.hasOwnProperty("HoveringMouse")) config.initialSettings.HoveringMouse = true;
        if (!((_b = config.initialSettings) === null || _b === void 0 ? void 0 : _b.hasOwnProperty("AFKTimeout")))
            config.initialSettings.AFKTimeout = 600;
        if (!config.initialSettings.ss)
            config.initialSettings.ss = exports.DefaultUrl;
        super(config);
        this.VERSION = "1.3.12";
        this.settings = settings;
        this.session = new Session_1.Session();
        this._initialSettings = config.initialSettings;
        // Setup arcware default settings.
        this.setFlagEnabled(lib_pixelstreamingfrontend_ue5_5_1.Flags.AFKDetection, true);
        // IMPORTANT NOTE: The feature BrowserSendOffer is no longer supported in PSInfra 5.5.
        // The offer is now expected to come from UE. Ensure that your signalling server supports this behaviour.
        //this.setFlagEnabled(Flags.BrowserSendOffer, true);
    }
    /** Setup connection string. */
    get urlFlags() {
        var _a;
        let flags = "";
        // Setup connection via shareId.
        if (this.settings.shareId)
            flags += `&sh=${this.settings.shareId}`;
        // Additionally setup the projectId property if the shareId is set up with multiple projects.
        if (this.settings.projectId)
            flags += `&p=${this.settings.projectId}`;
        // Setup direct session connection.
        if (typeof this.settings.session === "string") {
            flags += `&s=${this.settings.session}`;
        }
        else {
            // Setup session reconnect.
            const sessionId = this.session.id;
            if (sessionId) {
                flags += `&s=${sessionId}`;
                // If a sessionId is fetched out of the Session class, it's a reconnection attempt.
                flags += `&r=true`;
            }
        }
        // Setup bypass flag.
        if (this.settings.bypass)
            flags += `&b=true`;
        // Setup authentication token for platform internal previewing.
        if (this.settings.token)
            flags += `&t=${this.settings.token}`;
        const query = new URLSearchParams(window.location.search);
        // Fetch rId parameter from the url and pass it to the connection string.
        const rId = (_a = query.get("rId")) !== null && _a !== void 0 ? _a : undefined;
        if (rId)
            flags += `&rId=${rId}`;
        // Setup DirectFlow.
        const dfToken = new URL(window.location.href).search
            .slice(1)
            .split("&")
            .find((qp) => qp.startsWith("df-"));
        if (dfToken)
            flags += `&${dfToken}`;
        if (this.settings.startHeight && this.settings.startHeight > 200)
            flags += `&h=${this.settings.startHeight}`;
        if (this.settings.startWidth && this.settings.startWidth > 200)
            flags += `&w=${this.settings.startWidth}`;
        return flags;
    }
    get initialSettings() {
        return this._initialSettings;
    }
    modifyInitialSettings(mouseLock) {
        this.setFlagEnabled(lib_pixelstreamingfrontend_ue5_5_1.Flags.HoveringMouseMode, mouseLock);
    }
}
exports.ArcwareConfig = ArcwareConfig;


/***/ }),

/***/ 9770:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ArcwareInit = void 0;
const ArcwareConfig_1 = __webpack_require__(3995);
const ArcwarePixelStreaming_1 = __webpack_require__(4282);
const ArcwareApplication_1 = __webpack_require__(9783);
let globalPixelStreaming = null;
let globalConfig = null;
let globalApplication = null;
let previousShareId = null;
let previousProjectId = null;
function ArcwareInit({ shareId, projectId }, configuration, forceRefresh = false) {
    if (shareId && !shareId.startsWith("share-"))
        throw new Error(`Unexpected shareId-format: '${shareId}'.`);
    if (shareId && previousShareId !== shareId) {
        globalConfig = null;
        globalPixelStreaming = null;
        globalApplication = null;
        previousShareId = shareId;
    }
    if (projectId && previousProjectId !== projectId) {
        globalConfig = null;
        globalPixelStreaming = null;
        globalApplication = null;
        previousProjectId = projectId;
    }
    if (forceRefresh) {
        globalConfig = null;
        globalPixelStreaming = null;
        globalApplication = null;
        console.info("ArcwareInit: Forced re-initialization");
    }
    if (globalPixelStreaming && globalConfig && globalApplication) {
        console.warn("ArcwareInit: Returning existing instance to prevent multiple WebSocket connections.");
        return {
            Config: globalConfig,
            PixelStreaming: globalPixelStreaming,
            Application: globalApplication
        };
    }
    const Config = new ArcwareConfig_1.ArcwareConfig({
        useUrlParams: (configuration === null || configuration === void 0 ? void 0 : configuration.useUrlParams) === true,
        initialSettings: Object.assign({ ss: ArcwareConfig_1.DefaultUrl, AutoConnect: false, StartVideoMuted: true, AutoPlayVideo: true, KeyboardInput: true, MouseInput: true, GamepadInput: true, TouchInput: true, XRControllerInput: true, UseMic: true, SuppressBrowserKeys: true, FakeMouseWithTouches: false, ForceMonoAudio: false, HoveringMouse: true }, configuration === null || configuration === void 0 ? void 0 : configuration.initialSettings),
        settings: Object.assign({ shareId,
            projectId, fullscreenButton: true, audioButton: true, stopButton: false, infoButton: false, micButton: false, settingsButton: false, connectionStrengthIcon: false, connectionIdentifierLoggingDisabled: undefined, errorHandler: undefined, loveLetterHandler: undefined, loveLetterLogging: undefined, queueHandler: undefined, sessionIdHandler: undefined, startHeight: undefined, startWidth: undefined, orientationZoom: undefined }, configuration === null || configuration === void 0 ? void 0 : configuration.settings)
    });
    const PixelStreaming = new ArcwarePixelStreaming_1.ArcwarePixelStreaming(Config);
    const Application = new ArcwareApplication_1.ArcwareApplication({ stream: PixelStreaming });
    // Store globally to prevent multiple instances
    globalConfig = Config;
    globalPixelStreaming = PixelStreaming;
    globalApplication = Application;
    return {
        Config,
        PixelStreaming,
        Application
    };
}
exports.ArcwareInit = ArcwareInit;


/***/ }),

/***/ 4282:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ArcwarePixelStreaming = void 0;
const tslib_1 = __webpack_require__(655);
const shared_pixelstreaming_websdk_1 = __webpack_require__(7910);
const lib_pixelstreamingfrontend_ue5_5_1 = __webpack_require__(693);
const ApplyUrlHack_1 = __webpack_require__(4790);
const EventHandler_1 = __webpack_require__(3379);
const Stats_1 = __webpack_require__(9764);
const debounce_1 = __webpack_require__(9580);
const LoveLetters_1 = __webpack_require__(4572);
const ArcwareLogoLoader_1 = __webpack_require__(6469);
const MicrophoneOverlay_1 = __webpack_require__(3613);
const ConnectionIdentifier_1 = __webpack_require__(5999);
const DiagnosticsCollector_1 = __webpack_require__(8429);
const common_1 = __webpack_require__(2483);
class ArcwarePixelStreaming extends lib_pixelstreamingfrontend_ue5_5_1.PixelStreaming {
    resetInitGuardsAndHooks() {
        this.videoInitializedSent = false;
        this._postInitSideEffectsDone = false;
        this.cancelFirstRenderedFrameHook(); // just in case
        this.attachFirstRenderedFrameOnce(); // re-arm rVFC/resize on current video element
        this.bindTransportEvents(); // ensure listeners are bound to current transport
    }
    reconnect() {
        super.reconnect();
        this.resetInitGuardsAndHooks();
    }
    // Classify CloseEvent into retryable vs. legit (non-retryable)
    isRetryableClose(err) {
        var _a, _b;
        //const reason = (evt.reason || "").toLowerCase();
        const code = (_b = (_a = err.code) !== null && _a !== void 0 ? _a : err.status) !== null && _b !== void 0 ? _b : err.errorCode;
        if (code >= 4000 /*||
        reason.includes("Stream disconnected.") ||
        reason.includes("forbidden") ||
        reason.includes("invalid token") ||
        reason.includes("policy violation") ||
        reason.includes("not allowed")*/) {
            return false; // legit server-side rejection: do NOT auto-retry
        }
        // Transient/server/network issues: keep auto behavior
        return true;
    }
    bindTransportEvents() {
        var _a, _b, _c, _d, _e, _f, _g;
        const current = (_a = this.webRtcController) === null || _a === void 0 ? void 0 : _a.transport;
        if (!current || current === this._boundTransport)
            return;
        // Unbind from previous
        if (this._boundTransport) {
            if (this._onWsOpen)
                (_c = (_b = this._boundTransport).removeEventListener) === null || _c === void 0 ? void 0 : _c.call(_b, "open", this._onWsOpen);
            if (this._onWsClose)
                (_e = (_d = this._boundTransport).removeEventListener) === null || _e === void 0 ? void 0 : _e.call(_d, "close", this._onWsClose);
        }
        // Define (or reuse) callbacks
        if (!this._onWsOpen) {
            this._onWsOpen = () => {
                this.flushOutbox();
                this.attachFirstRenderedFrameOnce();
                // no watchdog anymore
                setTimeout(() => {
                    var _a, _b, _c;
                    if (!this.videoInitializedSent) {
                        const v = (_c = (_b = (_a = this.webRtcController) === null || _a === void 0 ? void 0 : _a.videoPlayer) === null || _b === void 0 ? void 0 : _b.getVideoElement) === null || _c === void 0 ? void 0 : _c.call(_b);
                        if (v && v.videoWidth > 0 && v.videoHeight > 0 && v.readyState >= HTMLMediaElement.HAVE_CURRENT_DATA) {
                            this.sendVideoInitializedOnce();
                            this.runPostInitSideEffectsOnce();
                        }
                    }
                }, 1200);
            };
        }
        if (!this._onWsClose) {
            this._onWsClose = (evt) => {
                // Bubble to your public close handler
                EventHandler_1.EventHandler.Emit(this.websocketOnCloseHandler, evt);
            };
        }
        // Bind to current
        (_f = current.addEventListener) === null || _f === void 0 ? void 0 : _f.call(current, "open", this._onWsOpen);
        (_g = current.addEventListener) === null || _g === void 0 ? void 0 : _g.call(current, "close", this._onWsClose);
        this._boundTransport = current;
    }
    get isWsOpen() {
        var _a, _b;
        const ws = (_b = (_a = this.webRtcController) === null || _a === void 0 ? void 0 : _a.transport) === null || _b === void 0 ? void 0 : _b.webSocket;
        return !!ws && ws.readyState === WebSocket.OPEN;
    }
    /** Returns a list of WebSocketStates of all PixelStreaming Instances generated. */
    get WebsocketStates() {
        return ConnectionIdentifier_1.ConnectionIdentifier.Instance.GetWebSocketStates();
    }
    /** Counts all active PixelStreaming Instances generated. (CONNECTING & CONNECTED) */
    get ActiveInstances() {
        return ConnectionIdentifier_1.ConnectionIdentifier.Instance.ActiveInstances;
    }
    /** Returns this PixelStreaming Instances websocket state. */
    get websocketState() {
        var _a, _b, _c;
        let state = (_c = (_b = (_a = this.webRtcController) === null || _a === void 0 ? void 0 : _a.transport) === null || _b === void 0 ? void 0 : _b.webSocket) === null || _c === void 0 ? void 0 : _c.readyState;
        return state !== undefined ? state : WebSocket.CLOSED;
    }
    constructor(config, overrides) {
        var _a, _b, _c;
        /** As soon as upstream is fixed, we got to adjust the url building process. */
        (0, ApplyUrlHack_1.ApplyUrlHack)();
        super(config, overrides);
        this.loveLettersQueue = [];
        this.isProcessingQueue = false;
        // --- reliable send / idempotence ---
        this.outbox = [];
        this.videoInitializedSent = false;
        // --- first-frame (rVFC) detection + element swap handling ---
        this._rVFCsupported = "requestVideoFrameCallback" in HTMLVideoElement.prototype;
        this._postInitSideEffectsDone = false;
        // Externalized
        this.queueHandler = new EventHandler_1.EventHandler();
        this.errorHandler = new EventHandler_1.EventHandler();
        this.loveLetterHandler = new EventHandler_1.EventHandler();
        this.sessionIdHandler = new EventHandler_1.EventHandler();
        /** VideoInitialized (native Epic event) */
        this.videoInitializedHandler = new EventHandler_1.EventHandler();
        // Internal
        this.websocketOnCloseHandler = new EventHandler_1.EventHandler();
        /** Theoretically this call should be used to implement the signalling url, but this would not work at all, if config is setup for "AutoConnect=true"
         * Instead we use ApplyUrlHack();
         */
        // this.setSignallingUrlBuilder(() => {
        //   const regex = /(?<=\?.*)\?/g;
        //   const signallingServerUrl = this.config.getTextSettingValue(TextParameters.SignallingServerUrl);
        //   return signallingServerUrl + "?" + this.config.urlFlags;
        // });
        const transport = (_a = this.webRtcController) === null || _a === void 0 ? void 0 : _a.transport;
        (_b = transport === null || transport === void 0 ? void 0 : transport.addEventListener) === null || _b === void 0 ? void 0 : _b.call(transport, "open", () => {
            this.flushOutbox();
            // no polling watchdog
        });
        (_c = transport === null || transport === void 0 ? void 0 : transport.addEventListener) === null || _c === void 0 ? void 0 : _c.call(transport, "close", (evt) => {
            if (this.websocketOnCloseHandler) {
                EventHandler_1.EventHandler.Emit(this.websocketOnCloseHandler, evt);
            }
        });
        // Set override config.
        this.config = config;
        this.loveLettersList = [];
        this.microphoneOverlay = new MicrophoneOverlay_1.MicrophoneOverlay(this);
        this.diagnosticsCollector = new DiagnosticsCollector_1.DiagnosticsCollector({
            enableBandwidthProbe: false
        });
        // after super(...) and once webRtcController is available
        this.bindTransportEvents();
        this.startTransportWatcher();
        // Arm first-frame detector & watch for element swaps
        this.attachFirstRenderedFrameOnce();
        this.watchVideoElementReplacement();
        this.wrapWebSocketOnCloseHandler();
        // Bind the event listener function to the class instance
        this.handleResolutionChange = this.handleResolutionChange.bind(this);
        // Register message handlers.
        this.addMessageHandler("letter", shared_pixelstreaming_websdk_1.Messages.ZLoveLetter, this.onLoveLetter);
        this.addMessageHandler("streamInfo", shared_pixelstreaming_websdk_1.Messages.ZStreamInfo, this.onStreamInfo);
        this.addMessageHandler("sessionId", shared_pixelstreaming_websdk_1.Messages.ZSessionId, this.onSessionId);
        this.addMessageHandler("error", shared_pixelstreaming_websdk_1.Messages.ZErrorMessage, this.onError);
        this.addMessageHandler("ping", shared_pixelstreaming_websdk_1.Messages.ZPing, this.onPing);
        this.addMessageHandler("queue", shared_pixelstreaming_websdk_1.Messages.ZQueue, this.onQueue);
        this.addMessageHandler("version", shared_pixelstreaming_websdk_1.Messages.ZVersion, this.onVersion);
        this.addMessageHandler("render", shared_pixelstreaming_websdk_1.Messages.ZRender, this.onRender);
        // Create a debounced version of the handleResolutionChange function
        const debouncedResolutionChange = (0, debounce_1.default)(() => {
            this.handleResolutionChange();
        }, 0);
        // Register event listeners.
        this.addEventListener("videoInitialized", this.onVideoInitialized.bind(this));
        this.addEventListener("statsReceived", (event) => {
            this.sendStats(event.data.aggregatedStats);
        });
        // Add the window resize event listener
        window.addEventListener("resize", debouncedResolutionChange);
        this.webRtcController.streamMessageController.registerMessageHandler(0, // MessageDirection.ToStreamer,
        "TextboxEntry", (messageData) => {
            try {
                this.webRtcController.sendMessageController.sendMessageToStreamer("TextboxEntry", messageData);
            }
            catch (e) {
                console.error(`Error: ToStreamer.TextboxEntry`, e);
            }
        });
        this.initLoveLettersContainer();
        this.createMicrophoneOverlay();
        // Set pre configured handlers.
        if (this.config.settings.errorHandler)
            this.errorHandler.add(this.config.settings.errorHandler);
        if (this.config.settings.queueHandler)
            this.queueHandler.add(this.config.settings.queueHandler);
        if (this.config.settings.sessionIdHandler)
            this.sessionIdHandler.add(this.config.settings.sessionIdHandler);
        if (this.config.settings.loveLetterHandler)
            this.loveLetterHandler.add(this.config.settings.loveLetterHandler);
        ConnectionIdentifier_1.ConnectionIdentifier.Instance.register(this);
        this.removeXRIconIfDisabled();
        this.handleMouseLock();
    }
    /** Getter for the session object. */
    get session() {
        return this.config.session;
    }
    /**
     * * * * * * *
     *  Listen   *
     * * * * * * *
     */
    /** On version requested, the version of the WebSDK would be returned. */
    onVersion(_msg) {
        var _a, _b;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let diagnostics;
            try {
                diagnostics = yield this.diagnosticsCollector.collect();
            }
            catch (e) {
                (_a = lib_pixelstreamingfrontend_ue5_5_1.Logger.Warning) === null || _a === void 0 ? void 0 : _a.call(lib_pixelstreamingfrontend_ue5_5_1.Logger, `Diagnostics collection failed: ${(_b = e === null || e === void 0 ? void 0 : e.message) !== null && _b !== void 0 ? _b : e}`);
            }
            finally {
                const payload = {
                    type: "version",
                    version: this.config.VERSION
                };
                if (diagnostics !== undefined)
                    payload.diagnostics = diagnostics;
                this.send(payload); // uses buffered send
            }
        });
    }
    isVideoRenderingNow(video) {
        if (!video)
            return false;
        const hasDims = video.videoWidth > 0 && video.videoHeight > 0;
        const hasData = video.readyState >= HTMLMediaElement.HAVE_CURRENT_DATA; // 2
        const playing = !video.paused && !video.ended;
        // Be conservative: require at least two signals to avoid metadata-only false positives
        return (hasDims && hasData) || (hasDims && playing) || (hasData && playing);
    }
    waitForFirstFrameWithTimeout(ms = 2000) {
        var _a, _b, _c;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const video = (_c = (_b = (_a = this.webRtcController) === null || _a === void 0 ? void 0 : _a.videoPlayer) === null || _b === void 0 ? void 0 : _b.getVideoElement) === null || _c === void 0 ? void 0 : _c.call(_b);
            if (this.isVideoRenderingNow(video))
                return true;
            let t;
            const ok = yield Promise.race([
                new Promise((resolve) => {
                    var _a, _b;
                    const done = () => {
                        cleanup();
                        resolve(true);
                    };
                    const cleanup = () => {
                        var _a, _b;
                        video.removeEventListener("playing", onPlaying);
                        video.removeEventListener("resize", onResize);
                        if ("cancelVideoFrameCallback" in HTMLVideoElement.prototype && rvfcId != null) {
                            (_b = (_a = video).cancelVideoFrameCallback) === null || _b === void 0 ? void 0 : _b.call(_a, rvfcId);
                        }
                    };
                    const onPlaying = () => this.isVideoRenderingNow(video) && done();
                    const onResize = () => this.isVideoRenderingNow(video) && done();
                    video.addEventListener("playing", onPlaying, { once: true });
                    video.addEventListener("resize", onResize, { once: true });
                    const rvfcId = "requestVideoFrameCallback" in HTMLVideoElement.prototype
                        ? (_b = (_a = video).requestVideoFrameCallback) === null || _b === void 0 ? void 0 : _b.call(_a, () => done())
                        : null;
                }),
                new Promise((resolve) => {
                    t = window.setTimeout(() => resolve(false), ms);
                })
            ]);
            if (t)
                clearTimeout(t);
            return ok;
        });
    }
    onRender(_msg) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const isRendering = yield this.waitForFirstFrameWithTimeout();
            const payload = {
                type: "render",
                isRendering: isRendering
            };
            this.send(payload); // uses buffered send
        });
    }
    /** On ping the session creation timestamp will be updated. */
    onPing(message) {
        var _a, _b;
        if (this.config.isFlagEnabled("HoveringMouse") !== !((_b = (_a = this === null || this === void 0 ? void 0 : this.streamInfo) === null || _a === void 0 ? void 0 : _a.streamInfo.meta) === null || _b === void 0 ? void 0 : _b.mouseLock))
            this.handleMouseLock();
        if (this.session.current)
            this.session.set(this.session.current);
    }
    /** Handle incoming configurations. */
    onStreamInfo(streamInfo) {
        var _a, _b, _c, _d;
        lib_pixelstreamingfrontend_ue5_5_1.Logger.Info(`StreamInfo received.`);
        this.streamInfo = streamInfo;
        if (!((_b = (_a = this.config) === null || _a === void 0 ? void 0 : _a.settings) === null || _b === void 0 ? void 0 : _b["do-not-eval-streamInfo"])) {
            const { afk } = streamInfo.streamInfo;
            if (afk) {
                this.config.setFlagEnabled(lib_pixelstreamingfrontend_ue5_5_1.Flags.AFKDetection, afk.enabled);
                this.config.setNumericSetting(lib_pixelstreamingfrontend_ue5_5_1.NumericParameters.AFKTimeoutSecs, afk.warn + afk.error);
                // Hack
                const { afkController } = this.webRtcController;
                afkController.countDown = afk.action;
            }
            if ((_c = streamInfo.streamInfo.webSdkSettings) === null || _c === void 0 ? void 0 : _c.init) {
                this.config.setSettings(streamInfo.streamInfo.webSdkSettings.init);
            }
            if ((_d = streamInfo.streamInfo.webSdkSettings) === null || _d === void 0 ? void 0 : _d.conf) {
                Object.entries(streamInfo.streamInfo.webSdkSettings.conf).forEach(([key, value]) => {
                    const k = key;
                    this.config.settings[k] = value;
                    if (key === "connectionIdentifierLoggingDisabled" && value === true)
                        ConnectionIdentifier_1.ConnectionIdentifier.Instance.disable();
                });
            }
        }
        this.handleMouseLock();
        this.injectCustomUI();
    }
    onQueue(message) {
        lib_pixelstreamingfrontend_ue5_5_1.Logger.Info(`QueueInfo received.`);
        EventHandler_1.EventHandler.Emit(this.queueHandler, message);
    }
    onError(error) {
        var _a, _b;
        lib_pixelstreamingfrontend_ue5_5_1.Logger.Error(error.type);
        console.log(error);
        const retryable = this.isRetryableClose(error);
        if (!retryable) {
            // This stops the signaling client and shows the built-in "Play to reconnect" overlay
            try {
                (_b = (_a = this.webRtcController) === null || _a === void 0 ? void 0 : _a.closeSignalingServer) === null || _b === void 0 ? void 0 : _b.call(_a, error.reason, false);
            }
            catch (_c) { }
            // Optional: pause the transport watcher so we don't churn while idle
            this.stopTransportWatcher();
        }
        else {
            // Leave your existing auto-retry behavior for transient errors
            this.startTransportWatcher(); // (in case it was stopped)
        }
        EventHandler_1.EventHandler.Emit(this.errorHandler, error);
    }
    onLoveLetter(loveLetter) {
        if (this.config.settings.loveLetterLogging)
            console.info(loveLetter.reason);
        EventHandler_1.EventHandler.Emit(this.loveLetterHandler, loveLetter);
        this.pushLetter(loveLetter.reason);
    }
    onSessionId(message) {
        lib_pixelstreamingfrontend_ue5_5_1.Logger.Info(message.sessionId);
        this.session.set(message.sessionId);
        EventHandler_1.EventHandler.Emit(this.sessionIdHandler, message.sessionId);
    }
    sendVideoInitializedOnce() {
        if (this.videoInitializedSent)
            return;
        this.videoInitializedSent = true;
        // cancel rVFC if still armed (we've already initialized)
        this.cancelFirstRenderedFrameHook();
        this.send({ type: "onVideoInitialized" });
        if (this.videoInitializedHandler) {
            EventHandler_1.EventHandler.Emit(this.videoInitializedHandler, undefined);
        }
    }
    runPostInitSideEffectsOnce() {
        var _a, _b, _c, _d, _e, _f, _g;
        if (this._postInitSideEffectsDone)
            return;
        this._postInitSideEffectsDone = true;
        try {
            (_a = this.handleMouseLock) === null || _a === void 0 ? void 0 : _a.call(this);
        }
        catch (_h) { }
        try {
            (_b = this.handleResolutionChange) === null || _b === void 0 ? void 0 : _b.call(this);
        }
        catch (_j) { }
        try {
            (_c = this.handleRemoveLoveLetters) === null || _c === void 0 ? void 0 : _c.call(this);
        }
        catch (_k) { }
        try {
            (_e = (_d = this.microphoneOverlay) === null || _d === void 0 ? void 0 : _d.toggleVisibility) === null || _e === void 0 ? void 0 : _e.call(_d, false);
        }
        catch (_l) { }
        try {
            (_f = this.applyResolutionIfPlaying) === null || _f === void 0 ? void 0 : _f.call(this);
        }
        catch (_m) { }
        try {
            (_g = this.removeXRIconIfDisabled) === null || _g === void 0 ? void 0 : _g.call(this);
        }
        catch (_o) { }
    }
    onVideoInitialized() {
        if (this.videoInitializedSent) {
            // Init was already sent by rVFC; ensure side-effects run once, then bail.
            this.runPostInitSideEffectsOnce();
            return;
        }
        //console.log("Ran from Epic");
        this.sendVideoInitializedOnce();
        this.runPostInitSideEffectsOnce();
    }
    // --- First-frame detection (rVFC/resize) ---
    attachFirstRenderedFrameOnce() {
        var _a, _b, _c, _d;
        const v = (_c = (_b = (_a = this.webRtcController) === null || _a === void 0 ? void 0 : _a.videoPlayer) === null || _b === void 0 ? void 0 : _b.getVideoElement) === null || _c === void 0 ? void 0 : _c.call(_b);
        if (!v)
            return;
        if (this._rVFCArmedForElement === v)
            return;
        this.cancelFirstRenderedFrameHook();
        this._rVFCArmedForElement = v;
        // Modern path
        if (this._rVFCsupported) {
            const anyV = v;
            this._rvfcHandle = (_d = anyV.requestVideoFrameCallback) === null || _d === void 0 ? void 0 : _d.call(anyV, (_now, _meta) => {
                this.sendVideoInitializedOnce();
                this.runPostInitSideEffectsOnce();
                this._rvfcHandle = undefined;
            });
        }
        // Always attach resize once as a parallel fallback
        const onResize = () => {
            v.removeEventListener("resize", onResize);
            this.sendVideoInitializedOnce();
            this.runPostInitSideEffectsOnce();
        };
        v.addEventListener("resize", onResize, { once: true });
    }
    cancelFirstRenderedFrameHook() {
        var _a;
        const v = this._rVFCArmedForElement;
        if (!v)
            return;
        if (this._rvfcHandle && "cancelVideoFrameCallback" in HTMLVideoElement.prototype) {
            const anyV = v;
            try {
                (_a = anyV.cancelVideoFrameCallback) === null || _a === void 0 ? void 0 : _a.call(anyV, this._rvfcHandle);
            }
            catch (_b) { }
        }
        this._rvfcHandle = undefined;
        this._rVFCArmedForElement = undefined;
    }
    watchVideoElementReplacement() {
        var _a, _b, _c, _d;
        // Observe the player container; if a new <video> is inserted/replaced, re-arm rVFC
        try {
            const parent = (_c = (_b = (_a = this === null || this === void 0 ? void 0 : this.webRtcController) === null || _a === void 0 ? void 0 : _a.videoPlayer) === null || _b === void 0 ? void 0 : _b.getVideoParentElement) === null || _c === void 0 ? void 0 : _c.call(_b);
            if (!parent)
                return;
            (_d = this._mo) === null || _d === void 0 ? void 0 : _d.disconnect();
            this._mo = new MutationObserver(() => {
                // Try to re-attach on any child change (cheap and reliable)
                this.attachFirstRenderedFrameOnce();
            });
            this._mo.observe(parent, { childList: true, subtree: true });
        }
        catch (_e) {
            // noop
        }
    }
    /** Adding a zod-safe handler. */
    addMessageHandler(type, zod, boundMethod) {
        this.signallingProtocol.addListener(type, (payload) => {
            const parsed = zod.safeParse(payload);
            if (parsed.success)
                boundMethod.call(this, parsed.data);
            else {
                const parsedError = parsed;
                const error = new Error(`Unexpected message content. Event:'${type}', ZodError: ${parsedError.error.message}`);
                lib_pixelstreamingfrontend_ue5_5_1.Logger.Error(error.message);
            }
            if (type === "error") {
                // this.disconnect();
            }
        });
    }
    /**
     * * * * * *
     *  Send   *
     * * * * * *
     */
    sendStats(stats) {
        const message = { type: "stats", stats: (0, Stats_1.Stats)(stats) };
        this.send(message);
    }
    send(a, b) {
        var _a, _b;
        const msg = typeof a === "string" ? Object.assign({ type: a }, (b !== null && b !== void 0 ? b : {})) : a;
        // Optional zod validation if you have schemas for this type
        const schema = (_a = shared_pixelstreaming_websdk_1.Messages.Send) === null || _a === void 0 ? void 0 : _a[msg.type];
        if (schema) {
            const result = schema.safeParse(msg);
            if (!result.success) {
                (_b = lib_pixelstreamingfrontend_ue5_5_1.Logger.Error) === null || _b === void 0 ? void 0 : _b.call(lib_pixelstreamingfrontend_ue5_5_1.Logger, `Send validation failed for ${msg.type}: ${result.error}`);
                return;
            }
            this._dispatchOrBuffer(result.data);
        }
        else {
            this._dispatchOrBuffer(msg);
        }
    }
    _dispatchOrBuffer(message) {
        if (this.isWsOpen) {
            try {
                this.signallingProtocol.sendMessage(message);
                return;
            }
            catch (_a) {
                // fallthrough to buffer
            }
        }
        this.outbox.push(message);
    }
    flushOutbox() {
        if (!this.isWsOpen || this.outbox.length === 0)
            return;
        const batch = this.outbox.splice(0, this.outbox.length);
        for (const m of batch) {
            try {
                this.signallingProtocol.sendMessage(m);
            }
            catch (_a) {
                this.outbox.unshift(m, ...batch.slice(batch.indexOf(m) + 1));
                break;
            }
        }
    }
    handleResolutionChange() {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        if (!(this === null || this === void 0 ? void 0 : this.streamInfo) || !(this === null || this === void 0 ? void 0 : this.webRtcController) || !((_b = (_a = this === null || this === void 0 ? void 0 : this.webRtcController) === null || _a === void 0 ? void 0 : _a.videoPlayer) === null || _b === void 0 ? void 0 : _b.getVideoElement())) {
            return;
        }
        const resolution = (_d = (_c = this === null || this === void 0 ? void 0 : this.streamInfo) === null || _c === void 0 ? void 0 : _c.streamInfo) === null || _d === void 0 ? void 0 : _d.resolution;
        const unrealVersion = (_g = (_f = (_e = this === null || this === void 0 ? void 0 : this.streamInfo) === null || _e === void 0 ? void 0 : _e.streamInfo) === null || _f === void 0 ? void 0 : _f.meta) === null || _g === void 0 ? void 0 : _g.version;
        const orientationZoom = (_h = this.config.settings) === null || _h === void 0 ? void 0 : _h.orientationZoom;
        if (resolution && (resolution === null || resolution === void 0 ? void 0 : resolution.dynamic)) {
            setTimeout(() => {
                var _a, _b, _c;
                const { videoPlayer } = this === null || this === void 0 ? void 0 : this.webRtcController;
                const videoElementParent = videoPlayer === null || videoPlayer === void 0 ? void 0 : videoPlayer.getVideoParentElement();
                const browserWidth = videoElementParent === null || videoElementParent === void 0 ? void 0 : videoElementParent.getBoundingClientRect().width;
                const browserHeight = videoElementParent === null || videoElementParent === void 0 ? void 0 : videoElementParent.getBoundingClientRect().height;
                const maxWidth = resolution === null || resolution === void 0 ? void 0 : resolution.width;
                const maxHeight = resolution === null || resolution === void 0 ? void 0 : resolution.height;
                const aspectRatio = browserWidth / browserHeight;
                let limitedWidth, limitedHeight;
                if (aspectRatio > maxWidth / maxHeight) {
                    limitedWidth = maxWidth;
                    limitedHeight = maxWidth / aspectRatio;
                }
                else {
                    limitedHeight = maxHeight;
                    limitedWidth = maxHeight * aspectRatio;
                }
                // Zoom level for orientation change if provided
                if (orientationZoom) {
                    if (browserWidth < browserHeight) {
                        if (orientationZoom.hasOwnProperty('portrait'))
                            (_a = this === null || this === void 0 ? void 0 : this.webRtcController) === null || _a === void 0 ? void 0 : _a.emitUIInteraction({
                                zoom: orientationZoom.portrait
                            });
                    }
                    else if (orientationZoom.hasOwnProperty('landscape')) {
                        (_b = this === null || this === void 0 ? void 0 : this.webRtcController) === null || _b === void 0 ? void 0 : _b.emitUIInteraction({
                            zoom: orientationZoom.landscape
                        });
                    }
                }
                if (videoPlayer) {
                    if (!unrealVersion || (unrealVersion === null || unrealVersion === void 0 ? void 0 : unrealVersion.startsWith("4.27"))) {
                        const descriptor = { Console: `r.setres ${Math.round(limitedWidth)}x${Math.round(limitedHeight)}w` };
                        (_c = this === null || this === void 0 ? void 0 : this.webRtcController) === null || _c === void 0 ? void 0 : _c.emitUIInteraction(descriptor);
                    }
                    else {
                        videoPlayer.onMatchViewportResolutionCallback(Math.round(limitedWidth), Math.round(limitedHeight));
                    }
                }
            }, 0);
        }
    }
    applyResolutionIfPlaying() {
        var _a;
        const videoElement = (_a = this === null || this === void 0 ? void 0 : this.webRtcController) === null || _a === void 0 ? void 0 : _a.videoPlayer.getVideoElement();
        if (videoElement) {
            videoElement.addEventListener("playing", () => {
                setTimeout(() => {
                    this === null || this === void 0 ? void 0 : this.handleResolutionChange();
                }, 0);
            });
        }
    }
    removePlayer() {
        var _a, _b, _c, _d, _e;
        this.stopTransportWatcher();
        // Unbind transport listeners
        if (this._boundTransport) {
            if (this._onWsOpen)
                (_b = (_a = this._boundTransport).removeEventListener) === null || _b === void 0 ? void 0 : _b.call(_a, "open", this._onWsOpen);
            if (this._onWsClose)
                (_d = (_c = this._boundTransport).removeEventListener) === null || _d === void 0 ? void 0 : _d.call(_c, "close", this._onWsClose);
        }
        // Cancel rVFC + observer
        this.cancelFirstRenderedFrameHook();
        try {
            (_e = this._mo) === null || _e === void 0 ? void 0 : _e.disconnect();
        }
        catch (_f) { }
        this.disconnect();
    }
    startTransportWatcher() {
        if (this._transportWatchTimer)
            return;
        this._transportWatchTimer = window.setInterval(() => {
            var _a;
            const cur = (_a = this.webRtcController) === null || _a === void 0 ? void 0 : _a.transport;
            if (cur && cur !== this._boundTransport)
                this.bindTransportEvents();
        }, 3000);
    }
    stopTransportWatcher() {
        if (this._transportWatchTimer) {
            window.clearInterval(this._transportWatchTimer);
            this._transportWatchTimer = undefined;
        }
    }
    handleMouseLock() {
        var _a, _b, _c;
        (_a = this === null || this === void 0 ? void 0 : this.config) === null || _a === void 0 ? void 0 : _a.modifyInitialSettings(!((_c = (_b = this === null || this === void 0 ? void 0 : this.streamInfo) === null || _b === void 0 ? void 0 : _b.streamInfo.meta) === null || _c === void 0 ? void 0 : _c.mouseLock));
    }
    initLoveLettersContainer() {
        var _a;
        const logoLoader = new ArcwareLogoLoader_1.ArcwareLogoLoader();
        if (!this.loveLettersContainer) {
            const loveLettersContainer = document === null || document === void 0 ? void 0 : document.createElement("div");
            const { videoPlayer } = this === null || this === void 0 ? void 0 : this.webRtcController;
            const videoElementParent = videoPlayer.getVideoParentElement();
            (_a = loveLettersContainer === null || loveLettersContainer === void 0 ? void 0 : loveLettersContainer.classList) === null || _a === void 0 ? void 0 : _a.add("love-letters-box-root");
            videoElementParent === null || videoElementParent === void 0 ? void 0 : videoElementParent.appendChild(loveLettersContainer);
            const lettersBlock = document === null || document === void 0 ? void 0 : document.createElement("div");
            lettersBlock.id = "letters-block";
            const lettersWrapper = document === null || document === void 0 ? void 0 : document.createElement("div");
            lettersWrapper.id = "letters-wrapper";
            if (loveLettersContainer) {
                lettersBlock === null || lettersBlock === void 0 ? void 0 : lettersBlock.appendChild(logoLoader === null || logoLoader === void 0 ? void 0 : logoLoader.arcwareLogoLoader);
                loveLettersContainer === null || loveLettersContainer === void 0 ? void 0 : loveLettersContainer.appendChild(lettersBlock);
                lettersBlock === null || lettersBlock === void 0 ? void 0 : lettersBlock.appendChild(lettersWrapper);
            }
            lettersBlock.innerHTML = "";
            if (lettersBlock) {
                lettersBlock === null || lettersBlock === void 0 ? void 0 : lettersBlock.appendChild(logoLoader === null || logoLoader === void 0 ? void 0 : logoLoader.arcwareLogoLoader);
                lettersBlock === null || lettersBlock === void 0 ? void 0 : lettersBlock.appendChild(lettersWrapper);
            }
        }
    }
    pushLetter(letter) {
        var _a;
        (_a = this === null || this === void 0 ? void 0 : this.loveLettersQueue) === null || _a === void 0 ? void 0 : _a.push(letter);
        if (!this.isProcessingQueue) {
            this === null || this === void 0 ? void 0 : this.processLoveLetterQueue();
        }
    }
    processLoveLetterQueue() {
        var _a, _b;
        this.isProcessingQueue = true;
        const letter = this.loveLettersQueue.shift();
        if (letter !== undefined) {
            const formattedLoveLetter = letter === null || letter === void 0 ? void 0 : letter.replace(/LL: |\.$/g, "");
            (_a = this === null || this === void 0 ? void 0 : this.loveLettersList) === null || _a === void 0 ? void 0 : _a.push(formattedLoveLetter);
            const loveLettersBox = new LoveLetters_1.LoveLetters();
            loveLettersBox === null || loveLettersBox === void 0 ? void 0 : loveLettersBox.addLetter(formattedLoveLetter, (_b = this === null || this === void 0 ? void 0 : this.loveLettersList) === null || _b === void 0 ? void 0 : _b.length);
            setTimeout(() => {
                this.processLoveLetterQueue();
            }, 1000);
        }
        else {
            this.isProcessingQueue = false;
        }
    }
    handleRemoveLoveLetters() {
        const loveLettersContainer = document === null || document === void 0 ? void 0 : document.querySelector(".love-letters-box-root");
        setTimeout(() => {
            var _a;
            if (loveLettersContainer) {
                (_a = loveLettersContainer === null || loveLettersContainer === void 0 ? void 0 : loveLettersContainer.classList) === null || _a === void 0 ? void 0 : _a.add("fade-out");
            }
        }, 1000);
        setTimeout(() => {
            var _a;
            if (loveLettersContainer && (loveLettersContainer === null || loveLettersContainer === void 0 ? void 0 : loveLettersContainer.parentNode)) {
                (_a = loveLettersContainer === null || loveLettersContainer === void 0 ? void 0 : loveLettersContainer.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(loveLettersContainer);
            }
        }, 1600);
    }
    toggleAudio(videoElement, enabled) {
        var _a, _b;
        const { streamController } = this.webRtcController;
        if (videoElement) {
            videoElement.muted = enabled;
            if (streamController) {
                streamController.audioElement.muted = enabled;
                if ((videoElement === null || videoElement === void 0 ? void 0 : videoElement.currentTime) > 0 && !(videoElement === null || videoElement === void 0 ? void 0 : videoElement.paused) && ((_a = streamController === null || streamController === void 0 ? void 0 : streamController.audioElement) === null || _a === void 0 ? void 0 : _a.paused))
                    (_b = streamController === null || streamController === void 0 ? void 0 : streamController.audioElement) === null || _b === void 0 ? void 0 : _b.play();
            }
        }
    }
    createMicrophoneOverlay() {
        var _a;
        (_a = this === null || this === void 0 ? void 0 : this.microphoneOverlay) === null || _a === void 0 ? void 0 : _a.createOverlay();
    }
    toggleMic(enable, isDefault) {
        var _a, _b;
        (_a = this === null || this === void 0 ? void 0 : this.config) === null || _a === void 0 ? void 0 : _a.setFlagEnabled(lib_pixelstreamingfrontend_ue5_5_1.Flags.UseMic, enable);
        if (!isDefault) {
            (_b = this === null || this === void 0 ? void 0 : this.microphoneOverlay) === null || _b === void 0 ? void 0 : _b.toggleMessage(enable);
            setTimeout(() => { var _a; return (_a = this === null || this === void 0 ? void 0 : this.microphoneOverlay) === null || _a === void 0 ? void 0 : _a.toggleVisibility(true); }, 200);
            setTimeout(() => {
                this.videoInitializedSent = false; // reset before a real media restart
                // Re-arm rVFC on the current (or new) video element
                this.attachFirstRenderedFrameOnce();
                this.bindTransportEvents();
                this.reconnect();
            }, 1000);
        }
    }
    wrapWebSocketOnCloseHandler() {
        var _a, _b;
        let self = this;
        (_b = (_a = this.webRtcController) === null || _a === void 0 ? void 0 : _a.transport) === null || _b === void 0 ? void 0 : _b.addEventListener("close", (event) => {
            EventHandler_1.EventHandler.Emit(self.websocketOnCloseHandler, event);
        });
    }
    onStreamingStateChange(callback) {
        var _a, _b, _c, _d;
        const videoElement = (_b = (_a = this === null || this === void 0 ? void 0 : this.webRtcController) === null || _a === void 0 ? void 0 : _a.videoPlayer) === null || _b === void 0 ? void 0 : _b.getVideoElement();
        videoElement === null || videoElement === void 0 ? void 0 : videoElement.addEventListener("play", () => callback(true));
        videoElement === null || videoElement === void 0 ? void 0 : videoElement.addEventListener("pause", () => callback(false));
        videoElement === null || videoElement === void 0 ? void 0 : videoElement.addEventListener("ended", () => callback(false));
        (_c = this.webRtcController) === null || _c === void 0 ? void 0 : _c.transport.addEventListener("open", () => {
            callback(true);
        });
        (_d = this.webRtcController) === null || _d === void 0 ? void 0 : _d.transport.addEventListener("close", () => {
            callback(false);
        });
    }
    removeXRIconIfDisabled() {
        var _a, _b, _c, _d, _e;
        if (!((_b = (_a = this === null || this === void 0 ? void 0 : this.config) === null || _a === void 0 ? void 0 : _a.initialSettings) === null || _b === void 0 ? void 0 : _b.XRControllerInput)) {
            (_c = this === null || this === void 0 ? void 0 : this.config) === null || _c === void 0 ? void 0 : _c.setFlagEnabled(lib_pixelstreamingfrontend_ue5_5_1.Flags.XRControllerInput, false);
            if (this.videoElementParent) {
                if ((_d = this === null || this === void 0 ? void 0 : this.videoElementParent) === null || _d === void 0 ? void 0 : _d.parentElement) {
                    const xrBtn = (_e = this === null || this === void 0 ? void 0 : this.videoElementParent) === null || _e === void 0 ? void 0 : _e.parentElement.querySelector("#xrBtn");
                    xrBtn === null || xrBtn === void 0 ? void 0 : xrBtn.remove();
                }
            }
        }
    }
    injectCustomUI() {
        (0, common_1.waitForElement)('#stream-ui')
            .then(el => {
            var _a;
            const videoElementParent = (_a = this === null || this === void 0 ? void 0 : this.videoElementParent) === null || _a === void 0 ? void 0 : _a.parentElement;
            if (videoElementParent) {
                videoElementParent === null || videoElementParent === void 0 ? void 0 : videoElementParent.appendChild(el);
            }
        });
    }
}
exports.ArcwarePixelStreaming = ArcwarePixelStreaming;


/***/ }),

/***/ 5602:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ArcwareSettingsSchema = void 0;
const zod_1 = __webpack_require__(8754);
const shared_pixelstreaming_websdk_1 = __webpack_require__(7910);
/** Arcware Settings. */
exports.ArcwareSettingsSchema = zod_1.z.object({
    /** Overwrites the Session-Tool and uses the provided session instead. */
    session: zod_1.z.string().optional(),
    /** Can be used to be added to the request in order to verify access to private projects.
     * For internal use only. => Preview page.
     */
    token: zod_1.z.string().optional(),
    /** @deprecated in there for legacy use. Can only be used when token is provided. */
    bypass: zod_1.z.boolean().optional(),
    // /** Configure DirectFlow Token. */
    // directFlow: z.string().optional(),
    /** Handler for server side error messages. */
    errorHandler: zod_1.z.function().args(shared_pixelstreaming_websdk_1.Messages.ZErrorMessage).returns(zod_1.z.void()).optional(),
    /** Handler for queue events. */
    queueHandler: zod_1.z.function().args(shared_pixelstreaming_websdk_1.Messages.ZQueue).returns(zod_1.z.void()).optional(),
    /** Handler for sessionId message. */
    sessionIdHandler: zod_1.z.function().args(zod_1.z.string()).returns(zod_1.z.void()).optional(),
    /** Handler for love letters.
     * "LoveLetters" are send from backend to the SDK to state what phase the connection currently is in. */
    loveLetterHandler: zod_1.z.function().args(shared_pixelstreaming_websdk_1.Messages.ZLoveLetter).returns(zod_1.z.void()).optional(),
    /** Show or hide the fullscreen button. */
    fullscreenButton: zod_1.z.boolean().optional(),
    /** Show or hide the settings button. */
    settingsButton: zod_1.z.boolean().optional(),
    /** Show or hide the info button. */
    infoButton: zod_1.z.boolean().optional(),
    /** Show or hide the audio button. */
    audioButton: zod_1.z.boolean().optional(),
    /** Show or hide the microphone button. */
    micButton: zod_1.z.boolean().optional(),
    /** Show or hide the microphone button. */
    stopButton: zod_1.z.boolean().optional(),
    /** Show or hide the connectionStrengthIcon button. */
    connectionStrengthIcon: zod_1.z.boolean().optional(),
    /** ShareId, used for sharing your project.
     * Using ArcwareInit will set this required property for you. */
    shareId: zod_1.z.string().startsWith("share-").optional(),
    /** Id of your project, only required if your shareId refers to multiple projects.
     * Using ArcwareInit will set this required property for you. */
    projectId: zod_1.z.string().optional(),
    /** Enable/Disable LoveLetter logging to the console. */
    loveLetterLogging: zod_1.z.boolean().optional(),
    /** Enable/Disable Connection Identifier logging to the console. */
    connectionIdentifierLoggingDisabled: zod_1.z.boolean().optional(),
    /** Width with which instance should be started */
    startWidth: zod_1.z.number().optional(),
    /** Height with which instance should be started */
    startHeight: zod_1.z.number().optional(),
    /** Zoom functionality */
    orientationZoom: zod_1.z.object({
        landscape: zod_1.z.number(),
        portrait: zod_1.z.number(),
    }).strict().optional()
});


/***/ }),

/***/ 5999:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConnectionIdentifier = exports.WebsocketState = void 0;
var WebsocketState;
(function (WebsocketState) {
    // Socket has been created. The connection is not yet open.
    WebsocketState[WebsocketState["CONNECTING"] = 0] = "CONNECTING";
    // The connection is open and ready to communicate.
    WebsocketState[WebsocketState["OPEN"] = 1] = "OPEN";
    // The connection is in the process of closing.
    WebsocketState[WebsocketState["CLOSING"] = 2] = "CLOSING";
    // The connection is closed or couldn't be opened.
    WebsocketState[WebsocketState["CLOSED"] = 3] = "CLOSED";
})(WebsocketState = exports.WebsocketState || (exports.WebsocketState = {}));
class ConnectionIdentifier {
    static get Instance() {
        if (!this.instance) {
            this.instance = new ConnectionIdentifier();
        }
        return this.instance;
    }
    get WebsocketStates() {
        return this.aps.map((ps) => ps.websocketState);
    }
    constructor() {
        this.aps = [];
        this.enabled = true;
    }
    register(ps) {
        var _a;
        if (!this.aps.includes(ps)) {
            this.aps.push(ps);
            if ((_a = ps.config.settings) === null || _a === void 0 ? void 0 : _a.connectionIdentifierLoggingDisabled)
                this.disable();
        }
        if (!this.interval)
            this.interval = setInterval(this.connectionWatcher.bind(this), 10 * 1000);
    }
    GetWebSocketStates() {
        return this.aps.map((ps) => ps.websocketState);
    }
    ActiveInstances() {
        return this.GetWebSocketStates().filter((state) => state <= WebsocketState.OPEN).length;
    }
    disable() {
        this.enabled = false;
    }
    /**
     * The purpose of this method is to periodically tell the developer the amount of connected instances.
     * This way the developer can figure out, when they messed up the implementation and there's shadow instances still running.
     * Or when they accidentally set up multiple connections!
     * Things like that can happen, for example if the React.useEffect was not setup perfectly!
     */
    connectionWatcher() {
        if (!this.enabled)
            return;
        const activeStates = this.GetWebSocketStates().filter((state) => state <= WebsocketState.OPEN);
        if (activeStates.length === 1) {
            //console.log(`PixelStreaming Instance is connected.`);
        }
        else if (activeStates.length !== 0) {
            console.warn(`${activeStates.length} PixelStreaming Instances are connected!`);
        }
    }
}
exports.ConnectionIdentifier = ConnectionIdentifier;


/***/ }),

/***/ 3379:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EventHandler = void 0;
/** A helper class to spread the event to additional event handlers added from external sources. */
class EventHandler {
    /** Returns the added callback on success or null, if something went wrong. */
    add(callback) {
        const cb = this.callbacks.find((cb) => cb === callback);
        if (cb)
            return null;
        this.callbacks.push(callback);
        return callback;
    }
    /** Returns true if the input callback has been found and removed and false if not. */
    remove(callback) {
        const cb = this.callbacks.find((cb) => cb === callback);
        if (cb)
            this.callbacks.splice(this.callbacks.indexOf(cb), 1);
        return !!cb;
    }
    constructor() {
        this.callbacks = new Array();
    }
    /** Emits the event-data for each of the existing handlers. */
    static Emit(handler, event) {
        handler.callbacks.forEach((callback) => callback(event));
    }
}
exports.EventHandler = EventHandler;


/***/ }),

/***/ 2469:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Session = void 0;
const addSeconds_1 = __webpack_require__(1973);
const isBefore_1 = __webpack_require__(313);
const zod_1 = __webpack_require__(8754);
const ZSession = zod_1.z
    .object({
    id: zod_1.z.string().min(1),
    created: zod_1.z
        .date()
        .or(zod_1.z.string())
        .transform((arg) => new Date(arg)),
    expire: zod_1.z.boolean().default(false).optional(),
})
    .strict();
const ZOptions = zod_1.z.object({
    localStorageKey: zod_1.z.string().min(3).default("pxss"),
    keepSession: zod_1.z
        .number()
        .int()
        .min(3)
        /** Default keep is 10, since this is how long instances will be kept alive by default. */
        .default(10),
});
/** The sessionId is stored in the localStorage to allow for reconnection and
 * to prevent spamming start requests of instances, when smashing F5.
 */
class Session {
    get current() {
        return this._current;
    }
    get noSession() {
        return new URLSearchParams(window.location.search).has("noSession");
    }
    get id() {
        // If the query-parameter "noSession" or "nosession" is set, it will be skipped.
        if (this.noSession)
            return null;
        const sessionString = window.localStorage.getItem(this.localStorageKey);
        // No session yet set.
        if (sessionString === null) {
            return null;
        }
        const parsed = ZSession.safeParse(JSON.parse(sessionString));
        // Clear the session if it's not valid.
        if (!parsed.success) {
            this.unset();
            return null;
        }
        const session = parsed.data;
        const expirationTime = (0, addSeconds_1.default)(new Date(session.created), this.options.keepSession);
        if ((0, isBefore_1.default)(expirationTime, new Date())) {
            this.unset();
            return null;
        }
        // Return the sessionId.
        return session.id;
    }
    get localStorageKey() {
        return this.options.localStorageKey;
    }
    constructor(options) {
        this.options = ZOptions.parse(options || {});
    }
    /** Set's the session with creation date for the given storage key to the localStorage. */
    set(sessionId) {
        ZSession.shape.id.parse(sessionId);
        this._current = sessionId;
        const session = {
            id: sessionId,
            created: new Date(),
            expire: false,
        };
        window.localStorage.setItem(this.localStorageKey, JSON.stringify(session));
    }
    /** Removes a session from the localStorage. */
    unset() {
        window.localStorage.removeItem(this.localStorageKey);
    }
}
exports.Session = Session;


/***/ }),

/***/ 9764:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Stats = void 0;
const shared_pixelstreaming_websdk_1 = __webpack_require__(7910);
function Stats(stats) {
    const result = shared_pixelstreaming_websdk_1.Messages.ZStats.shape.stats.parse({
        /**
         * Other known properties.
         */
        codecs: stats.codecs,
        candidatePair: stats.candidatePairs,
        localCandidates: stats.localCandidates,
        remoteCandidates: stats.remoteCandidates,
        DataChannelStats: stats.datachannelStats,
        // Received (last) for ticket
        bytesReceived: forceNumber(stats.inboundVideoStats.bytesReceived),
        // Packets Lost (last) for ticket
        packetsLost: forceNumber(stats.inboundVideoStats.packetsLost),
        // Video resolution: highest lowest average (portrait) and highest lowest average (landscape) for ticket
        frameWidth: forceNumber(stats.inboundVideoStats.frameWidth),
        // Video resolution: highest lowest average (portrait) and highest lowest average (landscape) for ticket
        frameHeight: forceNumber(stats.inboundVideoStats.frameHeight),
        // Frames decoded (Last) for ticket
        framesDecoded: forceNumber(stats.inboundVideoStats.framesDecoded),
        // Framerate (low / high, avg) for ticket
        framesPerSecond: forceNumber(stats.inboundVideoStats.framesPerSecond),
        // frames dropped (last) for ticket
        framesDropped: forceNumber(stats.inboundVideoStats.framesDropped),
        // Videocodec (once) for ticket
        videoCodec: stats.inboundVideoStats.codecId,
        // audiocodec (once) for ticket
        audioCodec: stats.inboundAudioStats.codecId,
        // browser type and version for ticket (arcware / addition)
        browserInfo: {
            // to be received!
            userAgent: navigator.userAgent,
            platform: navigator.oscpu || navigator.platform || null,
            language: navigator.language,
        },
        // Net RTT (low, high, avg)
        // BEGIN TW CHANGE
        currentRTT: calcRTT(stats.candidatePairs),
        // END TW CHANGE
        // Duration (last)
        sessionRunTime: stats.sessionStats.runTime,
        // Controls stream input (??)
        controlsStreamInput: stats.sessionStats.controlsStreamInput,
        // video quantization parameter (low / high / avg if applicable)
        videoEncoderAvgQP: forceNumber(stats.sessionStats.videoEncoderAvgQP),
        // Video bitrate (min / max / avg)
        videoBitrate: forceNumber(stats.inboundVideoStats.bitrate),
        // Audio bitrate (min / max / avg)
        audioBitrate: forceNumber(stats.inboundAudioStats.bitrate),
    });
    return result;
}
exports.Stats = Stats;
/**
 * Given an array of candidate pairs this function will find the highest RTT for the selected pair
 * @param pairs - An array of candidate pairs
 * @returns The highest round trip time of a selected candidate pair
 */
function calcRTT(pairs) {
    let rtt = 0;
    pairs.forEach((pair) => {
        if (pair.selected && pair.currentRoundTripTime > rtt) {
            rtt = pair.currentRoundTripTime;
        }
    });
    return rtt;
}
/**
 * Takes a number and forces it to return a number. If the value passed in is NaN, 0 will be returned.
 * @param value - A number
 * @returns The number passed in as value or 0 if vlaue was NaN
 */
function forceNumber(value) {
    return isNaN(value) ? 0 : value;
}


/***/ }),

/***/ 9580:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
function debounce(func, wait) {
    let timeout;
    return function (...args) {
        clearTimeout(timeout);
        timeout = window.setTimeout(() => func(...args), wait);
    };
}
exports["default"] = debounce;


/***/ }),

/***/ 471:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isAnalyticsEvent = exports.toAnalyticsEvent = void 0;
// analytics.ts
const common_1 = __webpack_require__(2483);
/**
 * Build an AnalyticsEvent from unknown input.
 * - accepts object or JSON/JSON-ish string
 * - drops extra fields
 * - requires non-empty string `type` and `customName`
 * - accepts `payload` only if it's a string; truncates by **bytes**
 */
function toAnalyticsEvent(input, opts = {}) {
    var _a, _b, _c;
    const maxBytes = (_a = opts.maxPayloadBytes) !== null && _a !== void 0 ? _a : 512;
    let obj;
    try {
        obj = (0, common_1.parseUnknownToObject)(input, { allowJsonish: (_b = opts.allowJsonish) !== null && _b !== void 0 ? _b : true });
    }
    catch (e) {
        return { ok: false, error: (_c = e === null || e === void 0 ? void 0 : e.message) !== null && _c !== void 0 ? _c : "Invalid input" };
    }
    const typeVal = safeString(obj["type"]);
    const customNameVal = safeString(obj["customName"]);
    if (!typeVal)
        return { ok: false, error: "`type` must be a non-empty string." };
    if (!customNameVal)
        return { ok: false, error: "`customName` must be a non-empty string." };
    let payloadStr;
    if ("payload" in obj && typeof obj["payload"] === "string") {
        payloadStr = (0, common_1.truncateByBytes)(obj["payload"], maxBytes);
    }
    const value = payloadStr !== undefined
        ? { type: typeVal, customName: customNameVal, payload: payloadStr }
        : { type: typeVal, customName: customNameVal };
    return { ok: true, value };
}
exports.toAnalyticsEvent = toAnalyticsEvent;
/** Type guard */
function isAnalyticsEvent(x) {
    return (!!x &&
        typeof x === "object" &&
        typeof x.type === "string" &&
        typeof x.customName === "string" &&
        (typeof x.payload === "string" || x.payload === undefined));
}
exports.isAnalyticsEvent = isAnalyticsEvent;
function safeString(x) {
    if (typeof x !== "string")
        return undefined;
    const trimmed = x.trim();
    return trimmed.length ? trimmed : undefined;
}


/***/ }),

/***/ 2768:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseControl = exports.ZFileTransfer = void 0;
// fileTransfer.ts
const zod_1 = __webpack_require__(8754);
const common_1 = __webpack_require__(2483);
// Schema
exports.ZFileTransfer = zod_1.z.object({
    type: zod_1.z.literal("fileTransfer"),
    filename: zod_1.z.string().trim().optional()
});
// Normalized parse + validate
function parseControl(input, schema) {
    const obj = (0, common_1.parseUnknownToObject)(input, { allowJsonish: true });
    return schema.parse(obj);
}
exports.parseControl = parseControl;


/***/ }),

/***/ 8429:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/**
 * DiagnosticsCollector.ts
 * Lightweight, privacy-aware client diagnostics for troubleshooting + analytics.
 * WebRTC collection intentionally omitted (to add later).
 *
 * Notes:
 * - Some fields are best-effort due to browser restrictions; they're nullable.
 * - Bandwidth probe requires a small binary served with:
 *     Content-Type: application/octet-stream
 *     Content-Encoding: identity
 *     Cache-Control: no-store
 *   Default location: /diag/probe.bin
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DiagnosticsCollector = exports.Type = exports.Orientation = void 0;
const tslib_1 = __webpack_require__(655);
var Orientation;
(function (Orientation) {
    Orientation["Landscape"] = "landscape";
    Orientation["Portrait"] = "portrait";
})(Orientation = exports.Orientation || (exports.Orientation = {}));
var Type;
(function (Type) {
    Type["Desktop"] = "desktop";
    Type["Mobile"] = "mobile";
    Type["Tablet"] = "tablet";
})(Type = exports.Type || (exports.Type = {}));
/**
 * DiagnosticsCollector
 */
class DiagnosticsCollector {
    constructor(opts = {}) {
        var _a, _b, _c, _d;
        this.uaInfoCache = null;
        this.opts = {
            enableBandwidthProbe: (_a = opts.enableBandwidthProbe) !== null && _a !== void 0 ? _a : true,
            probeUrl: (_b = opts.probeUrl) !== null && _b !== void 0 ? _b : "/diag/probe.bin",
            respectSaveData: (_c = opts.respectSaveData) !== null && _c !== void 0 ? _c : true,
            sampleRate: Math.max(0, Math.min(1, (_d = opts.sampleRate) !== null && _d !== void 0 ? _d : 1))
        };
    }
    /**
     * Collect the diagnostics payload.
     */
    collect() {
        var _a, _b;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.shouldSample()) {
                return {
                    device: { type: Type.Desktop, touchSupport: false },
                    runtime: { browser: { family: "Unknown", version: null }, os: { family: "Unknown", version: null } },
                    powerHints: { saveData: null, prefersReducedData: null, prefersReducedMotion: null },
                    network: { type: null, effectiveType: null, downlinkMbps: null, rttMs: null, measuredDownlinkMbps: null },
                    timestamps: { collectedAt: Date.now() }
                };
            }
            const collectedAt = Date.now();
            const [uaInfo, codecSupport, measuredDownlinkMbps] = yield Promise.all([
                this.getUAInfo(),
                this.getCodecSupport(),
                this.maybeMeasureBandwidth()
            ]);
            return {
                device: {
                    type: this.inferDeviceType(),
                    vendor: null,
                    model: uaInfo.model,
                    architecture: uaInfo.architecture,
                    bitness: uaInfo.bitness,
                    touchSupport: this.hasTouch(),
                    hardwareConcurrency: (_a = navigator.hardwareConcurrency) !== null && _a !== void 0 ? _a : null,
                    deviceMemory: (_b = navigator.deviceMemory) !== null && _b !== void 0 ? _b : null,
                    orientation: this.getOrientation(),
                    webgl: this.hasWebGL(),
                    codecs: codecSupport
                },
                runtime: {
                    browser: { family: uaInfo.browserFamily, version: uaInfo.browserVersion },
                    os: { family: uaInfo.osFamily, version: uaInfo.osVersion }
                },
                powerHints: this.getPowerHints(),
                network: this.getNetworkInfo(measuredDownlinkMbps),
                timestamps: { collectedAt }
            };
        });
    }
    /**
     * Collect a safe subset of WebRTC stats once PC is connected.
     */
    collectWebRTC(pc) {
        var _a, _b, _c, _d, _e, _f;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const stats = yield pc.getStats();
                let selected, transport, local, remote;
                stats.forEach((r) => {
                    if (r.type === "transport" && r.selectedCandidatePairId)
                        transport = r;
                    if (r.type === "candidate-pair" && (r.selected || r.nominated))
                        selected = r;
                });
                if (selected) {
                    local = stats.get(selected.localCandidateId);
                    remote = stats.get(selected.remoteCandidateId);
                }
                return {
                    candidatePairId: (_a = selected === null || selected === void 0 ? void 0 : selected.id) !== null && _a !== void 0 ? _a : null,
                    localCandidateType: (_b = local === null || local === void 0 ? void 0 : local.candidateType) !== null && _b !== void 0 ? _b : null,
                    remoteCandidateType: (_c = remote === null || remote === void 0 ? void 0 : remote.candidateType) !== null && _c !== void 0 ? _c : null,
                    protocol: (_d = local === null || local === void 0 ? void 0 : local.protocol) !== null && _d !== void 0 ? _d : null,
                    networkType: (_e = local === null || local === void 0 ? void 0 : local.networkType) !== null && _e !== void 0 ? _e : null,
                    dtlsCipher: (_f = transport === null || transport === void 0 ? void 0 : transport.dtlsCipher) !== null && _f !== void 0 ? _f : null
                };
            }
            catch (_g) {
                return {};
            }
        });
    }
    /**
     * Helper to embed diagnostics in a hello envelope.
     */
    buildHelloEnvelope(base, pc) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const diag = yield this.collect();
            const webrtc = pc ? yield this.collectWebRTC(pc) : undefined;
            const ext = webrtc ? { diag: Object.assign(Object.assign({}, diag), { webrtc }) } : { diag };
            return Object.assign(Object.assign({}, base), { ext });
        });
    }
    // ---------- Internals ----------
    shouldSample() {
        if (this.opts.sampleRate >= 1)
            return true;
        return Math.random() < this.opts.sampleRate;
    }
    hasTouch() {
        var _a;
        const nav = navigator;
        return "ontouchstart" in window || ((_a = nav.maxTouchPoints) !== null && _a !== void 0 ? _a : 0) > 0;
    }
    getOrientation() {
        var _a;
        try {
            if ((_a = screen.orientation) === null || _a === void 0 ? void 0 : _a.type) {
                return screen.orientation.type.startsWith("portrait") ? Orientation.Portrait : Orientation.Landscape;
            }
            if (window.matchMedia) {
                return window.matchMedia("(orientation: portrait)").matches ? Orientation.Portrait : Orientation.Landscape;
            }
        }
        catch (_b) { }
        return null;
    }
    hasWebGL() {
        try {
            const canvas = document.createElement("canvas");
            return !!(canvas.getContext("webgl") || canvas.getContext("experimental-webgl"));
        }
        catch (_a) {
            return false;
        }
    }
    /**
     * Heuristic device type: best-effort only.
     * Tries UA-CH, then UA fallback, then touch + screen size heuristics.
     */
    inferDeviceType() {
        const uaData = navigator.userAgentData;
        const ua = navigator.userAgent || "";
        const isMobileCH = (uaData === null || uaData === void 0 ? void 0 : uaData.mobile) === true;
        const minDim = Math.min(screen.width, screen.height);
        // 1. Explicit iPad / tablet detection via UA (iOS often lies in CH)
        if (/\b(iPad|Tablet)\b/i.test(ua)) {
            return Type.Tablet;
        }
        // 2. UA-CH mobile hint (Chromium only, often accurate for Android)
        if (isMobileCH) {
            if (minDim >= 600)
                return Type.Tablet;
            return Type.Mobile;
        }
        // 3. UA sniffing fallback for mobile
        if (/\b(iPhone|Android.*Mobile|Windows Phone)\b/i.test(ua)) {
            return Type.Mobile;
        }
        // 4. Touch-capable with "tablet-like" dimensions
        if (("ontouchstart" in window || navigator.maxTouchPoints > 0) && minDim >= 600 && minDim <= 1100) {
            return Type.Tablet;
        }
        // 5. Default fallback
        return Type.Desktop;
    }
    getPowerHints() {
        const conn = navigator.connection;
        const saveData = typeof (conn === null || conn === void 0 ? void 0 : conn.saveData) === "boolean" ? conn.saveData : null;
        let prefersReducedData = null;
        let prefersReducedMotion = null;
        if (typeof window.matchMedia === "function") {
            try {
                const mqData = window.matchMedia("(prefers-reduced-data: reduce)");
                if (typeof mqData.matches === "boolean") {
                    prefersReducedData = mqData.matches;
                }
            }
            catch (_a) { }
            try {
                const mqMotion = window.matchMedia("(prefers-reduced-motion: reduce)");
                if (typeof mqMotion.matches === "boolean") {
                    prefersReducedMotion = mqMotion.matches;
                }
            }
            catch (_b) { }
        }
        return { saveData, prefersReducedData, prefersReducedMotion };
    }
    getNetworkInfo(measuredDownlinkMbps) {
        const conn = navigator.connection;
        return {
            type: typeof (conn === null || conn === void 0 ? void 0 : conn.type) === "string" ? conn.type : null,
            effectiveType: typeof (conn === null || conn === void 0 ? void 0 : conn.effectiveType) === "string" ? conn.effectiveType : null,
            downlinkMbps: typeof (conn === null || conn === void 0 ? void 0 : conn.downlink) === "number" ? conn.downlink : null,
            rttMs: typeof (conn === null || conn === void 0 ? void 0 : conn.rtt) === "number" ? conn.rtt : null,
            measuredDownlinkMbps
        };
    }
    maybeMeasureBandwidth() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const conn = navigator.connection;
            const saveData = (conn === null || conn === void 0 ? void 0 : conn.saveData) === true;
            if (!this.opts.enableBandwidthProbe)
                return null;
            if (this.opts.respectSaveData && saveData)
                return null;
            try {
                const t0 = performance.now();
                const res = yield fetch(this.withCacheBuster(this.opts.probeUrl), {
                    cache: "no-store",
                    credentials: "omit"
                });
                const buf = yield res.arrayBuffer();
                const t1 = performance.now();
                const bits = buf.byteLength * 8;
                const seconds = (t1 - t0) / 1000;
                if (seconds <= 0.05)
                    return null; // ignore unstable samples
                return +(bits / seconds / 1000000).toFixed(2);
            }
            catch (_a) {
                return null;
            }
        });
    }
    withCacheBuster(url) {
        var _a, _b;
        const u = new URL(url, location.origin);
        const token = (_b = (_a = crypto === null || crypto === void 0 ? void 0 : crypto.randomUUID) === null || _a === void 0 ? void 0 : _a.call(crypto)) !== null && _b !== void 0 ? _b : String(Date.now());
        u.searchParams.set("cb", token);
        return u.toString();
    }
    getCodecSupport() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const [h264, hevc] = yield Promise.all([
                this.supportsCodec('video/mp4; codecs="avc1.42E01E"'),
                this.supportsCodec('video/mp4; codecs="hvc1.1.6.L93.B0"')
            ]);
            return { h264, hevc };
        });
    }
    supportsCodec(mime) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                if ("mediaCapabilities" in navigator) {
                    // @ts-ignore
                    const res = yield navigator.mediaCapabilities.decodingInfo({
                        type: "file",
                        video: { contentType: mime, width: 1920, height: 1080, bitrate: 5000000, framerate: 30 }
                    });
                    return !!(res === null || res === void 0 ? void 0 : res.supported);
                }
            }
            catch (_a) { }
            try {
                const v = document.createElement("video");
                return v.canPlayType(mime) !== "";
            }
            catch (_b) {
                return false;
            }
        });
    }
    getUAInfo() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (this.uaInfoCache)
                return this.uaInfoCache;
            const nav = navigator;
            const uaData = nav.userAgentData;
            const ua = navigator.userAgent;
            let browserFamily = "Unknown";
            let browserVersion = null;
            let osFamily = "Unknown";
            let osVersion = null;
            let model = null;
            let architecture = null;
            let bitness = null;
            // --- UA-CH (modern browsers) ---
            if (uaData === null || uaData === void 0 ? void 0 : uaData.getHighEntropyValues) {
                try {
                    const high = yield uaData.getHighEntropyValues([
                        "platform",
                        "platformVersion",
                        "model",
                        "architecture",
                        "bitness",
                        "fullVersionList"
                    ]);
                    osFamily = high.platform || "Unknown";
                    osVersion = high.platformVersion || null;
                    model = high.model || null;
                    architecture = high.architecture || null;
                    bitness = high.bitness || null;
                    const brands = high.fullVersionList || uaData.brands || [];
                    const realBrand = brands.find((b) => {
                        if (!b.brand)
                            return false;
                        const normalized = b.brand.replace(/[^a-zA-Z]/g, "").toLowerCase();
                        return !normalized.includes("chromium") && !normalized.includes("notabrand");
                    });
                    if (realBrand) {
                        browserFamily = realBrand.brand;
                        browserVersion = realBrand.version;
                    }
                }
                catch (_a) {
                    // silently fail
                }
            }
            // --- Fallback to classic UA parsing if browser unknown ---
            if (!browserFamily || browserFamily === "Unknown") {
                const browserRegexes = [
                    [/Edg\/(\S+)/, "Edge"],
                    [/OPR\/(\S+)/, "Opera"],
                    [/SamsungBrowser\/(\S+)/, "Samsung Internet"],
                    [/Firefox\/(\S+)/, "Firefox"],
                    [/Chrome\/(\S+)/, "Chrome"],
                    [/Version\/(\S+).*Safari/, "Safari"]
                ];
                for (const [regex, name] of browserRegexes) {
                    const match = ua.match(regex);
                    if (match) {
                        browserFamily = name;
                        browserVersion = match[1];
                        break;
                    }
                }
            }
            // --- OS detection (always run, iOS first) ---
            if (/iPhone|iPad|iPod/.test(ua)) {
                osFamily = "iOS";
                const match = ua.match(/OS (\d+[_\d]*)/);
                if (match)
                    osVersion = match[1].replace(/_/g, ".");
            }
            else if (uaData === null || uaData === void 0 ? void 0 : uaData.platform) {
                osFamily = uaData.platform;
            }
            else if (/Windows/.test(ua)) {
                osFamily = "Windows";
                const match = ua.match(/Windows NT (\d+\.\d+)/);
                if (match)
                    osVersion = match[1];
            }
            else if (/Mac OS X/.test(ua)) {
                osFamily = "macOS";
                const match = ua.match(/Mac OS X (\d+[_\d]*)/);
                if (match)
                    osVersion = match[1].replace(/_/g, ".");
            }
            else if (/Android/.test(ua)) {
                osFamily = "Android";
                const match = ua.match(/Android (\d+(\.\d+)?)/);
                if (match)
                    osVersion = match[1];
            }
            else if (/Linux/.test(ua)) {
                osFamily = "Linux";
            }
            const result = { browserFamily, browserVersion, osFamily, osVersion, model, architecture, bitness };
            this.uaInfoCache = result;
            return result;
        });
    }
}
exports.DiagnosticsCollector = DiagnosticsCollector;


/***/ }),

/***/ 2483:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.waitForElement = exports.normalizeType = exports.randomHash = exports.extFromMime = exports.sanitizeFilename = exports.truncateByBytes = exports.parseUnknownToObject = void 0;
/** Conservative normalizer: accepts object, strict JSON string, or JSON-ish like {foo: "bar"} */
function parseUnknownToObject(input, opts = { allowJsonish: true }) {
    if (input && typeof input === "object")
        return input;
    if (typeof input === "string") {
        try {
            const parsed = JSON.parse(input);
            if (parsed && typeof parsed === "object")
                return parsed;
        }
        catch (_a) { }
        if (opts.allowJsonish) {
            const repaired = input
                .trim()
                .replace(/'/g, '"')
                .replace(/([{,]\s*)([A-Za-z_][$\w-]*)(\s*:)/g, '$1"$2"$3');
            try {
                const parsed = JSON.parse(repaired);
                if (parsed && typeof parsed === "object")
                    return parsed;
            }
            catch (_b) { }
        }
    }
    throw new Error("Input must be an object or a JSON string of an object.");
}
exports.parseUnknownToObject = parseUnknownToObject;
/** Byte-safe string truncation (no broken unicode) */
function truncateByBytes(input, maxBytes) {
    const enc = new TextEncoder();
    const dec = new TextDecoder();
    const bytes = enc.encode(input);
    if (bytes.byteLength <= maxBytes)
        return input;
    // Back off until decode works
    for (let cut = maxBytes; cut > 0; cut--) {
        try {
            return dec.decode(bytes.subarray(0, cut), { stream: false });
        }
        catch (_a) { }
    }
    return "";
}
exports.truncateByBytes = truncateByBytes;
/** Cross-platform safe filename */
function sanitizeFilename(input) {
    let name = input.replace(/\s+/g, " ").trim();
    name = name.replace(/[\\\/:\*\?"<>\|\u0000-\u001F]+/g, "");
    name = name.replace(/^\.+/, ""); // avoid hidden files
    const reserved = /^(con|prn|aux|nul|com[1-9]|lpt[1-9])(\..*)?$/i;
    if (reserved.test(name) || !name)
        name = randomHash();
    if (name.length > 100)
        name = name.slice(0, 100);
    return name;
}
exports.sanitizeFilename = sanitizeFilename;
/** MIME -> extension */
function extFromMime(mime) {
    const map = {
        "image/png": ".png",
        "image/jpeg": ".jpg",
        "image/jpg": ".jpg",
        "image/webp": ".webp",
        "image/gif": ".gif",
        "image/bmp": ".bmp",
        "image/tiff": ".tiff",
        "video/mp4": ".mp4",
        "video/webm": ".webm",
        "video/ogg": ".ogv",
        "audio/mpeg": ".mp3",
        "audio/ogg": ".ogg",
        "audio/wav": ".wav",
        "audio/webm": ".weba",
        "application/pdf": ".pdf",
        "application/zip": ".zip",
        "application/x-zip-compressed": ".zip",
        "application/json": ".json",
        "text/plain": ".txt",
        "text/csv": ".csv"
    };
    if (map[mime])
        return map[mime];
    if (mime.startsWith("image/") || mime.startsWith("video/") || mime.startsWith("audio/")) {
        return "." + mime.split("/")[1];
    }
    return "";
}
exports.extFromMime = extFromMime;
/** Short random fallback */
function randomHash() {
    return Math.random().toString(36).slice(2, 8);
}
exports.randomHash = randomHash;
function normalizeType(v) {
    return typeof v === "string" ? v.trim().toLowerCase() : "";
}
exports.normalizeType = normalizeType;
function waitForElement(selector, { root = document, timeout = 3000 } = {}) {
    return new Promise((resolve) => {
        const existing = root.querySelector(selector);
        if (existing)
            return resolve(existing);
        const observer = new MutationObserver(() => {
            const el = root.querySelector(selector);
            if (el) {
                clearTimeout(timer);
                observer.disconnect();
                resolve(el); // fires once
            }
        });
        observer.observe(root.documentElement || root, { childList: true, subtree: true });
        const timer = setTimeout(() => {
            observer.disconnect();
        }, timeout);
    });
}
exports.waitForElement = waitForElement;


/***/ }),

/***/ 9399:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __webpack_require__(655);
tslib_1.__exportStar(__webpack_require__(9783), exports);
tslib_1.__exportStar(__webpack_require__(3995), exports);
tslib_1.__exportStar(__webpack_require__(4282), exports);
tslib_1.__exportStar(__webpack_require__(9770), exports);
tslib_1.__exportStar(__webpack_require__(2299), exports);


/***/ }),

/***/ 2299:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ArcwareStyles = void 0;
exports.ArcwareStyles = {
    customStyles: {
        ":root": {
            "--color0": "#18181A !important",
            "--color1": "#000000",
            "--color2": "#FFFFFF",
            "--color3": "#DAF693 !important",
            "--color4": "#35b350",
            "--color5": "#ffab00",
            "--color6": "#858588 !important",
            "--color7": "#B5B5B7 !important",
            "--color8": "#41008c",
            "--color9": "#3e0070",
            "--color10": "#2e0052",
            "--color11": "rgba(65,0,139,1) !important",
            "--color12": "#222224 !important",
            "--color13": "#f0f0f2 !important",
            "--colorBoxShadow": "rgba(0, 0, 0, 0.20) !important",
        },
        "#playerUI *": {
            fontFamily: "system-ui",
        },
        "#shared-stream-container": {
            boxSizing: "border-box",
        },
        "#shared-stream-container::-webkit-scrollbar": {
            width: "10px",
        },
        "#shared-stream-container::-webkit-scrollbar-track": {
            background: "var(--color13)",
            opacity: "0.5",
            borderRadius: "30px",
            borderTop: "20px solid var(--color0)",
            borderRight: "5px solid var(--color0)",
            borderBottom: "20px solid var(--color0)",
            borderLeft: "5px solid var(--color0)",
        },
        "#shared-stream-container::-webkit-scrollbar-track-piece": {
            background: "transparent",
        },
        "#shared-stream-container::-webkit-scrollbar-thumb": {
            background: "var(--color13)",
            width: "8px",
            borderRight: "2px solid var(--color0)",
            borderLeft: "2px solid var(--color0)",
            transition: "all ease-in-out 0.3s",
            borderRadius: "7px",
        },
        "#shared-stream-container::-webkit-scrollbar-thumb:hover": {
            transition: "all ease-in-out 0.3s",
            background: "var(--color3)",
        },
        "#playerUI, #videoElementParent": {
            position: "absolute",
            width: "100%",
            height: "100%",
            maxWidth: "100%",
            maxHeight: "100%",
            top: 0,
            right: 0,
            bottom: 0,
            left: 0,
            margin: "auto",
            boxSizing: "border-box",
            pointerEvents: "all",
        },
        "#streamingVideo": {
            maxWidth: "100%",
            maxHeight: "100%",
            boxSizing: "border-box",
            background: "#18181A",
        },
        "#uiFeatures #controls": {
            top: "auto",
            left: "auto",
            bottom: "10px",
            right: "20px",
            display: "flex",
            flexDirection: "column-reverse",
        },
        "#uiFeatures #connection": {
            bottom: "5px",
            left: "10px",
            width: "2.5rem",
            heihgt: "2.5rem",
        },
        "#uiFeatures button": {
            backgroundColor: "var(--color12)",
            border: "none",
            position: "relative",
            width: "45px",
            height: "45px",
            padding: "0.5rem",
            textAlign: "center",
            cursor: "pointer",
            display: "flex",
            flexDirection: "row",
            justifyContent: "center",
            alignItems: "center",
            boxShadow: "0px 0px 24px 0px var(--colorBoxShadow)",
            borderRadius: "3px",
            outline: "none",
        },
        "#uiFeatures button:hover, #uiFeatures button:active": {
            padding: "0 !important",
            border: "none",
        },
        "#uiFeatures button #audioIconMuted, #uiFeatures button #audioIconUnmuted, #uiFeatures button #micIconMuted, #uiFeatures button #micIconUnmuted": {
            width: "31px",
            height: "28px",
        },
        "#uiFeatures button #maximizeIcon, #uiFeatures button #minimizeIcon": {
            width: "25px",
            height: "25px",
        },
        "#stopIcon, #playIcon": {
            width: "30px",
            height: "30px",
        },
        "#uiFeatures button .tooltiptext": {
            right: "125%",
            left: "auto",
            boxShadow: "0px 0px 24px 0px var(--colorBoxShadow)",
            borderRadius: "3px",
            backgroundColor: "var(--color12)",
            width: "95px",
            visibility: "hidden!important",
        },
        "@media (hover: hover) and (pointer: fine)": {
            "#uiFeatures button:hover .tooltiptext": {
                visibility: "visible!important",
            },
        },
        "#controls>*": {
            marginBottom: "0.5rem",
            display: "block",
            lineHeight: "1.75rem",
            padding: "0.5rem",
            backgroundColor: "var(--color12)",
        },
        "#uiFeatures #settingsIcon, #uiFeatures #statsIcon": {
            width: "27px",
            height: "27px",
        },
        ".svgIcon": {
            fill: "var(--color13)",
        },
        "#uiFeatures button:hover .svgIcon, #uiFeatures button:active .svgIcon": {
            fill: "var(--color12)",
        },
        ".tgl-switch .tgl-slider, .tgl-flat:checked+.tgl-slider": {
            border: "3px solid transparent",
        },
        ".tgl-switch .tgl-slider": {
            background: "none",
        },
        ".tgl-switch .tgl-slider::before": {
            content: "''",
            display: "block",
            background: "var(--color6)",
            position: "absolute",
            height: "50%",
            width: "90%",
            borderRadius: "5px",
            margin: "auto",
            top: "0",
            bottom: "0",
            left: "0",
            right: "0",
        },
        ".tgl-switch .tgl-slider::after": {
            height: "13px",
            width: "13px",
            borderRadius: "50%",
            top: "-2px",
            left: "-1%",
        },
        ".tgl-flat:checked+.tgl-slider:after": {
            left: "62%",
            background: "var(--color3)",
        },
        ".form-control": {
            backgroundColor: "transparent",
            border: "1px solid var(--color13)",
            borderRadius: "2px",
            color: "var(--color13)",
            textAlign: "left",
            fontFamily: "inherit",
            padding: "5px 15px ",
        },
        ".btn-flat": {
            background: "var(--color3)",
            color: "var(--color12)",
            border: "none",
            padding: "7px 50px",
            cursor: "pointer",
            borderRadius: "4px",
            textTransform: "uppercase",
            minWidth: "175px",
        },
        ".btn-flat:disabled": {
            background: "var(--color7)",
            borderColor: "var(--color3)",
            color: "var(--color3)",
            cursor: "default",
        },
        ".btn-flat:focus": {
            outline: "none",
        },
        ".arcware-logo-loader": {
            position: "relative",
            display: "block",
            width: "12.5%",
            height: "12.5%",
        },
        "#playOverlay img#playButton": {
            width: "5%",
        },
        "#disconnectOverlay, #errorOverlay": {
            textTransform: "initial",
            textAlign: "center",
            fontSize: "20px",
            lineHeight: 2.5,
        },
        "#disconnectOverlay .clickableState": {
            textTransform: "initial",
            textAlign: "center",
            color: "#DAF693",
            padding: "5px",
            fontSize: "18px",
            border: "1px solid #DAF693",
            margin: "25px auto 0",
            width: "180px",
        },
        "#afkOverlay": {
            background: "none",
            transition: "all ease-in-out 0.5s",
            opacity: 1,
            pointerEvents: "initial",
        },
        "#afkOverlayInner": {
            textTransform: "initial",
            background: "#18181A",
            padding: "20px 10px 30px",
            fontSize: "18px",
            width: "360px",
            textAlign: "center",
            lineHeight: 2.5,
        },
        "#afkOverlayInner center::first-line": {
            textTransform: "uppercase",
            color: "#FF8461",
            fontWeight: "bold",
            fontSize: "24px",
        },
        "#afkOverlayInner #afkCountDownNumber": {
            color: "#DAF693",
            fontSize: "26px",
            lineHeight: "22px",
        },
        "#afkOverlayInner center .retry-button": {
            textTransform: "initial",
            textAlign: "center",
            color: "#DAF693",
            padding: "5px",
            fontSize: "18px",
            border: "1px solid #DAF693",
            margin: "25px auto 0",
            width: "180px",
        },
        "#connectOverlay #connectButton": {
            textTransform: "initial",
            textAlign: "center",
            color: "#DAF693",
            padding: "5px 5px 8px",
            fontSize: "18px",
            border: "1px solid #DAF693",
            margin: "25px auto 0",
            width: "180px",
        },
        "#connectOverlay .connection-text": {
            textTransform: "initial",
            textAlign: "center",
            margin: "25px auto 0",
        },
        "#connectOverlay .connection-text .title": {
            color: "#ffffff",
            fontSize: "18px",
            margin: "5px 0",
        },
        "#connectOverlay .connection-text .subtitle": {
            color: "#ffffff",
            opacity: 0.5,
            fontSize: "12px",
            margin: "10px 0",
        },
        "#infoOverlay.hiddenState": {
            display: "none",
        },
        "#disconnectOverlay, #playOverlay, #errorOverlay, #microphoneOverlay, #connectOverlay": {
            background: "#18181A",
            display: "flex",
            transition: "all ease-in-out 0.5s",
            opacity: 1,
            pointerEvents: "initial",
        },
        "#microphoneOverlay": {
            textTransform: "initial",
            padding: "20px 30px",
            fontSize: "14px",
            height: "230px",
            width: "360px",
            textAlign: "center",
            lineHeight: 1.25,
            position: "absolute",
            margin: "auto",
            top: "0",
            bottom: "0",
            left: "0",
            right: "0",
            justifyContent: "center",
            alignItems: "center",
            flexDirection: "column",
            zIndex: 99999,
        },
        "#microphoneOverlay .title": {
            fontSize: "24px",
            position: "relative",
            marginBottom: "20px",
            color: "#F0F0F2",
        },
        "#microphoneOverlay .title:after": {
            content: "''",
            display: "inline-block",
            animation: "dotty steps(1,end) 1s infinite",
            position: "absolute",
        },
        "#microphoneOverlay p": {
            margin: 0,
            color: "#858588",
        },
        "#microphoneOverlay svg": {
            height: "65px",
            marginBottom: "15px",
            marginTop: "-5px",
        },
        "#microphoneOverlay .svgIcon": {
            fill: "#DAF693",
        },
        "#disconnectOverlay.hiddenState, #playOverlay.hiddenState, #errorOverlay.hiddenState, #afkOverlay.hiddenState, #microphoneOverlay.hiddenState": {
            opacity: 0,
            pointerEvents: "none",
        },
        "#disconnectOverlay.mic-overlay-is-visible, #errorOverlay.mic-overlay-is-visible, #infoOverlay.mic-overlay-is-visible": {
            opacity: 0,
            pointerEvents: "none",
        },
        "#infoOverlay.hiddenState, #connectOverlay.hiddenState": {
            display: "none",
        },
        "#connectOverlay": {
            display: "flex",
            flexDirection: "column-reverse",
            alignItems: "center",
            justifyContent: "center",
        },
        "#infoOverlay": {
            display: "none",
        },
        ".love-letters-box-root": {
            display: "flex",
            position: "absolute",
            width: "100%",
            height: "100%",
            color: "#ffffff",
            justifyContent: "center",
            alignItems: "center",
            flexDirection: "column",
            background: "#18181A",
            zIndex: 1,
        },
        ".love-letters-box-root.fade-out": {
            opacity: 0,
            transition: "opacity 0.5s",
        },
        "#letters-block": {
            position: "absolute",
            top: 0,
            left: 0,
            right: 0,
            bottom: 0,
            margin: "auto",
            color: "#ffffff",
            zIndex: 4,
            display: "flex",
            flexDirection: "column",
            justifyContent: "center",
            alignItems: "center",
            fontSize: "16px",
            textTransform: "initial",
            textAlign: "center",
        },
        "#letters-wrapper": {
            height: "77px",
            overflow: "hidden",
            position: "relative",
            display: "flex",
            flexDirection: "column",
            alignItems: "center",
            justifyContent: "flex-end",
            marginTop: "10px",
            paddingBottom: "2px",
        },
        "#letters-wrapper p": {
            textAlign: "center",
            lineHeight: 1.25,
            fontSize: "16px",
        },
        ".letter-animation:nth-last-of-type(1)::after": {
            display: "inline-block",
            animation: "dotty steps(1,end) 1s infinite",
            content: "''",
            position: "absolute",
        },
        ".letter-animation": {
            transition: "all 0.5s ease-in-out",
            transformOrigin: "bottom",
            margin: "0 auto",
        },
        ".letter-animation-enter": {
            animation: "fadeInUp 0.75s ease-out",
        },
        ".letter-animation-exit": {
            opacity: 0,
            scale: 0.9,
            transition: "all ease-in-out 1s",
            margin: 0,
        },
        "@keyframes dotty": {
            "0%": { content: "''" },
            "25%": { content: "'.'" },
            "50%": { content: "'..'" },
            "75%": { content: "'...'" },
            "100%": { content: "''" },
        },
        "@keyframes fadeInUp": {
            from: {
                opacity: 0,
                transform: " translateY(5px)",
                scale: 0.9,
            },
            to: {
                opacity: 1,
                transform: "translateY(0)",
                scale: 1,
            },
        },
        ".hidden": {
            display: "none",
            opacity: 0,
        },
        ".visible": {
            display: "block",
            opacity: 1,
            transition: "opacity 1s ease-out",
        },
    },
};


/***/ }),

/***/ 6469:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ArcwareLogoLoader = void 0;
class ArcwareLogoLoader {
    constructor() {
        this.arcwareLogoLoader = this.createArcwareLogoLoader();
    }
    createArcwareLogoLoader() {
        const arcwareLogoLoader = document.createElement("div");
        arcwareLogoLoader.classList.add("arcware-logo-loader");
        arcwareLogoLoader.innerHTML = this.getSvg();
        return arcwareLogoLoader;
    }
    getSvg() {
        return `
      <svg width="42" height="80" viewBox="0 0 42 80" xmlns="http://www.w3.org/2000/svg">
        <style>
          @keyframes ripple-1-down {
            0%, 50% { translate: 0 0; }
            60%, 100% { translate: 0 5px; }
          }
          @keyframes ripple-1-up {
            0%, 50% { translate: 0 0; }
            60%, 100% { translate: 0 -5px; }
          }
          @keyframes ripple-2-down {
            0%, 55% { translate: 0 0; }
            65%, 100% { translate: 0 5px; }
          }
          @keyframes ripple-3-down {
            0%, 60% { translate: 0 0; }
            70%, 100% { translate: 0 5px; }
          }
          @keyframes ripple-3-up {
            0%, 60% { translate: 0 0; }
            70%, 100% { translate: 0 -5px; }
          }
          @keyframes ripple-4-up {
            0%, 65% { translate: 0 0; }
            75%, 100% { translate: 0 -5px; }
          }

          .ripple-1-down { animation: ripple-1-down 0.6s infinite alternate; }
          .ripple-1-up   { animation: ripple-1-up 0.6s infinite alternate; }
          .ripple-2-down { animation: ripple-2-down 0.6s infinite alternate; }
          .ripple-3-down { animation: ripple-3-down 0.6s infinite alternate; }
          .ripple-3-up   { animation: ripple-3-up 0.6s infinite alternate; }
          .ripple-4-up   { animation: ripple-4-up 0.6s infinite alternate; }
        </style>

        <g class="ripple-1-down" fill="#f1f1f1">
          <rect y="38" width="6" height="22" />
        </g>
        <g class="ripple-1-up" fill="#f1f1f1">
          <rect y="10" width="6" height="22" />
        </g>
        <g class="ripple-2-down" fill="#f1f1f1">
          <rect x="12" width="6" height="32" />
          <rect x="12" y="38" width="6" height="22" />
        </g>
        <g class="ripple-3-down" fill="#f1f1f1">
          <rect x="24" y="38" width="6" height="22" />
        </g>
        <g class="ripple-3-up" fill="#f1f1f1">
          <rect x="24" y="10" width="6" height="22" />
        </g>
        <g class="ripple-4-up" fill="#f1f1f1">
          <rect x="36" y="10" width="6" height="22" />
          <rect x="36" y="38" width="6" height="32" />
        </g>
      </svg>
    `;
    }
}
exports.ArcwareLogoLoader = ArcwareLogoLoader;


/***/ }),

/***/ 9497:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AudioIcon = void 0;
class AudioIcon {
    constructor() {
        this.audioIconUnmuted = this.createAudioIconUnmuted();
        this.audioIconMuted = this.createAudioIconMuted();
    }
    createAudioIconUnmuted() {
        var _a;
        const audioIcon = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        audioIcon.setAttributeNS(null, "id", "audioIconUnmuted");
        audioIcon.setAttributeNS(null, "x", "31px");
        audioIcon.setAttributeNS(null, "y", "28px");
        audioIcon.setAttributeNS(null, "viewBox", "0 0 31 28");
        const svgGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
        (_a = svgGroup === null || svgGroup === void 0 ? void 0 : svgGroup.classList) === null || _a === void 0 ? void 0 : _a.add("svgIcon");
        audioIcon.appendChild(svgGroup);
        const path1 = document.createElementNS("http://www.w3.org/2000/svg", "path");
        path1.setAttributeNS(null, "d", "M21.0008,0.0720318C20.556,-0.117811,20.0379,0.0805569,19.8435,0.514827C19.6492,0.949098,19.8522,1.45512,20.297,1.6449C25.1233,3.70434,28.242,8.35761,28.2422,13.4998C28.2422,18.6423,25.1234,23.2957,20.2966,25.3551C19.8518,25.5448,19.6488,26.0508,19.8431,26.4852C19.9874,26.8077,20.3102,27,20.649,27C20.7664,27,20.8859,26.9769,21.0004,26.928C26.4674,24.5954,30,19.3246,30,13.4997C29.9998,7.67531,26.4674,2.40462,21.0008,0.0720318Z");
        const path2 = document.createElementNS("http://www.w3.org/2000/svg", "path");
        path2.setAttributeNS(null, "d", "M21.2351,6.69434C20.8735,6.37822,20.3179,6.4082,19.9941,6.76134C19.6703,7.11454,19.701,7.65706,20.0627,7.97324C21.6712,9.37932,22.5937,11.3937,22.5937,13.5C22.5937,15.6062,21.6711,17.6206,20.0627,19.0267C19.701,19.3428,19.6703,19.8854,19.9941,20.2386C20.1677,20.4279,20.4079,20.5244,20.6492,20.5244C20.8579,20.5244,21.0674,20.4522,21.2351,20.3056C23.2157,18.5744,24.3515,16.0937,24.3515,13.4999C24.3515,10.9061,23.2156,8.42553,21.2351,6.69434Z");
        const path3 = document.createElementNS("http://www.w3.org/2000/svg", "path");
        path3.setAttributeNS(null, "d", "M15.3973,2.16277C15.1018,2.01658,14.7473,2.04502,14.4803,2.23623L7.65176,7.12598H0.878906C0.393516,7.12598,0,7.51024,0,7.98422V19.0155C0,19.4895,0.393516,19.8738,0.878906,19.8738H7.6517L14.4802,24.7637C14.6339,24.8737,14.8164,24.9298,15.0001,24.9298C15.1356,24.9298,15.2718,24.8992,15.3973,24.8371C15.6927,24.6909,15.8789,24.395,15.8789,24.0716V2.9282C15.8789,2.60482,15.6927,2.30884,15.3973,2.16277ZM14.121,22.3778L8.45918,18.3234C8.30842,18.2154,8.12637,18.1572,7.93939,18.1572H1.75781V8.84246H7.93939C8.12631,8.84246,8.30842,8.78422,8.45912,8.67636L14.121,4.62197V22.3778Z");
        svgGroup.appendChild(path1);
        svgGroup.appendChild(path2);
        svgGroup.appendChild(path3);
        return audioIcon;
    }
    createAudioIconMuted() {
        var _a;
        const audioIcon = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        audioIcon.setAttributeNS(null, "id", "audioIconMuted");
        audioIcon.setAttributeNS(null, "x", "31px");
        audioIcon.setAttributeNS(null, "y", "28px");
        audioIcon.setAttributeNS(null, "viewBox", "0 -1 31 28");
        const svgGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
        (_a = svgGroup.classList) === null || _a === void 0 ? void 0 : _a.add("svgIcon");
        audioIcon.appendChild(svgGroup);
        const path1 = document.createElementNS("http://www.w3.org/2000/svg", "path");
        path1.setAttributeNS(null, "d", "M16.3501,0.829286C16.046,0.678799,15.6811,0.708072,15.4062,0.904912L8.37681,5.93848H1.40476C0.90509,5.93848,0.5,6.33404,0.5,6.82196V18.1777C0.5,18.6657,0.90509,19.0612,1.40476,19.0612H8.37675L15.4061,24.0949C15.5643,24.2082,15.7522,24.2659,15.9412,24.2659C16.0808,24.2659,16.221,24.2344,16.3501,24.1705C16.6542,24.02,16.8459,23.7154,16.8459,23.3825V1.61724C16.8459,1.28434,16.6542,0.979655,16.3501,0.829286ZM15.0364,21.6389L9.20798,17.4652C9.05278,17.3541,8.86538,17.2942,8.6729,17.2942H2.30951V7.70544H8.6729C8.86532,7.70544,9.05278,7.64548,9.20792,7.53446L15.0364,3.36082V21.6389Z");
        const path2 = document.createElementNS("http://www.w3.org/2000/svg", "path");
        path2.setAttributeNS(null, "d", "M25.2799,11.7634L21.8442,8.32748C21.6206,8.10399,21.6206,7.74264,21.8442,7.51915C22.0676,7.29566,22.429,7.29566,22.6525,7.51915L26.0883,10.955L29.524,7.51915C29.7476,7.29566,30.1088,7.29566,30.3323,7.51915C30.5559,7.74264,30.5559,8.10399,30.3323,8.32748L26.8966,11.7634L30.3323,15.1992C30.5559,15.4227,30.5559,15.7841,30.3323,16.0076C30.2209,16.1191,30.0745,16.1751,29.9281,16.1751C29.7818,16.1751,29.6355,16.1191,29.524,16.0076L26.0883,12.5717L22.6525,16.0076C22.541,16.1191,22.3947,16.1751,22.2483,16.1751C22.102,16.1751,21.9556,16.1191,21.8442,16.0076C21.6206,15.7841,21.6206,15.4227,21.8442,15.1992L25.2799,11.7634Z");
        svgGroup.appendChild(path1);
        svgGroup.appendChild(path2);
        return audioIcon;
    }
}
exports.AudioIcon = AudioIcon;


/***/ }),

/***/ 7734:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AudioButton = void 0;
const AudioIcon_1 = __webpack_require__(9497);
class AudioButton {
    constructor(stream) {
        this.stream = stream;
        this.setAudioMutedByDefault();
        this.button = this.createButton();
        this.audioIcon = new AudioIcon_1.AudioIcon();
        this.tooltipText = this.createTooltipText();
        this.button.appendChild(this.tooltipText);
        this.button.appendChild(this.audioIcon.audioIconMuted);
        this.button.appendChild(this.audioIcon.audioIconUnmuted);
        this.audioIcon.audioIconUnmuted.style.display = "none";
        this.button.addEventListener("click", this.toggleAudio.bind(this));
        // Bind the onVolumeChange method to the current instance
        this.onVolumeChange = this.onVolumeChange.bind(this);
        const videoElement = this.stream["webRtcController"].videoPlayer["videoElement"];
        videoElement.addEventListener("volumechange", this.onVolumeChange.bind(this));
    }
    setAudioMutedByDefault() {
        const videoElementParent = this.stream.videoElementParent;
        if (videoElementParent) {
            const videoElement = videoElementParent.querySelector("video");
            if (videoElement) {
                this.stream.toggleAudio(videoElement, true);
            }
        }
    }
    createButton() {
        var _a;
        const button = document.createElement("button");
        button === null || button === void 0 ? void 0 : button.setAttribute("id", "audioBtn");
        button === null || button === void 0 ? void 0 : button.setAttribute("type", "button");
        (_a = button === null || button === void 0 ? void 0 : button.classList) === null || _a === void 0 ? void 0 : _a.add("UiTool");
        return button;
    }
    createTooltipText() {
        var _a;
        const tooltipText = document.createElement("span");
        (_a = tooltipText === null || tooltipText === void 0 ? void 0 : tooltipText.classList) === null || _a === void 0 ? void 0 : _a.add("tooltiptext");
        tooltipText.innerHTML = "Mute/Unmute";
        return tooltipText;
    }
    toggleAudio() {
        const videoElementParent = this.stream.videoElementParent;
        if (videoElementParent) {
            const videoElement = videoElementParent.querySelector("video");
            if (videoElement) {
                const muted = !videoElement.muted;
                this.stream.toggleAudio(videoElement, muted);
                this.updateAudioIcon(muted);
            }
        }
    }
    updateAudioIcon(muted) {
        if (muted) {
            this.audioIcon.audioIconUnmuted.style.display = "none";
            this.audioIcon.audioIconMuted.style.display = "block";
        }
        else {
            this.audioIcon.audioIconMuted.style.display = "none";
            this.audioIcon.audioIconUnmuted.style.display = "block";
        }
    }
    get element() {
        return this.button;
    }
    onVolumeChange(event) {
        const videoElement = event.target;
        this.updateAudioIcon(videoElement.muted);
    }
}
exports.AudioButton = AudioButton;


/***/ }),

/***/ 4572:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LoveLetters = void 0;
class LoveLetters {
    constructor() {
        this.loveLettersRoot = null;
    }
    addLetter(letter, listLength) {
        var _a;
        const lettersBlock = document.querySelector("#letters-wrapper");
        const p = document.createElement("p");
        p.textContent = letter;
        (_a = p === null || p === void 0 ? void 0 : p.classList) === null || _a === void 0 ? void 0 : _a.add("letter-animation", "letter-animation-enter");
        if (lettersBlock) {
            lettersBlock.appendChild(p);
            this.updateOpacity(listLength);
        }
        setTimeout(() => {
            var _a;
            (_a = p === null || p === void 0 ? void 0 : p.classList) === null || _a === void 0 ? void 0 : _a.remove("letter-animation-enter");
            p === null || p === void 0 ? void 0 : p.addEventListener("transitioned", () => {
                this.updateOpacity(listLength);
            });
        }, 1000);
    }
    updateOpacity(listLength) {
        const letters = document.querySelectorAll("#letters-block p");
        const maxOpacity = 0.6;
        const minOpacity = 0;
        const multiplyCoeficient = 1.2 / letters.length;
        letters.forEach((letter, index) => {
            var _a;
            const htmlLetter = letter;
            const reverseIndex = letters.length - 1 - index;
            const opacity = maxOpacity - reverseIndex * multiplyCoeficient * (maxOpacity - minOpacity);
            if (listLength !== index + 1) {
                htmlLetter.style.opacity = Math.max(minOpacity, opacity).toString();
                (_a = htmlLetter === null || htmlLetter === void 0 ? void 0 : htmlLetter.classList) === null || _a === void 0 ? void 0 : _a.add("letter-animation-exit");
            }
            else {
                htmlLetter.style.opacity = "1";
            }
        });
    }
}
exports.LoveLetters = LoveLetters;


/***/ }),

/***/ 2293:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MicButton = void 0;
const lib_pixelstreamingfrontend_ue5_5_1 = __webpack_require__(693);
const MicIcon_1 = __webpack_require__(3527);
class MicButton {
    constructor(stream) {
        this.stream = stream;
        this.setMicMutedByDefault();
        this.button = this.createButton();
        this.micIcon = new MicIcon_1.MicIcon();
        this.tooltipText = this.createTooltipText();
        this.button.appendChild(this.tooltipText);
        this.button.appendChild(this.micIcon.micIconMuted);
        this.button.appendChild(this.micIcon.micIconUnmuted);
        this.micIcon.micIconUnmuted.style.display = "none";
        this.button.addEventListener("click", this.toggleMic.bind(this));
    }
    setMicMutedByDefault() {
        const videoElementParent = this.stream.videoElementParent;
        if (videoElementParent) {
            const videoElement = videoElementParent.querySelector("video");
            if (videoElement) {
                this.stream.toggleMic(false, true);
            }
        }
    }
    createButton() {
        var _a;
        const button = document.createElement("button");
        button.setAttribute("id", "micBtn");
        button.setAttribute("type", "button");
        (_a = button === null || button === void 0 ? void 0 : button.classList) === null || _a === void 0 ? void 0 : _a.add("UiTool");
        return button;
    }
    createTooltipText() {
        var _a;
        const tooltipText = document.createElement("span");
        (_a = tooltipText === null || tooltipText === void 0 ? void 0 : tooltipText.classList) === null || _a === void 0 ? void 0 : _a.add("tooltiptext");
        tooltipText.innerHTML = "Mic on/off";
        return tooltipText;
    }
    toggleMic() {
        var _a, _b;
        const micFlag = (_b = (_a = this === null || this === void 0 ? void 0 : this.stream) === null || _a === void 0 ? void 0 : _a.config) === null || _b === void 0 ? void 0 : _b.isFlagEnabled(lib_pixelstreamingfrontend_ue5_5_1.Flags.UseMic);
        this.stream.toggleMic(!micFlag, false);
        this.updateMicIcon(!micFlag);
    }
    updateMicIcon(micActive) {
        if (!micActive) {
            this.micIcon.micIconUnmuted.style.display = "none";
            this.micIcon.micIconMuted.style.display = "block";
        }
        else {
            this.micIcon.micIconMuted.style.display = "none";
            this.micIcon.micIconUnmuted.style.display = "block";
        }
    }
    get element() {
        return this.button;
    }
}
exports.MicButton = MicButton;


/***/ }),

/***/ 3527:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MicIcon = void 0;
class MicIcon {
    constructor() {
        this.micIconUnmuted = this.createMicIconUnmuted();
        this.micIconMuted = this.createMicIconMuted();
    }
    createMicIconUnmuted() {
        var _a;
        const micIcon = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        micIcon.setAttributeNS(null, "id", "micIconUnmuted");
        micIcon.setAttributeNS(null, "x", "24px");
        micIcon.setAttributeNS(null, "y", "24px");
        micIcon.setAttributeNS(null, "viewBox", "0 -1 24 24");
        const svgGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
        (_a = svgGroup === null || svgGroup === void 0 ? void 0 : svgGroup.classList) === null || _a === void 0 ? void 0 : _a.add("svgIcon");
        micIcon.appendChild(svgGroup);
        const path1 = document.createElementNS("http://www.w3.org/2000/svg", "path");
        path1.setAttributeNS(null, "d", "M12 14c1.66,0,2.99-1.34,2.99-3L15,5c0-1.66-1.34-3-3-3S9,3.34,9,5v6c0,1.66,1.34,3,3,3zm5.3-3c0,3-2.54,5.1-5.3,5.1S6.7,14,6.7,11H5c0,3.41,2.72,6.23,6,6.72V21h2v-3.28c3.28-.48,6-3.3,6-6.72h-1.7z");
        svgGroup.appendChild(path1);
        return micIcon;
    }
    createMicIconMuted() {
        var _a;
        const micIcon = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        micIcon.setAttributeNS(null, "id", "micIconMuted");
        micIcon.setAttributeNS(null, "x", "24px");
        micIcon.setAttributeNS(null, "y", "24px");
        micIcon.setAttributeNS(null, "viewBox", "0 -1 24 24");
        const svgGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
        (_a = svgGroup === null || svgGroup === void 0 ? void 0 : svgGroup.classList) === null || _a === void 0 ? void 0 : _a.add("svgIcon");
        micIcon.appendChild(svgGroup);
        const path1 = document.createElementNS("http://www.w3.org/2000/svg", "path");
        path1.setAttributeNS(null, "d", "M19,11h-1.7c0,.74-.16,1.43-.43,2.05l1.23,1.23c.56-.98.9-2.09.9-3.28zm-4.02.17c0-.06.02-.11.02-.17V5c0-1.66-1.34-3-3-3S9,3.34,9,5v.18l5.98,5.99zM4.27,3,3,4.27l6.01,6.01V11c0,1.66,1.33,3,2.99,3,.22,0,.44-.03.65-.08l1.66,1.66c-.71.33-1.5.52-2.31.52-2.76,0-5.3-2.1-5.3-5.1H5c0,3.41,2.72,6.23,6,6.72V21h2v-3.28c.91-.13,1.77-.45,2.54-.9L19.73,21,21,19.73,4.27,3z");
        svgGroup.appendChild(path1);
        return micIcon;
    }
}
exports.MicIcon = MicIcon;


/***/ }),

/***/ 3613:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MicrophoneOverlay = void 0;
const MicIcon_1 = __webpack_require__(3527);
class MicrophoneOverlay {
    constructor(stream) {
        this.overlay = null;
        this.stream = stream;
        this.micIcon = new MicIcon_1.MicIcon();
        this.parentElement = stream === null || stream === void 0 ? void 0 : stream.videoElementParent;
    }
    createOverlay() {
        var _a, _b;
        if (this.parentElement) {
            if (this.overlay) {
                this.parentElement.removeChild(this.overlay);
                this.overlay = null;
            }
            // Create the overlay element
            this.overlay = document.createElement("div");
            this.overlay.id = "microphoneOverlay";
            (_b = (_a = this.overlay) === null || _a === void 0 ? void 0 : _a.classList) === null || _b === void 0 ? void 0 : _b.add("hiddenState");
            // Append the icons to the overlay
            this.overlay.appendChild(this.micIcon.micIconUnmuted);
            this.overlay.appendChild(this.micIcon.micIconMuted);
            this.micIcon.micIconMuted.style.display = "none";
            // Create the title div element
            const titleDiv = document.createElement("div");
            titleDiv.className = "title";
            titleDiv.textContent = "Enabling microphone..."; // Default text
            // Create the paragraph element
            const paragraph = document.createElement("p");
            paragraph.textContent =
                "Please check your browser's prompt to allow microphone access. You may also need to re-enable the sound."; // Default text
            // Append the title and paragraph to the overlay
            this.overlay.appendChild(titleDiv);
            this.overlay.appendChild(paragraph);
            // Append the overlay to the parent element
            this.parentElement.appendChild(this.overlay);
        }
    }
    toggleMessage(enabled) {
        if (this.parentElement) {
            if (this.overlay) {
                // Find the title and paragraph elements
                const titleElement = this.overlay.querySelector(".title");
                const paragraphElement = this.overlay.querySelector("p");
                this.micIcon.micIconMuted.style.display = enabled ? "none" : "block";
                this.micIcon.micIconUnmuted.style.display = enabled ? "block" : "none";
                // Update the title and paragraph text
                if (titleElement)
                    titleElement.textContent = enabled ? "Enabling microphone" : "Disabling microphone";
                if (paragraphElement)
                    paragraphElement.textContent = enabled
                        ? "Please check your browser's prompt to allow microphone access. You may also need to re-enable the sound."
                        : "Please wait. You may need to re-enable the sound.";
            }
        }
    }
    toggleVisibility(visible) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
        if (this.parentElement) {
            const infoOverlay = (_a = this === null || this === void 0 ? void 0 : this.parentElement) === null || _a === void 0 ? void 0 : _a.querySelector("#infoOverlay");
            const disconnectOverlay = (_b = this === null || this === void 0 ? void 0 : this.parentElement) === null || _b === void 0 ? void 0 : _b.querySelector("#disconnectOverlay");
            const errorOverlay = (_c = this === null || this === void 0 ? void 0 : this.parentElement) === null || _c === void 0 ? void 0 : _c.querySelector("#errorOverlay");
            const className = "mic-overlay-is-visible";
            if (this.overlay && infoOverlay && disconnectOverlay && errorOverlay) {
                if (visible) {
                    (_d = infoOverlay === null || infoOverlay === void 0 ? void 0 : infoOverlay.classList) === null || _d === void 0 ? void 0 : _d.add(className);
                    (_e = disconnectOverlay === null || disconnectOverlay === void 0 ? void 0 : disconnectOverlay.classList) === null || _e === void 0 ? void 0 : _e.add(className);
                    (_f = errorOverlay === null || errorOverlay === void 0 ? void 0 : errorOverlay.classList) === null || _f === void 0 ? void 0 : _f.add(className);
                    (_h = (_g = this === null || this === void 0 ? void 0 : this.overlay) === null || _g === void 0 ? void 0 : _g.classList) === null || _h === void 0 ? void 0 : _h.remove("hiddenState");
                }
                else {
                    (_k = (_j = this === null || this === void 0 ? void 0 : this.overlay) === null || _j === void 0 ? void 0 : _j.classList) === null || _k === void 0 ? void 0 : _k.add("hiddenState");
                    (_l = infoOverlay === null || infoOverlay === void 0 ? void 0 : infoOverlay.classList) === null || _l === void 0 ? void 0 : _l.remove(className);
                    (_m = disconnectOverlay === null || disconnectOverlay === void 0 ? void 0 : disconnectOverlay.classList) === null || _m === void 0 ? void 0 : _m.remove(className);
                    (_o = errorOverlay === null || errorOverlay === void 0 ? void 0 : errorOverlay.classList) === null || _o === void 0 ? void 0 : _o.remove(className);
                }
            }
        }
    }
}
exports.MicrophoneOverlay = MicrophoneOverlay;


/***/ }),

/***/ 1038:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PlayIcon = void 0;
class PlayIcon {
    constructor() {
        this.playIcon = this.createPlayIcon();
    }
    createPlayIcon() {
        var _a;
        const playIcon = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        playIcon.setAttributeNS(null, "id", "playIcon");
        playIcon.setAttributeNS(null, "x", "24px");
        playIcon.setAttributeNS(null, "y", "24px");
        playIcon.setAttributeNS(null, "viewBox", "0 0 24 24");
        const svgGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
        (_a = svgGroup === null || svgGroup === void 0 ? void 0 : svgGroup.classList) === null || _a === void 0 ? void 0 : _a.add("svgIcon");
        playIcon.appendChild(svgGroup);
        const path1 = document.createElementNS("http://www.w3.org/2000/svg", "path");
        path1.setAttributeNS(null, "d", "M8 5v14l11-7z");
        svgGroup.appendChild(path1);
        return playIcon;
    }
}
exports.PlayIcon = PlayIcon;


/***/ }),

/***/ 9684:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StopButton = void 0;
const StopIcon_1 = __webpack_require__(2446);
const PlayIcon_1 = __webpack_require__(1038);
class StopButton {
    constructor(stream) {
        this.isStreaming = true; // Assuming streaming starts by default
        this.stream = stream;
        this.button = this.createButton();
        this.stopIcon = new StopIcon_1.StopIcon();
        this.playIcon = new PlayIcon_1.PlayIcon();
        this.tooltipText = this.createTooltipText();
        this.button.appendChild(this.tooltipText);
        this.button.appendChild(this.stopIcon.stopIcon);
        this.button.addEventListener("click", this.toggleStreaming.bind(this));
        stream.onStreamingStateChange(this.updateButtonState.bind(this));
    }
    createButton() {
        var _a;
        const button = document.createElement("button");
        button === null || button === void 0 ? void 0 : button.setAttribute("id", "stopBtn");
        button === null || button === void 0 ? void 0 : button.setAttribute("type", "button");
        (_a = button === null || button === void 0 ? void 0 : button.classList) === null || _a === void 0 ? void 0 : _a.add("UiTool");
        return button;
    }
    createTooltipText() {
        var _a;
        const tooltipText = document.createElement("span");
        (_a = tooltipText === null || tooltipText === void 0 ? void 0 : tooltipText.classList) === null || _a === void 0 ? void 0 : _a.add("tooltiptext");
        tooltipText.innerHTML = "Disconnect";
        return tooltipText;
    }
    toggleStreaming() {
        this.isStreaming = !this.isStreaming;
        this.updateButtonIcon();
        if (this.isStreaming) {
            this.stream.reconnect();
        }
        else {
            this.stream.disconnect();
        }
    }
    updateButtonIcon() {
        // Determine which icon + tooltip should be currently displayed
        const currentIcon = this.isStreaming ? this.stopIcon.stopIcon : this.playIcon.playIcon;
        const currentTooltipText = this.isStreaming ? "Disconnect" : "Reconnect";
        // Update tooltip text
        this.tooltipText.innerHTML = currentTooltipText;
        // Remove the first child if it exists
        if (this.button.firstChild) {
            this.button.removeChild(this.button.children[1]);
        }
        // Append the new icon
        this.button.appendChild(currentIcon);
    }
    get element() {
        return this.button;
    }
    updateButtonState(isStreaming) {
        this.isStreaming = isStreaming;
        this.updateButtonIcon();
    }
}
exports.StopButton = StopButton;


/***/ }),

/***/ 2446:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StopIcon = void 0;
class StopIcon {
    constructor() {
        this.stopIcon = this.createStopIcon();
    }
    createStopIcon() {
        var _a;
        const stopIcon = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        stopIcon.setAttributeNS(null, "id", "stopIcon");
        stopIcon.setAttributeNS(null, "x", "24px");
        stopIcon.setAttributeNS(null, "y", "24px");
        stopIcon.setAttributeNS(null, "viewBox", "0 -1 24 24");
        const svgGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
        (_a = svgGroup === null || svgGroup === void 0 ? void 0 : svgGroup.classList) === null || _a === void 0 ? void 0 : _a.add("svgIcon");
        stopIcon === null || stopIcon === void 0 ? void 0 : stopIcon.appendChild(svgGroup);
        const path1 = document.createElementNS("http://www.w3.org/2000/svg", "path");
        path1.setAttributeNS(null, "d", "M6 6h12v12H6z");
        svgGroup.appendChild(path1);
        return stopIcon;
    }
}
exports.StopIcon = StopIcon;


/***/ }),

/***/ 7910:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __webpack_require__(655);
tslib_1.__exportStar(__webpack_require__(318), exports);


/***/ }),

/***/ 1344:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ZErrorMessage = void 0;
const zod_1 = __webpack_require__(8754);
exports.ZErrorMessage = zod_1.z.object({
    type: zod_1.z.literal("error"),
    code: zod_1.z.number().int(),
    reason: zod_1.z.string(),
    verbosity: zod_1.z.number(),
});


/***/ }),

/***/ 383:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ZLoveLetter = void 0;
const zod_1 = __webpack_require__(8754);
exports.ZLoveLetter = zod_1.z.object({
    type: zod_1.z.literal("letter"),
    reason: zod_1.z.string().startsWith("LL: "),
    code: zod_1.z.number(),
    verbosity: zod_1.z.number(),
});


/***/ }),

/***/ 1224:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ZPing = void 0;
const zod_1 = __webpack_require__(8754);
exports.ZPing = zod_1.z.object({
    type: zod_1.z.literal("ping"),
    message: zod_1.z.string().optional(),
    time: zod_1.z.number()
});


/***/ }),

/***/ 4882:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ZQueue = void 0;
const zod_1 = __webpack_require__(8754);
exports.ZQueue = zod_1.z.object({
    type: zod_1.z.literal("queue"),
    queue: zod_1.z.object({
        /** Ticket._id - will not be exposed to frontend. */
        // _id: z.string().optional()
        /** Position in queue (zero based). */
        index: zod_1.z.number().int().optional(),
        /** Length of the queue. */
        queueLength: zod_1.z.number().int().optional(),
        /** Already waited for. */
        waited: zod_1.z.number().optional(),
        /** Based on Average Watch Time,
         * we calculate an average interval of expected connection closings and based on the amount of concurrent sessions,
         * we can calculate the estimated time until another slot will be freed up. */
        estimatedWaitTime: zod_1.z.number().optional().nullable(),
        /** The average time all current sessions.
         * (How long did it actually take those that waited for them that received a connection to the currently running instances.)
         */
        averageWaitTime: zod_1.z.number().optional().nullable(),
        /** Type of all time-values in the que. */
        valueType: zod_1.z.enum(["milliseconds", "seconds", "minutes", "hours", "days"]),
    }),
});


/***/ }),

/***/ 1919:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ZRender = void 0;
const zod_1 = __webpack_require__(8754);
exports.ZRender = zod_1.z.object({
    type: zod_1.z.literal("render")
});


/***/ }),

/***/ 4201:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ZSessionId = void 0;
const zod_1 = __webpack_require__(8754);
exports.ZSessionId = zod_1.z.object({
    type: zod_1.z.literal("sessionId"),
    sessionId: zod_1.z.string(),
});


/***/ }),

/***/ 3403:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ZStats = void 0;
const zod_1 = __webpack_require__(8754);
exports.ZStats = zod_1.z.object({
    type: zod_1.z.literal("stats"),
    stats: zod_1.z
        .object({
        /**
         * Other known properties.
         */
        codecs: zod_1.z.custom(),
        candidatePair: zod_1.z.custom(),
        localCandidates: zod_1.z.custom(),
        remoteCandidates: zod_1.z.custom(),
        DataChannelStats: zod_1.z.custom(),
        // Received (last) for ticket
        bytesReceived: zod_1.z.number(),
        // Packets Lost (last) for ticket
        packetsLost: zod_1.z.number(),
        // Video resolution: highest lowest average (portrait) and highest lowest average (landscape) for ticket
        frameWidth: zod_1.z.number(),
        // Video resolution: highest lowest average (portrait) and highest lowest average (landscape) for ticket
        frameHeight: zod_1.z.number(),
        // Frames decoded (Last) for ticket
        framesDecoded: zod_1.z.number(),
        // Framerate (low / high, avg) for ticket
        framesPerSecond: zod_1.z.number(),
        // frames dropped (last) for ticket
        framesDropped: zod_1.z.number(),
        // Videocodec (once) for ticket
        videoCodec: zod_1.z.string(),
        // audiocodec (once) for ticket
        audioCodec: zod_1.z.string(),
        // browser type and version for ticket (arcware / addition)
        browserInfo: zod_1.z
            .object({
            userAgent: zod_1.z.string(),
            platform: zod_1.z.string().nullable(),
            language: zod_1.z.string(),
        })
            .passthrough()
            .partial(),
        // Net RTT (low, high, avg)
        currentRTT: zod_1.z.number(),
        // Duration (last)
        sessionRunTime: zod_1.z.string(),
        // Controls stream input (??)
        controlsStreamInput: zod_1.z.string().refine((arg) => arg === "true" || arg === "false"),
        // video quantization parameter (low / high / avg if applicable)
        videoEncoderAvgQP: zod_1.z.number(),
        // Video bitrate (min / max / avg)
        videoBitrate: zod_1.z.number(),
        // Audio bitrate (min / max / avg)
        audioBitrate: zod_1.z.number(),
    })
        .passthrough()
        .partial(),
});


/***/ }),

/***/ 2750:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ZStreamInfo = void 0;
const zod_1 = __webpack_require__(8754);
const WebSdkSettings_1 = __webpack_require__(9864);
exports.ZStreamInfo = zod_1.z.object({
    type: zod_1.z.literal("streamInfo"),
    streamInfo: zod_1.z.object({
        guid: zod_1.z.string(),
        autoPlay: zod_1.z.boolean().optional(),
        touchCapable: zod_1.z.boolean().optional(),
        resolution: zod_1.z
            .object({
            width: zod_1.z.number().int().nonnegative(),
            height: zod_1.z.number().int().nonnegative(),
            dynamic: zod_1.z.boolean().optional(),
            fixed: zod_1.z.boolean().optional()
        })
            .optional(),
        meta: zod_1.z
            .object({
            friendlyName: zod_1.z.string().optional(),
            isTrial: zod_1.z.boolean().optional(),
            mouseLock: zod_1.z.boolean().optional(),
            poweredBy: zod_1.z.boolean().optional(),
            version: zod_1.z.string().optional()
        })
            .optional(),
        webSdkSettings: WebSdkSettings_1.WebSdkSettings.optional(),
        afk: zod_1.z
            .object({
            enabled: zod_1.z.boolean().describe("Enables / Disables AFK functionality."),
            warn: zod_1.z
                .number()
                .int()
                .nonnegative()
                .describe("Time in seconds, after last interaction, when the first warning will be triggered."),
            error: zod_1.z
                .number()
                .int()
                .nonnegative()
                .describe("Time in seconds, after warn trigger, when a more pushy warning will be triggered."),
            action: zod_1.z
                .number()
                .int()
                .nonnegative()
                .describe("Time in seconds, after error trigger, the actual disconnection action will take place.")
        }, {
            description: "AFK stands for 'away from keyboard' and describes a timeout based on activity of the actual project. All execution of these settings are prone to frontend and therefore no full security measure for abuse! These settings can be overwritten by shareId, but would overwrite the settings given through frontend configuration."
        })
            .optional()
    })
});


/***/ }),

/***/ 3751:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ZVersion = void 0;
const zod_1 = __webpack_require__(8754);
exports.ZVersion = zod_1.z.object({
    type: zod_1.z.literal("version"),
    version: zod_1.z.string().optional(),
});


/***/ }),

/***/ 9864:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebSdkSettings = void 0;
const zod_1 = __webpack_require__(8754);
const disabledDisclaimer = "Disabled: To purchase this option, please contact our sales department by clicking the 'Create Support Ticket' button on the Help Center page.";
exports.WebSdkSettings = zod_1.z
    .object({
    conf: zod_1.z
        .object({
        fullscreenButton: zod_1.z
            .boolean()
            .default(true)
            .describe([
            "Full-Screen Button|",
            "Override Enable/Disable Enable/Disable the full-screen button.",
            "Info: Please be aware that iOS (iPhone devices) does not support full-screen mode, and as a result, the button will not be displayed on these devices.",
        ].join("\n"))
            .optional(),
        stopButton: zod_1.z
            .boolean()
            .default(true)
            .describe([
            "Stop Button|",
            "Override Enable/Disable the stop overlay-button.",
            "Info: Manually stops the connection.",
        ].join("\n"))
            .optional(),
        // Default: false, for cleaner UI.
        audioButton: zod_1.z
            .boolean()
            .default(false)
            .describe([
            "Audio Button|",
            "Override Enable/Disable the audio overlay-button.",
            "Info: Displays the audio button if your Unreal Engine application includes audio.",
        ].join("\n"))
            .optional(),
        // Even though it's defaulted to false, it can still be enabled while being false by using the "i" query parameter: https://some-url/?i
        infoButton: zod_1.z
            .boolean()
            .default(false)
            .describe(["Info Button|", "Override Enable/Disable the info overlay-button."].join("\n"))
            .optional(),
        micButton: zod_1.z
            .boolean()
            .default(false)
            .describe([
            "Mic Button|",
            "Override Enable/Disable the microphone overlay-button.",
            "Info: Enables users to interact with the Unreal Engine application using a microphone, which must be manually enabled by the user.",
        ].join("\n"))
            .optional(),
        settingsButton: zod_1.z
            .boolean()
            .default(false)
            .describe(["Settings Button|", "Override Enable/Disable the settings overlay-button."].join("\n"))
            .optional(),
        connectionStrengthIcon: zod_1.z
            .boolean()
            .default(false)
            .describe(["Connection Strength|", "Override Enable/Disable the connection strength overlay-icon."].join("\n"))
            .optional(),
        // errorHandler: zat(z.boolean()).optional(),
        // loveLetterHandler: zat(z.boolean()).optional(),
        // loveLetterLogging: zat(z.boolean()).optional(),
        // Enabled by default.
        // connectionIdentifierLoggingDisabled: zat(z.boolean()).optional(),
        // queueHandler: zat(z.boolean()).optional(),
        // sessionIdHandler: zat(z.boolean()).optional(),
    })
        .optional(),
    init: zod_1.z
        .object({
        // Input
        KeyboardInput: zod_1.z
            .boolean()
            .default(true)
            .describe([
            "Keyboard Input|",
            "Override 'KeyboardInput' property of the WebSDK integration.",
            "Info: Allows keyboard input events.",
        ].join("\n"))
            .optional(),
        MouseInput: zod_1.z
            .boolean()
            .default(true)
            .describe([
            "Mouse Input|",
            "Override 'MouseInput' property of the WebSDK integration.",
            "Info: Allows mouse input events.",
        ].join("\n"))
            .optional(),
        GamepadInput: zod_1.z
            .boolean()
            .describe([
            "Game pad Input|",
            "Override 'GamepadInput' property of the WebSDK integration.",
            "Info: Allows input events from gamepad controllers.",
        ].join("\n"))
            .optional(),
        TouchInput: zod_1.z
            .boolean()
            .describe([
            "Touch Input|",
            "Override 'TouchInput' property of the WebSDK integration.",
            "Info: Allows touch events on mobile devices and tablets.",
        ].join("\n"))
            .optional(),
        XRControllerInput: zod_1.z
            .boolean()
            .describe([
            "XR Controller Input|",
            "Override 'XRControllerInput' property of the WebSDK integration.",
            "Info: Allows input events from XR controllers for use with AR and VR setups.",
        ].join("\n"))
            .optional(),
        // UseMic:
        //   z.boolean().describe(["UseMic|", "Override use mic property of the WebSDK integration."].join("\n"))
        //  .optional(),
        FakeMouseWithTouches: zod_1.z
            .boolean()
            .describe([
            "Fake mouse with touches |",
            "Override 'FakeMouseWithTouches' property of the WebSDK integration. When enabled this setting will convert single-finger touch input to mouse input.",
            "Info: When this option is enabled, and the user is viewing the stream on a device with a touch screen such as a smartphone or tablet, this setting causes single-finger touch events to be interpreted by the Unreal Engine application as mouse clicks and drag events. Enabling this setting can provide users on mobile devices with the ability to partially control your Unreal Engine application, even when the application's input controller does not specifically handle touch input events.",
        ].join("\n"))
            .optional(),
        ForceMonoAudio: zod_1.z
            .boolean()
            .describe(["Force mono audio|", "Override 'ForceMonoAudio' of the WebSDK integration."].join("\n"))
            .optional(),
        HoveringMouse: zod_1.z
            .boolean()
            .describe(["Hovering mouse|", "Override 'HoveringMouse' property of the WebSDK integration."].join("\n"))
            .optional(),
        // MatchViewportRes: zat(
        //   z
        //     .boolean()
        //     .describe(["MatchViewportRes|", "Override match viewport res property of the WebSDK integration."].join("\n"))
        // ).optional(),
        // SuppressBrowserKeys: zat(
        //   z
        //     .boolean()
        //     .describe(
        //       ["SuppressBrowserKeys|", "Override suppress browser keys property of the WebSDK integration."].join("\n")
        //     )
        // ).optional(),
        // These make no sense, since the data flows only with the streamInfo
        // AutoConnect: zat(
        //   z.boolean().default(false).describe(["AutoConnect|", "To be described."].join("\n"))
        // ).optional(),
        // StartVideoMuted: zat(
        //   z.boolean().default(true).describe(["StartVideoMuted|", "To be described."].join("\n"))
        // ).optional(),
        // AutoPlayVideo: zat(
        //   z.boolean().default(true).describe(["AutoPlayVideo|", "To be described."].join("\n"))
        // ).optional(),
        // No effect:
        // ForceTURN: zat(z.boolean().describe(["ForceTURN|", "To be described."].join("\n"))).optional(),
        // AFKTimeout: zat(z.number().describe(["AFKTimeout|", "To be described."].join("\n"))).optional(),
        // MaxQP: zat(z.number().int().min().max().describe(["Todo Title|","To be described."].join("\n"))).optional(),
        // MinQP: zat(z.number().int().min().max().describe(["Todo Title|","To be described."].join("\n"))).optional(),
        // OfferToReceive: zat(z.boolean().describe(["Todo Title|","To be described."].join("\n"))).optional(),
        // PreferredCodec: zat(z.literal().describe(["Todo Title|","To be described."].join("\n"))).optional(),
        // preferSFU: zat(z.boolean().describe(["Todo Title|","To be described."].join("\n"))).optional(),
        // StreamerId: zat(z.boolean().describe(["Todo Title|","To be described."].join("\n"))).optional(),
        // TimeoutIfIdle: zat(z.boolean().describe(["Todo Title|","To be described."].join("\n"))).optional(),
        // Don't know whether we want to have that or not.
        // ControlsQuality: zat(z.boolean().describe(["ControlsQuality|", "To be described."].join("\n"))).optional(),
        // WebRTCFPS: zat(z.number().describe(["WebRTCFPS|", "To be described."].join("\n"))).optional(),
        // WebRTCMaxBitrate: zat(z.number().describe(["WebRTCMaxBitrate|", "To be described."].join("\n"))).optional(),
        // WebRTCMinBitrate: zat(z.number().describe(["WebRTCMinBitrate|", "To be described."].join("\n"))).optional(),
    })
        .optional(),
})
    .strict();


/***/ }),

/***/ 5387:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Send = void 0;
const tslib_1 = __webpack_require__(655);
tslib_1.__exportStar(__webpack_require__(1344), exports);
tslib_1.__exportStar(__webpack_require__(383), exports);
tslib_1.__exportStar(__webpack_require__(4201), exports);
tslib_1.__exportStar(__webpack_require__(2750), exports);
tslib_1.__exportStar(__webpack_require__(3403), exports);
tslib_1.__exportStar(__webpack_require__(1224), exports);
tslib_1.__exportStar(__webpack_require__(4882), exports);
tslib_1.__exportStar(__webpack_require__(3751), exports);
tslib_1.__exportStar(__webpack_require__(9864), exports);
tslib_1.__exportStar(__webpack_require__(1919), exports);
const Stats_1 = __webpack_require__(3403);
exports.Send = {
    stats: Stats_1.ZStats
};


/***/ }),

/***/ 318:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Messages = void 0;
exports.Messages = __webpack_require__(5387);


/***/ }),

/***/ 655:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "__assign": () => (/* binding */ __assign),
/* harmony export */   "__asyncDelegator": () => (/* binding */ __asyncDelegator),
/* harmony export */   "__asyncGenerator": () => (/* binding */ __asyncGenerator),
/* harmony export */   "__asyncValues": () => (/* binding */ __asyncValues),
/* harmony export */   "__await": () => (/* binding */ __await),
/* harmony export */   "__awaiter": () => (/* binding */ __awaiter),
/* harmony export */   "__classPrivateFieldGet": () => (/* binding */ __classPrivateFieldGet),
/* harmony export */   "__classPrivateFieldIn": () => (/* binding */ __classPrivateFieldIn),
/* harmony export */   "__classPrivateFieldSet": () => (/* binding */ __classPrivateFieldSet),
/* harmony export */   "__createBinding": () => (/* binding */ __createBinding),
/* harmony export */   "__decorate": () => (/* binding */ __decorate),
/* harmony export */   "__esDecorate": () => (/* binding */ __esDecorate),
/* harmony export */   "__exportStar": () => (/* binding */ __exportStar),
/* harmony export */   "__extends": () => (/* binding */ __extends),
/* harmony export */   "__generator": () => (/* binding */ __generator),
/* harmony export */   "__importDefault": () => (/* binding */ __importDefault),
/* harmony export */   "__importStar": () => (/* binding */ __importStar),
/* harmony export */   "__makeTemplateObject": () => (/* binding */ __makeTemplateObject),
/* harmony export */   "__metadata": () => (/* binding */ __metadata),
/* harmony export */   "__param": () => (/* binding */ __param),
/* harmony export */   "__propKey": () => (/* binding */ __propKey),
/* harmony export */   "__read": () => (/* binding */ __read),
/* harmony export */   "__rest": () => (/* binding */ __rest),
/* harmony export */   "__runInitializers": () => (/* binding */ __runInitializers),
/* harmony export */   "__setFunctionName": () => (/* binding */ __setFunctionName),
/* harmony export */   "__spread": () => (/* binding */ __spread),
/* harmony export */   "__spreadArray": () => (/* binding */ __spreadArray),
/* harmony export */   "__spreadArrays": () => (/* binding */ __spreadArrays),
/* harmony export */   "__values": () => (/* binding */ __values)
/* harmony export */ });
/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    }
    return __assign.apply(this, arguments);
}

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
}

function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
        var context = {};
        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
        context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.push(_);
        }
        else if (_ = accept(result)) {
            if (kind === "field") initializers.push(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
};

function __runInitializers(thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
};

function __propKey(x) {
    return typeof x === "symbol" ? x : "".concat(x);
};

function __setFunctionName(f, name, prefix) {
    if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
    return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
};

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

var __createBinding = Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});

function __exportStar(m, o) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
}

function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

/** @deprecated */
function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

/** @deprecated */
function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
}

function __spreadArray(to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
}

function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }
}

function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};

var __setModuleDefault = Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
};

function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
}

function __importDefault(mod) {
    return (mod && mod.__esModule) ? mod : { default: mod };
}

function __classPrivateFieldGet(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}

function __classPrivateFieldSet(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
}

function __classPrivateFieldIn(state, receiver) {
    if (receiver === null || (typeof receiver !== "object" && typeof receiver !== "function")) throw new TypeError("Cannot use 'in' operator on non-object");
    return typeof state === "function" ? receiver === state : state.has(receiver);
}


/***/ }),

/***/ 7026:
/***/ ((module) => {



module.exports = function () {
  throw new Error(
    'ws does not work in the browser. Browser clients must use the native ' +
      'WebSocket object'
  );
};


/***/ }),

/***/ 8280:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ZodError = exports.quotelessJson = exports.ZodIssueCode = void 0;
const util_1 = __webpack_require__(9110);
exports.ZodIssueCode = util_1.util.arrayToEnum([
    "invalid_type",
    "invalid_literal",
    "custom",
    "invalid_union",
    "invalid_union_discriminator",
    "invalid_enum_value",
    "unrecognized_keys",
    "invalid_arguments",
    "invalid_return_type",
    "invalid_date",
    "invalid_string",
    "too_small",
    "too_big",
    "invalid_intersection_types",
    "not_multiple_of",
    "not_finite",
]);
const quotelessJson = (obj) => {
    const json = JSON.stringify(obj, null, 2);
    return json.replace(/"([^"]+)":/g, "$1:");
};
exports.quotelessJson = quotelessJson;
class ZodError extends Error {
    constructor(issues) {
        super();
        this.issues = [];
        this.addIssue = (sub) => {
            this.issues = [...this.issues, sub];
        };
        this.addIssues = (subs = []) => {
            this.issues = [...this.issues, ...subs];
        };
        const actualProto = new.target.prototype;
        if (Object.setPrototypeOf) {
            // eslint-disable-next-line ban/ban
            Object.setPrototypeOf(this, actualProto);
        }
        else {
            this.__proto__ = actualProto;
        }
        this.name = "ZodError";
        this.issues = issues;
    }
    get errors() {
        return this.issues;
    }
    format(_mapper) {
        const mapper = _mapper ||
            function (issue) {
                return issue.message;
            };
        const fieldErrors = { _errors: [] };
        const processError = (error) => {
            for (const issue of error.issues) {
                if (issue.code === "invalid_union") {
                    issue.unionErrors.map(processError);
                }
                else if (issue.code === "invalid_return_type") {
                    processError(issue.returnTypeError);
                }
                else if (issue.code === "invalid_arguments") {
                    processError(issue.argumentsError);
                }
                else if (issue.path.length === 0) {
                    fieldErrors._errors.push(mapper(issue));
                }
                else {
                    let curr = fieldErrors;
                    let i = 0;
                    while (i < issue.path.length) {
                        const el = issue.path[i];
                        const terminal = i === issue.path.length - 1;
                        if (!terminal) {
                            curr[el] = curr[el] || { _errors: [] };
                            // if (typeof el === "string") {
                            //   curr[el] = curr[el] || { _errors: [] };
                            // } else if (typeof el === "number") {
                            //   const errorArray: any = [];
                            //   errorArray._errors = [];
                            //   curr[el] = curr[el] || errorArray;
                            // }
                        }
                        else {
                            curr[el] = curr[el] || { _errors: [] };
                            curr[el]._errors.push(mapper(issue));
                        }
                        curr = curr[el];
                        i++;
                    }
                }
            }
        };
        processError(this);
        return fieldErrors;
    }
    toString() {
        return this.message;
    }
    get message() {
        return JSON.stringify(this.issues, util_1.util.jsonStringifyReplacer, 2);
    }
    get isEmpty() {
        return this.issues.length === 0;
    }
    flatten(mapper = (issue) => issue.message) {
        const fieldErrors = {};
        const formErrors = [];
        for (const sub of this.issues) {
            if (sub.path.length > 0) {
                fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
                fieldErrors[sub.path[0]].push(mapper(sub));
            }
            else {
                formErrors.push(mapper(sub));
            }
        }
        return { formErrors, fieldErrors };
    }
    get formErrors() {
        return this.flatten();
    }
}
exports.ZodError = ZodError;
ZodError.create = (issues) => {
    const error = new ZodError(issues);
    return error;
};


/***/ }),

/***/ 6996:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getErrorMap = exports.setErrorMap = exports.defaultErrorMap = void 0;
const en_1 = __importDefault(__webpack_require__(9349));
exports.defaultErrorMap = en_1.default;
let overrideErrorMap = en_1.default;
function setErrorMap(map) {
    overrideErrorMap = map;
}
exports.setErrorMap = setErrorMap;
function getErrorMap() {
    return overrideErrorMap;
}
exports.getErrorMap = getErrorMap;


/***/ }),

/***/ 6349:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(6996), exports);
__exportStar(__webpack_require__(3187), exports);
__exportStar(__webpack_require__(116), exports);
__exportStar(__webpack_require__(9110), exports);
__exportStar(__webpack_require__(5433), exports);
__exportStar(__webpack_require__(8280), exports);


/***/ }),

/***/ 8762:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.errorUtil = void 0;
var errorUtil;
(function (errorUtil) {
    errorUtil.errToObj = (message) => typeof message === "string" ? { message } : message || {};
    errorUtil.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
})(errorUtil = exports.errorUtil || (exports.errorUtil = {}));


/***/ }),

/***/ 3187:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isAsync = exports.isValid = exports.isDirty = exports.isAborted = exports.OK = exports.DIRTY = exports.INVALID = exports.ParseStatus = exports.addIssueToContext = exports.EMPTY_PATH = exports.makeIssue = void 0;
const errors_1 = __webpack_require__(6996);
const en_1 = __importDefault(__webpack_require__(9349));
const makeIssue = (params) => {
    const { data, path, errorMaps, issueData } = params;
    const fullPath = [...path, ...(issueData.path || [])];
    const fullIssue = {
        ...issueData,
        path: fullPath,
    };
    let errorMessage = "";
    const maps = errorMaps
        .filter((m) => !!m)
        .slice()
        .reverse();
    for (const map of maps) {
        errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
    }
    return {
        ...issueData,
        path: fullPath,
        message: issueData.message || errorMessage,
    };
};
exports.makeIssue = makeIssue;
exports.EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
    const issue = (0, exports.makeIssue)({
        issueData: issueData,
        data: ctx.data,
        path: ctx.path,
        errorMaps: [
            ctx.common.contextualErrorMap,
            ctx.schemaErrorMap,
            (0, errors_1.getErrorMap)(),
            en_1.default, // then global default map
        ].filter((x) => !!x),
    });
    ctx.common.issues.push(issue);
}
exports.addIssueToContext = addIssueToContext;
class ParseStatus {
    constructor() {
        this.value = "valid";
    }
    dirty() {
        if (this.value === "valid")
            this.value = "dirty";
    }
    abort() {
        if (this.value !== "aborted")
            this.value = "aborted";
    }
    static mergeArray(status, results) {
        const arrayValue = [];
        for (const s of results) {
            if (s.status === "aborted")
                return exports.INVALID;
            if (s.status === "dirty")
                status.dirty();
            arrayValue.push(s.value);
        }
        return { status: status.value, value: arrayValue };
    }
    static async mergeObjectAsync(status, pairs) {
        const syncPairs = [];
        for (const pair of pairs) {
            syncPairs.push({
                key: await pair.key,
                value: await pair.value,
            });
        }
        return ParseStatus.mergeObjectSync(status, syncPairs);
    }
    static mergeObjectSync(status, pairs) {
        const finalObject = {};
        for (const pair of pairs) {
            const { key, value } = pair;
            if (key.status === "aborted")
                return exports.INVALID;
            if (value.status === "aborted")
                return exports.INVALID;
            if (key.status === "dirty")
                status.dirty();
            if (value.status === "dirty")
                status.dirty();
            if (key.value !== "__proto__" &&
                (typeof value.value !== "undefined" || pair.alwaysSet)) {
                finalObject[key.value] = value.value;
            }
        }
        return { status: status.value, value: finalObject };
    }
}
exports.ParseStatus = ParseStatus;
exports.INVALID = Object.freeze({
    status: "aborted",
});
const DIRTY = (value) => ({ status: "dirty", value });
exports.DIRTY = DIRTY;
const OK = (value) => ({ status: "valid", value });
exports.OK = OK;
const isAborted = (x) => x.status === "aborted";
exports.isAborted = isAborted;
const isDirty = (x) => x.status === "dirty";
exports.isDirty = isDirty;
const isValid = (x) => x.status === "valid";
exports.isValid = isValid;
const isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;
exports.isAsync = isAsync;


/***/ }),

/***/ 116:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 9110:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getParsedType = exports.ZodParsedType = exports.objectUtil = exports.util = void 0;
var util;
(function (util) {
    util.assertEqual = (val) => val;
    function assertIs(_arg) { }
    util.assertIs = assertIs;
    function assertNever(_x) {
        throw new Error();
    }
    util.assertNever = assertNever;
    util.arrayToEnum = (items) => {
        const obj = {};
        for (const item of items) {
            obj[item] = item;
        }
        return obj;
    };
    util.getValidEnumValues = (obj) => {
        const validKeys = util.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
        const filtered = {};
        for (const k of validKeys) {
            filtered[k] = obj[k];
        }
        return util.objectValues(filtered);
    };
    util.objectValues = (obj) => {
        return util.objectKeys(obj).map(function (e) {
            return obj[e];
        });
    };
    util.objectKeys = typeof Object.keys === "function" // eslint-disable-line ban/ban
        ? (obj) => Object.keys(obj) // eslint-disable-line ban/ban
        : (object) => {
            const keys = [];
            for (const key in object) {
                if (Object.prototype.hasOwnProperty.call(object, key)) {
                    keys.push(key);
                }
            }
            return keys;
        };
    util.find = (arr, checker) => {
        for (const item of arr) {
            if (checker(item))
                return item;
        }
        return undefined;
    };
    util.isInteger = typeof Number.isInteger === "function"
        ? (val) => Number.isInteger(val) // eslint-disable-line ban/ban
        : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
    function joinValues(array, separator = " | ") {
        return array
            .map((val) => (typeof val === "string" ? `'${val}'` : val))
            .join(separator);
    }
    util.joinValues = joinValues;
    util.jsonStringifyReplacer = (_, value) => {
        if (typeof value === "bigint") {
            return value.toString();
        }
        return value;
    };
})(util = exports.util || (exports.util = {}));
var objectUtil;
(function (objectUtil) {
    objectUtil.mergeShapes = (first, second) => {
        return {
            ...first,
            ...second, // second overwrites first
        };
    };
})(objectUtil = exports.objectUtil || (exports.objectUtil = {}));
exports.ZodParsedType = util.arrayToEnum([
    "string",
    "nan",
    "number",
    "integer",
    "float",
    "boolean",
    "date",
    "bigint",
    "symbol",
    "function",
    "undefined",
    "null",
    "array",
    "object",
    "unknown",
    "promise",
    "void",
    "never",
    "map",
    "set",
]);
const getParsedType = (data) => {
    const t = typeof data;
    switch (t) {
        case "undefined":
            return exports.ZodParsedType.undefined;
        case "string":
            return exports.ZodParsedType.string;
        case "number":
            return isNaN(data) ? exports.ZodParsedType.nan : exports.ZodParsedType.number;
        case "boolean":
            return exports.ZodParsedType.boolean;
        case "function":
            return exports.ZodParsedType.function;
        case "bigint":
            return exports.ZodParsedType.bigint;
        case "symbol":
            return exports.ZodParsedType.symbol;
        case "object":
            if (Array.isArray(data)) {
                return exports.ZodParsedType.array;
            }
            if (data === null) {
                return exports.ZodParsedType.null;
            }
            if (data.then &&
                typeof data.then === "function" &&
                data.catch &&
                typeof data.catch === "function") {
                return exports.ZodParsedType.promise;
            }
            if (typeof Map !== "undefined" && data instanceof Map) {
                return exports.ZodParsedType.map;
            }
            if (typeof Set !== "undefined" && data instanceof Set) {
                return exports.ZodParsedType.set;
            }
            if (typeof Date !== "undefined" && data instanceof Date) {
                return exports.ZodParsedType.date;
            }
            return exports.ZodParsedType.object;
        default:
            return exports.ZodParsedType.unknown;
    }
};
exports.getParsedType = getParsedType;


/***/ }),

/***/ 8754:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.z = void 0;
const z = __importStar(__webpack_require__(6349));
exports.z = z;
__exportStar(__webpack_require__(6349), exports);
exports["default"] = z;


/***/ }),

/***/ 9349:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
const util_1 = __webpack_require__(9110);
const ZodError_1 = __webpack_require__(8280);
const errorMap = (issue, _ctx) => {
    let message;
    switch (issue.code) {
        case ZodError_1.ZodIssueCode.invalid_type:
            if (issue.received === util_1.ZodParsedType.undefined) {
                message = "Required";
            }
            else {
                message = `Expected ${issue.expected}, received ${issue.received}`;
            }
            break;
        case ZodError_1.ZodIssueCode.invalid_literal:
            message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util_1.util.jsonStringifyReplacer)}`;
            break;
        case ZodError_1.ZodIssueCode.unrecognized_keys:
            message = `Unrecognized key(s) in object: ${util_1.util.joinValues(issue.keys, ", ")}`;
            break;
        case ZodError_1.ZodIssueCode.invalid_union:
            message = `Invalid input`;
            break;
        case ZodError_1.ZodIssueCode.invalid_union_discriminator:
            message = `Invalid discriminator value. Expected ${util_1.util.joinValues(issue.options)}`;
            break;
        case ZodError_1.ZodIssueCode.invalid_enum_value:
            message = `Invalid enum value. Expected ${util_1.util.joinValues(issue.options)}, received '${issue.received}'`;
            break;
        case ZodError_1.ZodIssueCode.invalid_arguments:
            message = `Invalid function arguments`;
            break;
        case ZodError_1.ZodIssueCode.invalid_return_type:
            message = `Invalid function return type`;
            break;
        case ZodError_1.ZodIssueCode.invalid_date:
            message = `Invalid date`;
            break;
        case ZodError_1.ZodIssueCode.invalid_string:
            if (typeof issue.validation === "object") {
                if ("includes" in issue.validation) {
                    message = `Invalid input: must include "${issue.validation.includes}"`;
                    if (typeof issue.validation.position === "number") {
                        message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
                    }
                }
                else if ("startsWith" in issue.validation) {
                    message = `Invalid input: must start with "${issue.validation.startsWith}"`;
                }
                else if ("endsWith" in issue.validation) {
                    message = `Invalid input: must end with "${issue.validation.endsWith}"`;
                }
                else {
                    util_1.util.assertNever(issue.validation);
                }
            }
            else if (issue.validation !== "regex") {
                message = `Invalid ${issue.validation}`;
            }
            else {
                message = "Invalid";
            }
            break;
        case ZodError_1.ZodIssueCode.too_small:
            if (issue.type === "array")
                message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
            else if (issue.type === "string")
                message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
            else if (issue.type === "number")
                message = `Number must be ${issue.exact
                    ? `exactly equal to `
                    : issue.inclusive
                        ? `greater than or equal to `
                        : `greater than `}${issue.minimum}`;
            else if (issue.type === "date")
                message = `Date must be ${issue.exact
                    ? `exactly equal to `
                    : issue.inclusive
                        ? `greater than or equal to `
                        : `greater than `}${new Date(Number(issue.minimum))}`;
            else
                message = "Invalid input";
            break;
        case ZodError_1.ZodIssueCode.too_big:
            if (issue.type === "array")
                message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
            else if (issue.type === "string")
                message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
            else if (issue.type === "number")
                message = `Number must be ${issue.exact
                    ? `exactly`
                    : issue.inclusive
                        ? `less than or equal to`
                        : `less than`} ${issue.maximum}`;
            else if (issue.type === "bigint")
                message = `BigInt must be ${issue.exact
                    ? `exactly`
                    : issue.inclusive
                        ? `less than or equal to`
                        : `less than`} ${issue.maximum}`;
            else if (issue.type === "date")
                message = `Date must be ${issue.exact
                    ? `exactly`
                    : issue.inclusive
                        ? `smaller than or equal to`
                        : `smaller than`} ${new Date(Number(issue.maximum))}`;
            else
                message = "Invalid input";
            break;
        case ZodError_1.ZodIssueCode.custom:
            message = `Invalid input`;
            break;
        case ZodError_1.ZodIssueCode.invalid_intersection_types:
            message = `Intersection results could not be merged`;
            break;
        case ZodError_1.ZodIssueCode.not_multiple_of:
            message = `Number must be a multiple of ${issue.multipleOf}`;
            break;
        case ZodError_1.ZodIssueCode.not_finite:
            message = "Number must be finite";
            break;
        default:
            message = _ctx.defaultError;
            util_1.util.assertNever(issue);
    }
    return { message };
};
exports["default"] = errorMap;


/***/ }),

/***/ 5433:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.date = exports.boolean = exports.bigint = exports.array = exports.any = exports.coerce = exports.ZodFirstPartyTypeKind = exports.late = exports.ZodSchema = exports.Schema = exports.custom = exports.ZodReadonly = exports.ZodPipeline = exports.ZodBranded = exports.BRAND = exports.ZodNaN = exports.ZodCatch = exports.ZodDefault = exports.ZodNullable = exports.ZodOptional = exports.ZodTransformer = exports.ZodEffects = exports.ZodPromise = exports.ZodNativeEnum = exports.ZodEnum = exports.ZodLiteral = exports.ZodLazy = exports.ZodFunction = exports.ZodSet = exports.ZodMap = exports.ZodRecord = exports.ZodTuple = exports.ZodIntersection = exports.ZodDiscriminatedUnion = exports.ZodUnion = exports.ZodObject = exports.ZodArray = exports.ZodVoid = exports.ZodNever = exports.ZodUnknown = exports.ZodAny = exports.ZodNull = exports.ZodUndefined = exports.ZodSymbol = exports.ZodDate = exports.ZodBoolean = exports.ZodBigInt = exports.ZodNumber = exports.ZodString = exports.ZodType = void 0;
exports.NEVER = exports["void"] = exports.unknown = exports.union = exports.undefined = exports.tuple = exports.transformer = exports.symbol = exports.string = exports.strictObject = exports.set = exports.record = exports.promise = exports.preprocess = exports.pipeline = exports.ostring = exports.optional = exports.onumber = exports.oboolean = exports.object = exports.number = exports.nullable = exports["null"] = exports.never = exports.nativeEnum = exports.nan = exports.map = exports.literal = exports.lazy = exports.intersection = exports["instanceof"] = exports["function"] = exports["enum"] = exports.effect = exports.discriminatedUnion = void 0;
const errors_1 = __webpack_require__(6996);
const errorUtil_1 = __webpack_require__(8762);
const parseUtil_1 = __webpack_require__(3187);
const util_1 = __webpack_require__(9110);
const ZodError_1 = __webpack_require__(8280);
class ParseInputLazyPath {
    constructor(parent, value, path, key) {
        this._cachedPath = [];
        this.parent = parent;
        this.data = value;
        this._path = path;
        this._key = key;
    }
    get path() {
        if (!this._cachedPath.length) {
            if (this._key instanceof Array) {
                this._cachedPath.push(...this._path, ...this._key);
            }
            else {
                this._cachedPath.push(...this._path, this._key);
            }
        }
        return this._cachedPath;
    }
}
const handleResult = (ctx, result) => {
    if ((0, parseUtil_1.isValid)(result)) {
        return { success: true, data: result.value };
    }
    else {
        if (!ctx.common.issues.length) {
            throw new Error("Validation failed but no issues detected.");
        }
        return {
            success: false,
            get error() {
                if (this._error)
                    return this._error;
                const error = new ZodError_1.ZodError(ctx.common.issues);
                this._error = error;
                return this._error;
            },
        };
    }
};
function processCreateParams(params) {
    if (!params)
        return {};
    const { errorMap, invalid_type_error, required_error, description } = params;
    if (errorMap && (invalid_type_error || required_error)) {
        throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
    }
    if (errorMap)
        return { errorMap: errorMap, description };
    const customMap = (iss, ctx) => {
        if (iss.code !== "invalid_type")
            return { message: ctx.defaultError };
        if (typeof ctx.data === "undefined") {
            return { message: required_error !== null && required_error !== void 0 ? required_error : ctx.defaultError };
        }
        return { message: invalid_type_error !== null && invalid_type_error !== void 0 ? invalid_type_error : ctx.defaultError };
    };
    return { errorMap: customMap, description };
}
class ZodType {
    constructor(def) {
        /** Alias of safeParseAsync */
        this.spa = this.safeParseAsync;
        this._def = def;
        this.parse = this.parse.bind(this);
        this.safeParse = this.safeParse.bind(this);
        this.parseAsync = this.parseAsync.bind(this);
        this.safeParseAsync = this.safeParseAsync.bind(this);
        this.spa = this.spa.bind(this);
        this.refine = this.refine.bind(this);
        this.refinement = this.refinement.bind(this);
        this.superRefine = this.superRefine.bind(this);
        this.optional = this.optional.bind(this);
        this.nullable = this.nullable.bind(this);
        this.nullish = this.nullish.bind(this);
        this.array = this.array.bind(this);
        this.promise = this.promise.bind(this);
        this.or = this.or.bind(this);
        this.and = this.and.bind(this);
        this.transform = this.transform.bind(this);
        this.brand = this.brand.bind(this);
        this.default = this.default.bind(this);
        this.catch = this.catch.bind(this);
        this.describe = this.describe.bind(this);
        this.pipe = this.pipe.bind(this);
        this.readonly = this.readonly.bind(this);
        this.isNullable = this.isNullable.bind(this);
        this.isOptional = this.isOptional.bind(this);
    }
    get description() {
        return this._def.description;
    }
    _getType(input) {
        return (0, util_1.getParsedType)(input.data);
    }
    _getOrReturnCtx(input, ctx) {
        return (ctx || {
            common: input.parent.common,
            data: input.data,
            parsedType: (0, util_1.getParsedType)(input.data),
            schemaErrorMap: this._def.errorMap,
            path: input.path,
            parent: input.parent,
        });
    }
    _processInputParams(input) {
        return {
            status: new parseUtil_1.ParseStatus(),
            ctx: {
                common: input.parent.common,
                data: input.data,
                parsedType: (0, util_1.getParsedType)(input.data),
                schemaErrorMap: this._def.errorMap,
                path: input.path,
                parent: input.parent,
            },
        };
    }
    _parseSync(input) {
        const result = this._parse(input);
        if ((0, parseUtil_1.isAsync)(result)) {
            throw new Error("Synchronous parse encountered promise.");
        }
        return result;
    }
    _parseAsync(input) {
        const result = this._parse(input);
        return Promise.resolve(result);
    }
    parse(data, params) {
        const result = this.safeParse(data, params);
        if (result.success)
            return result.data;
        throw result.error;
    }
    safeParse(data, params) {
        var _a;
        const ctx = {
            common: {
                issues: [],
                async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,
                contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
            },
            path: (params === null || params === void 0 ? void 0 : params.path) || [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data,
            parsedType: (0, util_1.getParsedType)(data),
        };
        const result = this._parseSync({ data, path: ctx.path, parent: ctx });
        return handleResult(ctx, result);
    }
    async parseAsync(data, params) {
        const result = await this.safeParseAsync(data, params);
        if (result.success)
            return result.data;
        throw result.error;
    }
    async safeParseAsync(data, params) {
        const ctx = {
            common: {
                issues: [],
                contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
                async: true,
            },
            path: (params === null || params === void 0 ? void 0 : params.path) || [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data,
            parsedType: (0, util_1.getParsedType)(data),
        };
        const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
        const result = await ((0, parseUtil_1.isAsync)(maybeAsyncResult)
            ? maybeAsyncResult
            : Promise.resolve(maybeAsyncResult));
        return handleResult(ctx, result);
    }
    refine(check, message) {
        const getIssueProperties = (val) => {
            if (typeof message === "string" || typeof message === "undefined") {
                return { message };
            }
            else if (typeof message === "function") {
                return message(val);
            }
            else {
                return message;
            }
        };
        return this._refinement((val, ctx) => {
            const result = check(val);
            const setError = () => ctx.addIssue({
                code: ZodError_1.ZodIssueCode.custom,
                ...getIssueProperties(val),
            });
            if (typeof Promise !== "undefined" && result instanceof Promise) {
                return result.then((data) => {
                    if (!data) {
                        setError();
                        return false;
                    }
                    else {
                        return true;
                    }
                });
            }
            if (!result) {
                setError();
                return false;
            }
            else {
                return true;
            }
        });
    }
    refinement(check, refinementData) {
        return this._refinement((val, ctx) => {
            if (!check(val)) {
                ctx.addIssue(typeof refinementData === "function"
                    ? refinementData(val, ctx)
                    : refinementData);
                return false;
            }
            else {
                return true;
            }
        });
    }
    _refinement(refinement) {
        return new ZodEffects({
            schema: this,
            typeName: ZodFirstPartyTypeKind.ZodEffects,
            effect: { type: "refinement", refinement },
        });
    }
    superRefine(refinement) {
        return this._refinement(refinement);
    }
    optional() {
        return ZodOptional.create(this, this._def);
    }
    nullable() {
        return ZodNullable.create(this, this._def);
    }
    nullish() {
        return this.nullable().optional();
    }
    array() {
        return ZodArray.create(this, this._def);
    }
    promise() {
        return ZodPromise.create(this, this._def);
    }
    or(option) {
        return ZodUnion.create([this, option], this._def);
    }
    and(incoming) {
        return ZodIntersection.create(this, incoming, this._def);
    }
    transform(transform) {
        return new ZodEffects({
            ...processCreateParams(this._def),
            schema: this,
            typeName: ZodFirstPartyTypeKind.ZodEffects,
            effect: { type: "transform", transform },
        });
    }
    default(def) {
        const defaultValueFunc = typeof def === "function" ? def : () => def;
        return new ZodDefault({
            ...processCreateParams(this._def),
            innerType: this,
            defaultValue: defaultValueFunc,
            typeName: ZodFirstPartyTypeKind.ZodDefault,
        });
    }
    brand() {
        return new ZodBranded({
            typeName: ZodFirstPartyTypeKind.ZodBranded,
            type: this,
            ...processCreateParams(this._def),
        });
    }
    catch(def) {
        const catchValueFunc = typeof def === "function" ? def : () => def;
        return new ZodCatch({
            ...processCreateParams(this._def),
            innerType: this,
            catchValue: catchValueFunc,
            typeName: ZodFirstPartyTypeKind.ZodCatch,
        });
    }
    describe(description) {
        const This = this.constructor;
        return new This({
            ...this._def,
            description,
        });
    }
    pipe(target) {
        return ZodPipeline.create(this, target);
    }
    readonly() {
        return ZodReadonly.create(this);
    }
    isOptional() {
        return this.safeParse(undefined).success;
    }
    isNullable() {
        return this.safeParse(null).success;
    }
}
exports.ZodType = ZodType;
exports.Schema = ZodType;
exports.ZodSchema = ZodType;
const cuidRegex = /^c[^\s-]{8,}$/i;
const cuid2Regex = /^[a-z][a-z0-9]*$/;
const ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/;
// const uuidRegex =
//   /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
const uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
// from https://stackoverflow.com/a/46181/1550155
// old version: too slow, didn't support unicode
// const emailRegex = /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))$/i;
//old email regex
// const emailRegex = /^(([^<>()[\].,;:\s@"]+(\.[^<>()[\].,;:\s@"]+)*)|(".+"))@((?!-)([^<>()[\].,;:\s@"]+\.)+[^<>()[\].,;:\s@"]{1,})[^-<>()[\].,;:\s@"]$/i;
// eslint-disable-next-line
// const emailRegex =
//   /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\])|(\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\.[A-Za-z]{2,})+))$/;
// const emailRegex =
//   /^[a-zA-Z0-9\.\!\#\$\%\&\'\*\+\/\=\?\^\_\`\{\|\}\~\-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
// const emailRegex =
//   /^(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|"(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])*")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])$/i;
const emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_+-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
// const emailRegex =
//   /^[a-z0-9.!#$%&*+/=?^_`{|}~-]+@[a-z0-9-]+(?:\.[a-z0-9\-]+)*$/i;
// from https://thekevinscott.com/emojis-in-javascript/#writing-a-regular-expression
const _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
let emojiRegex;
const ipv4Regex = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/;
const ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
// Adapted from https://stackoverflow.com/a/3143231
const datetimeRegex = (args) => {
    if (args.precision) {
        if (args.offset) {
            return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
        }
        else {
            return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}Z$`);
        }
    }
    else if (args.precision === 0) {
        if (args.offset) {
            return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
        }
        else {
            return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$`);
        }
    }
    else {
        if (args.offset) {
            return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
        }
        else {
            return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$`);
        }
    }
};
function isValidIP(ip, version) {
    if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
        return true;
    }
    if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
        return true;
    }
    return false;
}
class ZodString extends ZodType {
    _parse(input) {
        if (this._def.coerce) {
            input.data = String(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.string) {
            const ctx = this._getOrReturnCtx(input);
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1.ZodParsedType.string,
                received: ctx.parsedType,
            }
            //
            );
            return parseUtil_1.INVALID;
        }
        const status = new parseUtil_1.ParseStatus();
        let ctx = undefined;
        for (const check of this._def.checks) {
            if (check.kind === "min") {
                if (input.data.length < check.value) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        code: ZodError_1.ZodIssueCode.too_small,
                        minimum: check.value,
                        type: "string",
                        inclusive: true,
                        exact: false,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "max") {
                if (input.data.length > check.value) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        code: ZodError_1.ZodIssueCode.too_big,
                        maximum: check.value,
                        type: "string",
                        inclusive: true,
                        exact: false,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "length") {
                const tooBig = input.data.length > check.value;
                const tooSmall = input.data.length < check.value;
                if (tooBig || tooSmall) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    if (tooBig) {
                        (0, parseUtil_1.addIssueToContext)(ctx, {
                            code: ZodError_1.ZodIssueCode.too_big,
                            maximum: check.value,
                            type: "string",
                            inclusive: true,
                            exact: true,
                            message: check.message,
                        });
                    }
                    else if (tooSmall) {
                        (0, parseUtil_1.addIssueToContext)(ctx, {
                            code: ZodError_1.ZodIssueCode.too_small,
                            minimum: check.value,
                            type: "string",
                            inclusive: true,
                            exact: true,
                            message: check.message,
                        });
                    }
                    status.dirty();
                }
            }
            else if (check.kind === "email") {
                if (!emailRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        validation: "email",
                        code: ZodError_1.ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "emoji") {
                if (!emojiRegex) {
                    emojiRegex = new RegExp(_emojiRegex, "u");
                }
                if (!emojiRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        validation: "emoji",
                        code: ZodError_1.ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "uuid") {
                if (!uuidRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        validation: "uuid",
                        code: ZodError_1.ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "cuid") {
                if (!cuidRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        validation: "cuid",
                        code: ZodError_1.ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "cuid2") {
                if (!cuid2Regex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        validation: "cuid2",
                        code: ZodError_1.ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "ulid") {
                if (!ulidRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        validation: "ulid",
                        code: ZodError_1.ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "url") {
                try {
                    new URL(input.data);
                }
                catch (_a) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        validation: "url",
                        code: ZodError_1.ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "regex") {
                check.regex.lastIndex = 0;
                const testResult = check.regex.test(input.data);
                if (!testResult) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        validation: "regex",
                        code: ZodError_1.ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "trim") {
                input.data = input.data.trim();
            }
            else if (check.kind === "includes") {
                if (!input.data.includes(check.value, check.position)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        code: ZodError_1.ZodIssueCode.invalid_string,
                        validation: { includes: check.value, position: check.position },
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "toLowerCase") {
                input.data = input.data.toLowerCase();
            }
            else if (check.kind === "toUpperCase") {
                input.data = input.data.toUpperCase();
            }
            else if (check.kind === "startsWith") {
                if (!input.data.startsWith(check.value)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        code: ZodError_1.ZodIssueCode.invalid_string,
                        validation: { startsWith: check.value },
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "endsWith") {
                if (!input.data.endsWith(check.value)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        code: ZodError_1.ZodIssueCode.invalid_string,
                        validation: { endsWith: check.value },
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "datetime") {
                const regex = datetimeRegex(check);
                if (!regex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        code: ZodError_1.ZodIssueCode.invalid_string,
                        validation: "datetime",
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "ip") {
                if (!isValidIP(input.data, check.version)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        validation: "ip",
                        code: ZodError_1.ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else {
                util_1.util.assertNever(check);
            }
        }
        return { status: status.value, value: input.data };
    }
    _regex(regex, validation, message) {
        return this.refinement((data) => regex.test(data), {
            validation,
            code: ZodError_1.ZodIssueCode.invalid_string,
            ...errorUtil_1.errorUtil.errToObj(message),
        });
    }
    _addCheck(check) {
        return new ZodString({
            ...this._def,
            checks: [...this._def.checks, check],
        });
    }
    email(message) {
        return this._addCheck({ kind: "email", ...errorUtil_1.errorUtil.errToObj(message) });
    }
    url(message) {
        return this._addCheck({ kind: "url", ...errorUtil_1.errorUtil.errToObj(message) });
    }
    emoji(message) {
        return this._addCheck({ kind: "emoji", ...errorUtil_1.errorUtil.errToObj(message) });
    }
    uuid(message) {
        return this._addCheck({ kind: "uuid", ...errorUtil_1.errorUtil.errToObj(message) });
    }
    cuid(message) {
        return this._addCheck({ kind: "cuid", ...errorUtil_1.errorUtil.errToObj(message) });
    }
    cuid2(message) {
        return this._addCheck({ kind: "cuid2", ...errorUtil_1.errorUtil.errToObj(message) });
    }
    ulid(message) {
        return this._addCheck({ kind: "ulid", ...errorUtil_1.errorUtil.errToObj(message) });
    }
    ip(options) {
        return this._addCheck({ kind: "ip", ...errorUtil_1.errorUtil.errToObj(options) });
    }
    datetime(options) {
        var _a;
        if (typeof options === "string") {
            return this._addCheck({
                kind: "datetime",
                precision: null,
                offset: false,
                message: options,
            });
        }
        return this._addCheck({
            kind: "datetime",
            precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
            offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false,
            ...errorUtil_1.errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message),
        });
    }
    regex(regex, message) {
        return this._addCheck({
            kind: "regex",
            regex: regex,
            ...errorUtil_1.errorUtil.errToObj(message),
        });
    }
    includes(value, options) {
        return this._addCheck({
            kind: "includes",
            value: value,
            position: options === null || options === void 0 ? void 0 : options.position,
            ...errorUtil_1.errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message),
        });
    }
    startsWith(value, message) {
        return this._addCheck({
            kind: "startsWith",
            value: value,
            ...errorUtil_1.errorUtil.errToObj(message),
        });
    }
    endsWith(value, message) {
        return this._addCheck({
            kind: "endsWith",
            value: value,
            ...errorUtil_1.errorUtil.errToObj(message),
        });
    }
    min(minLength, message) {
        return this._addCheck({
            kind: "min",
            value: minLength,
            ...errorUtil_1.errorUtil.errToObj(message),
        });
    }
    max(maxLength, message) {
        return this._addCheck({
            kind: "max",
            value: maxLength,
            ...errorUtil_1.errorUtil.errToObj(message),
        });
    }
    length(len, message) {
        return this._addCheck({
            kind: "length",
            value: len,
            ...errorUtil_1.errorUtil.errToObj(message),
        });
    }
    /**
     * @deprecated Use z.string().min(1) instead.
     * @see {@link ZodString.min}
     */
    nonempty(message) {
        return this.min(1, errorUtil_1.errorUtil.errToObj(message));
    }
    trim() {
        return new ZodString({
            ...this._def,
            checks: [...this._def.checks, { kind: "trim" }],
        });
    }
    toLowerCase() {
        return new ZodString({
            ...this._def,
            checks: [...this._def.checks, { kind: "toLowerCase" }],
        });
    }
    toUpperCase() {
        return new ZodString({
            ...this._def,
            checks: [...this._def.checks, { kind: "toUpperCase" }],
        });
    }
    get isDatetime() {
        return !!this._def.checks.find((ch) => ch.kind === "datetime");
    }
    get isEmail() {
        return !!this._def.checks.find((ch) => ch.kind === "email");
    }
    get isURL() {
        return !!this._def.checks.find((ch) => ch.kind === "url");
    }
    get isEmoji() {
        return !!this._def.checks.find((ch) => ch.kind === "emoji");
    }
    get isUUID() {
        return !!this._def.checks.find((ch) => ch.kind === "uuid");
    }
    get isCUID() {
        return !!this._def.checks.find((ch) => ch.kind === "cuid");
    }
    get isCUID2() {
        return !!this._def.checks.find((ch) => ch.kind === "cuid2");
    }
    get isULID() {
        return !!this._def.checks.find((ch) => ch.kind === "ulid");
    }
    get isIP() {
        return !!this._def.checks.find((ch) => ch.kind === "ip");
    }
    get minLength() {
        let min = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "min") {
                if (min === null || ch.value > min)
                    min = ch.value;
            }
        }
        return min;
    }
    get maxLength() {
        let max = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "max") {
                if (max === null || ch.value < max)
                    max = ch.value;
            }
        }
        return max;
    }
}
exports.ZodString = ZodString;
ZodString.create = (params) => {
    var _a;
    return new ZodString({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodString,
        coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
        ...processCreateParams(params),
    });
};
// https://stackoverflow.com/questions/3966484/why-does-modulus-operator-return-fractional-number-in-javascript/31711034#31711034
function floatSafeRemainder(val, step) {
    const valDecCount = (val.toString().split(".")[1] || "").length;
    const stepDecCount = (step.toString().split(".")[1] || "").length;
    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
    const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
    const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
    return (valInt % stepInt) / Math.pow(10, decCount);
}
class ZodNumber extends ZodType {
    constructor() {
        super(...arguments);
        this.min = this.gte;
        this.max = this.lte;
        this.step = this.multipleOf;
    }
    _parse(input) {
        if (this._def.coerce) {
            input.data = Number(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.number) {
            const ctx = this._getOrReturnCtx(input);
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1.ZodParsedType.number,
                received: ctx.parsedType,
            });
            return parseUtil_1.INVALID;
        }
        let ctx = undefined;
        const status = new parseUtil_1.ParseStatus();
        for (const check of this._def.checks) {
            if (check.kind === "int") {
                if (!util_1.util.isInteger(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        code: ZodError_1.ZodIssueCode.invalid_type,
                        expected: "integer",
                        received: "float",
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "min") {
                const tooSmall = check.inclusive
                    ? input.data < check.value
                    : input.data <= check.value;
                if (tooSmall) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        code: ZodError_1.ZodIssueCode.too_small,
                        minimum: check.value,
                        type: "number",
                        inclusive: check.inclusive,
                        exact: false,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "max") {
                const tooBig = check.inclusive
                    ? input.data > check.value
                    : input.data >= check.value;
                if (tooBig) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        code: ZodError_1.ZodIssueCode.too_big,
                        maximum: check.value,
                        type: "number",
                        inclusive: check.inclusive,
                        exact: false,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "multipleOf") {
                if (floatSafeRemainder(input.data, check.value) !== 0) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        code: ZodError_1.ZodIssueCode.not_multiple_of,
                        multipleOf: check.value,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "finite") {
                if (!Number.isFinite(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        code: ZodError_1.ZodIssueCode.not_finite,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else {
                util_1.util.assertNever(check);
            }
        }
        return { status: status.value, value: input.data };
    }
    gte(value, message) {
        return this.setLimit("min", value, true, errorUtil_1.errorUtil.toString(message));
    }
    gt(value, message) {
        return this.setLimit("min", value, false, errorUtil_1.errorUtil.toString(message));
    }
    lte(value, message) {
        return this.setLimit("max", value, true, errorUtil_1.errorUtil.toString(message));
    }
    lt(value, message) {
        return this.setLimit("max", value, false, errorUtil_1.errorUtil.toString(message));
    }
    setLimit(kind, value, inclusive, message) {
        return new ZodNumber({
            ...this._def,
            checks: [
                ...this._def.checks,
                {
                    kind,
                    value,
                    inclusive,
                    message: errorUtil_1.errorUtil.toString(message),
                },
            ],
        });
    }
    _addCheck(check) {
        return new ZodNumber({
            ...this._def,
            checks: [...this._def.checks, check],
        });
    }
    int(message) {
        return this._addCheck({
            kind: "int",
            message: errorUtil_1.errorUtil.toString(message),
        });
    }
    positive(message) {
        return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: false,
            message: errorUtil_1.errorUtil.toString(message),
        });
    }
    negative(message) {
        return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: false,
            message: errorUtil_1.errorUtil.toString(message),
        });
    }
    nonpositive(message) {
        return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: true,
            message: errorUtil_1.errorUtil.toString(message),
        });
    }
    nonnegative(message) {
        return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: true,
            message: errorUtil_1.errorUtil.toString(message),
        });
    }
    multipleOf(value, message) {
        return this._addCheck({
            kind: "multipleOf",
            value: value,
            message: errorUtil_1.errorUtil.toString(message),
        });
    }
    finite(message) {
        return this._addCheck({
            kind: "finite",
            message: errorUtil_1.errorUtil.toString(message),
        });
    }
    safe(message) {
        return this._addCheck({
            kind: "min",
            inclusive: true,
            value: Number.MIN_SAFE_INTEGER,
            message: errorUtil_1.errorUtil.toString(message),
        })._addCheck({
            kind: "max",
            inclusive: true,
            value: Number.MAX_SAFE_INTEGER,
            message: errorUtil_1.errorUtil.toString(message),
        });
    }
    get minValue() {
        let min = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "min") {
                if (min === null || ch.value > min)
                    min = ch.value;
            }
        }
        return min;
    }
    get maxValue() {
        let max = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "max") {
                if (max === null || ch.value < max)
                    max = ch.value;
            }
        }
        return max;
    }
    get isInt() {
        return !!this._def.checks.find((ch) => ch.kind === "int" ||
            (ch.kind === "multipleOf" && util_1.util.isInteger(ch.value)));
    }
    get isFinite() {
        let max = null, min = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "finite" ||
                ch.kind === "int" ||
                ch.kind === "multipleOf") {
                return true;
            }
            else if (ch.kind === "min") {
                if (min === null || ch.value > min)
                    min = ch.value;
            }
            else if (ch.kind === "max") {
                if (max === null || ch.value < max)
                    max = ch.value;
            }
        }
        return Number.isFinite(min) && Number.isFinite(max);
    }
}
exports.ZodNumber = ZodNumber;
ZodNumber.create = (params) => {
    return new ZodNumber({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodNumber,
        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
        ...processCreateParams(params),
    });
};
class ZodBigInt extends ZodType {
    constructor() {
        super(...arguments);
        this.min = this.gte;
        this.max = this.lte;
    }
    _parse(input) {
        if (this._def.coerce) {
            input.data = BigInt(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.bigint) {
            const ctx = this._getOrReturnCtx(input);
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1.ZodParsedType.bigint,
                received: ctx.parsedType,
            });
            return parseUtil_1.INVALID;
        }
        let ctx = undefined;
        const status = new parseUtil_1.ParseStatus();
        for (const check of this._def.checks) {
            if (check.kind === "min") {
                const tooSmall = check.inclusive
                    ? input.data < check.value
                    : input.data <= check.value;
                if (tooSmall) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        code: ZodError_1.ZodIssueCode.too_small,
                        type: "bigint",
                        minimum: check.value,
                        inclusive: check.inclusive,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "max") {
                const tooBig = check.inclusive
                    ? input.data > check.value
                    : input.data >= check.value;
                if (tooBig) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        code: ZodError_1.ZodIssueCode.too_big,
                        type: "bigint",
                        maximum: check.value,
                        inclusive: check.inclusive,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "multipleOf") {
                if (input.data % check.value !== BigInt(0)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        code: ZodError_1.ZodIssueCode.not_multiple_of,
                        multipleOf: check.value,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else {
                util_1.util.assertNever(check);
            }
        }
        return { status: status.value, value: input.data };
    }
    gte(value, message) {
        return this.setLimit("min", value, true, errorUtil_1.errorUtil.toString(message));
    }
    gt(value, message) {
        return this.setLimit("min", value, false, errorUtil_1.errorUtil.toString(message));
    }
    lte(value, message) {
        return this.setLimit("max", value, true, errorUtil_1.errorUtil.toString(message));
    }
    lt(value, message) {
        return this.setLimit("max", value, false, errorUtil_1.errorUtil.toString(message));
    }
    setLimit(kind, value, inclusive, message) {
        return new ZodBigInt({
            ...this._def,
            checks: [
                ...this._def.checks,
                {
                    kind,
                    value,
                    inclusive,
                    message: errorUtil_1.errorUtil.toString(message),
                },
            ],
        });
    }
    _addCheck(check) {
        return new ZodBigInt({
            ...this._def,
            checks: [...this._def.checks, check],
        });
    }
    positive(message) {
        return this._addCheck({
            kind: "min",
            value: BigInt(0),
            inclusive: false,
            message: errorUtil_1.errorUtil.toString(message),
        });
    }
    negative(message) {
        return this._addCheck({
            kind: "max",
            value: BigInt(0),
            inclusive: false,
            message: errorUtil_1.errorUtil.toString(message),
        });
    }
    nonpositive(message) {
        return this._addCheck({
            kind: "max",
            value: BigInt(0),
            inclusive: true,
            message: errorUtil_1.errorUtil.toString(message),
        });
    }
    nonnegative(message) {
        return this._addCheck({
            kind: "min",
            value: BigInt(0),
            inclusive: true,
            message: errorUtil_1.errorUtil.toString(message),
        });
    }
    multipleOf(value, message) {
        return this._addCheck({
            kind: "multipleOf",
            value,
            message: errorUtil_1.errorUtil.toString(message),
        });
    }
    get minValue() {
        let min = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "min") {
                if (min === null || ch.value > min)
                    min = ch.value;
            }
        }
        return min;
    }
    get maxValue() {
        let max = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "max") {
                if (max === null || ch.value < max)
                    max = ch.value;
            }
        }
        return max;
    }
}
exports.ZodBigInt = ZodBigInt;
ZodBigInt.create = (params) => {
    var _a;
    return new ZodBigInt({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodBigInt,
        coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
        ...processCreateParams(params),
    });
};
class ZodBoolean extends ZodType {
    _parse(input) {
        if (this._def.coerce) {
            input.data = Boolean(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.boolean) {
            const ctx = this._getOrReturnCtx(input);
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1.ZodParsedType.boolean,
                received: ctx.parsedType,
            });
            return parseUtil_1.INVALID;
        }
        return (0, parseUtil_1.OK)(input.data);
    }
}
exports.ZodBoolean = ZodBoolean;
ZodBoolean.create = (params) => {
    return new ZodBoolean({
        typeName: ZodFirstPartyTypeKind.ZodBoolean,
        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
        ...processCreateParams(params),
    });
};
class ZodDate extends ZodType {
    _parse(input) {
        if (this._def.coerce) {
            input.data = new Date(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.date) {
            const ctx = this._getOrReturnCtx(input);
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1.ZodParsedType.date,
                received: ctx.parsedType,
            });
            return parseUtil_1.INVALID;
        }
        if (isNaN(input.data.getTime())) {
            const ctx = this._getOrReturnCtx(input);
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_date,
            });
            return parseUtil_1.INVALID;
        }
        const status = new parseUtil_1.ParseStatus();
        let ctx = undefined;
        for (const check of this._def.checks) {
            if (check.kind === "min") {
                if (input.data.getTime() < check.value) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        code: ZodError_1.ZodIssueCode.too_small,
                        message: check.message,
                        inclusive: true,
                        exact: false,
                        minimum: check.value,
                        type: "date",
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "max") {
                if (input.data.getTime() > check.value) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        code: ZodError_1.ZodIssueCode.too_big,
                        message: check.message,
                        inclusive: true,
                        exact: false,
                        maximum: check.value,
                        type: "date",
                    });
                    status.dirty();
                }
            }
            else {
                util_1.util.assertNever(check);
            }
        }
        return {
            status: status.value,
            value: new Date(input.data.getTime()),
        };
    }
    _addCheck(check) {
        return new ZodDate({
            ...this._def,
            checks: [...this._def.checks, check],
        });
    }
    min(minDate, message) {
        return this._addCheck({
            kind: "min",
            value: minDate.getTime(),
            message: errorUtil_1.errorUtil.toString(message),
        });
    }
    max(maxDate, message) {
        return this._addCheck({
            kind: "max",
            value: maxDate.getTime(),
            message: errorUtil_1.errorUtil.toString(message),
        });
    }
    get minDate() {
        let min = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "min") {
                if (min === null || ch.value > min)
                    min = ch.value;
            }
        }
        return min != null ? new Date(min) : null;
    }
    get maxDate() {
        let max = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "max") {
                if (max === null || ch.value < max)
                    max = ch.value;
            }
        }
        return max != null ? new Date(max) : null;
    }
}
exports.ZodDate = ZodDate;
ZodDate.create = (params) => {
    return new ZodDate({
        checks: [],
        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
        typeName: ZodFirstPartyTypeKind.ZodDate,
        ...processCreateParams(params),
    });
};
class ZodSymbol extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.symbol) {
            const ctx = this._getOrReturnCtx(input);
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1.ZodParsedType.symbol,
                received: ctx.parsedType,
            });
            return parseUtil_1.INVALID;
        }
        return (0, parseUtil_1.OK)(input.data);
    }
}
exports.ZodSymbol = ZodSymbol;
ZodSymbol.create = (params) => {
    return new ZodSymbol({
        typeName: ZodFirstPartyTypeKind.ZodSymbol,
        ...processCreateParams(params),
    });
};
class ZodUndefined extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.undefined) {
            const ctx = this._getOrReturnCtx(input);
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1.ZodParsedType.undefined,
                received: ctx.parsedType,
            });
            return parseUtil_1.INVALID;
        }
        return (0, parseUtil_1.OK)(input.data);
    }
}
exports.ZodUndefined = ZodUndefined;
ZodUndefined.create = (params) => {
    return new ZodUndefined({
        typeName: ZodFirstPartyTypeKind.ZodUndefined,
        ...processCreateParams(params),
    });
};
class ZodNull extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.null) {
            const ctx = this._getOrReturnCtx(input);
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1.ZodParsedType.null,
                received: ctx.parsedType,
            });
            return parseUtil_1.INVALID;
        }
        return (0, parseUtil_1.OK)(input.data);
    }
}
exports.ZodNull = ZodNull;
ZodNull.create = (params) => {
    return new ZodNull({
        typeName: ZodFirstPartyTypeKind.ZodNull,
        ...processCreateParams(params),
    });
};
class ZodAny extends ZodType {
    constructor() {
        super(...arguments);
        // to prevent instances of other classes from extending ZodAny. this causes issues with catchall in ZodObject.
        this._any = true;
    }
    _parse(input) {
        return (0, parseUtil_1.OK)(input.data);
    }
}
exports.ZodAny = ZodAny;
ZodAny.create = (params) => {
    return new ZodAny({
        typeName: ZodFirstPartyTypeKind.ZodAny,
        ...processCreateParams(params),
    });
};
class ZodUnknown extends ZodType {
    constructor() {
        super(...arguments);
        // required
        this._unknown = true;
    }
    _parse(input) {
        return (0, parseUtil_1.OK)(input.data);
    }
}
exports.ZodUnknown = ZodUnknown;
ZodUnknown.create = (params) => {
    return new ZodUnknown({
        typeName: ZodFirstPartyTypeKind.ZodUnknown,
        ...processCreateParams(params),
    });
};
class ZodNever extends ZodType {
    _parse(input) {
        const ctx = this._getOrReturnCtx(input);
        (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.never,
            received: ctx.parsedType,
        });
        return parseUtil_1.INVALID;
    }
}
exports.ZodNever = ZodNever;
ZodNever.create = (params) => {
    return new ZodNever({
        typeName: ZodFirstPartyTypeKind.ZodNever,
        ...processCreateParams(params),
    });
};
class ZodVoid extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.undefined) {
            const ctx = this._getOrReturnCtx(input);
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1.ZodParsedType.void,
                received: ctx.parsedType,
            });
            return parseUtil_1.INVALID;
        }
        return (0, parseUtil_1.OK)(input.data);
    }
}
exports.ZodVoid = ZodVoid;
ZodVoid.create = (params) => {
    return new ZodVoid({
        typeName: ZodFirstPartyTypeKind.ZodVoid,
        ...processCreateParams(params),
    });
};
class ZodArray extends ZodType {
    _parse(input) {
        const { ctx, status } = this._processInputParams(input);
        const def = this._def;
        if (ctx.parsedType !== util_1.ZodParsedType.array) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1.ZodParsedType.array,
                received: ctx.parsedType,
            });
            return parseUtil_1.INVALID;
        }
        if (def.exactLength !== null) {
            const tooBig = ctx.data.length > def.exactLength.value;
            const tooSmall = ctx.data.length < def.exactLength.value;
            if (tooBig || tooSmall) {
                (0, parseUtil_1.addIssueToContext)(ctx, {
                    code: tooBig ? ZodError_1.ZodIssueCode.too_big : ZodError_1.ZodIssueCode.too_small,
                    minimum: (tooSmall ? def.exactLength.value : undefined),
                    maximum: (tooBig ? def.exactLength.value : undefined),
                    type: "array",
                    inclusive: true,
                    exact: true,
                    message: def.exactLength.message,
                });
                status.dirty();
            }
        }
        if (def.minLength !== null) {
            if (ctx.data.length < def.minLength.value) {
                (0, parseUtil_1.addIssueToContext)(ctx, {
                    code: ZodError_1.ZodIssueCode.too_small,
                    minimum: def.minLength.value,
                    type: "array",
                    inclusive: true,
                    exact: false,
                    message: def.minLength.message,
                });
                status.dirty();
            }
        }
        if (def.maxLength !== null) {
            if (ctx.data.length > def.maxLength.value) {
                (0, parseUtil_1.addIssueToContext)(ctx, {
                    code: ZodError_1.ZodIssueCode.too_big,
                    maximum: def.maxLength.value,
                    type: "array",
                    inclusive: true,
                    exact: false,
                    message: def.maxLength.message,
                });
                status.dirty();
            }
        }
        if (ctx.common.async) {
            return Promise.all([...ctx.data].map((item, i) => {
                return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
            })).then((result) => {
                return parseUtil_1.ParseStatus.mergeArray(status, result);
            });
        }
        const result = [...ctx.data].map((item, i) => {
            return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
        });
        return parseUtil_1.ParseStatus.mergeArray(status, result);
    }
    get element() {
        return this._def.type;
    }
    min(minLength, message) {
        return new ZodArray({
            ...this._def,
            minLength: { value: minLength, message: errorUtil_1.errorUtil.toString(message) },
        });
    }
    max(maxLength, message) {
        return new ZodArray({
            ...this._def,
            maxLength: { value: maxLength, message: errorUtil_1.errorUtil.toString(message) },
        });
    }
    length(len, message) {
        return new ZodArray({
            ...this._def,
            exactLength: { value: len, message: errorUtil_1.errorUtil.toString(message) },
        });
    }
    nonempty(message) {
        return this.min(1, message);
    }
}
exports.ZodArray = ZodArray;
ZodArray.create = (schema, params) => {
    return new ZodArray({
        type: schema,
        minLength: null,
        maxLength: null,
        exactLength: null,
        typeName: ZodFirstPartyTypeKind.ZodArray,
        ...processCreateParams(params),
    });
};
function deepPartialify(schema) {
    if (schema instanceof ZodObject) {
        const newShape = {};
        for (const key in schema.shape) {
            const fieldSchema = schema.shape[key];
            newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
        }
        return new ZodObject({
            ...schema._def,
            shape: () => newShape,
        });
    }
    else if (schema instanceof ZodArray) {
        return new ZodArray({
            ...schema._def,
            type: deepPartialify(schema.element),
        });
    }
    else if (schema instanceof ZodOptional) {
        return ZodOptional.create(deepPartialify(schema.unwrap()));
    }
    else if (schema instanceof ZodNullable) {
        return ZodNullable.create(deepPartialify(schema.unwrap()));
    }
    else if (schema instanceof ZodTuple) {
        return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
    }
    else {
        return schema;
    }
}
class ZodObject extends ZodType {
    constructor() {
        super(...arguments);
        this._cached = null;
        /**
         * @deprecated In most cases, this is no longer needed - unknown properties are now silently stripped.
         * If you want to pass through unknown properties, use `.passthrough()` instead.
         */
        this.nonstrict = this.passthrough;
        // extend<
        //   Augmentation extends ZodRawShape,
        //   NewOutput extends util.flatten<{
        //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
        //       ? Augmentation[k]["_output"]
        //       : k extends keyof Output
        //       ? Output[k]
        //       : never;
        //   }>,
        //   NewInput extends util.flatten<{
        //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
        //       ? Augmentation[k]["_input"]
        //       : k extends keyof Input
        //       ? Input[k]
        //       : never;
        //   }>
        // >(
        //   augmentation: Augmentation
        // ): ZodObject<
        //   extendShape<T, Augmentation>,
        //   UnknownKeys,
        //   Catchall,
        //   NewOutput,
        //   NewInput
        // > {
        //   return new ZodObject({
        //     ...this._def,
        //     shape: () => ({
        //       ...this._def.shape(),
        //       ...augmentation,
        //     }),
        //   }) as any;
        // }
        /**
         * @deprecated Use `.extend` instead
         *  */
        this.augment = this.extend;
    }
    _getCached() {
        if (this._cached !== null)
            return this._cached;
        const shape = this._def.shape();
        const keys = util_1.util.objectKeys(shape);
        return (this._cached = { shape, keys });
    }
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.object) {
            const ctx = this._getOrReturnCtx(input);
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1.ZodParsedType.object,
                received: ctx.parsedType,
            });
            return parseUtil_1.INVALID;
        }
        const { status, ctx } = this._processInputParams(input);
        const { shape, keys: shapeKeys } = this._getCached();
        const extraKeys = [];
        if (!(this._def.catchall instanceof ZodNever &&
            this._def.unknownKeys === "strip")) {
            for (const key in ctx.data) {
                if (!shapeKeys.includes(key)) {
                    extraKeys.push(key);
                }
            }
        }
        const pairs = [];
        for (const key of shapeKeys) {
            const keyValidator = shape[key];
            const value = ctx.data[key];
            pairs.push({
                key: { status: "valid", value: key },
                value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
                alwaysSet: key in ctx.data,
            });
        }
        if (this._def.catchall instanceof ZodNever) {
            const unknownKeys = this._def.unknownKeys;
            if (unknownKeys === "passthrough") {
                for (const key of extraKeys) {
                    pairs.push({
                        key: { status: "valid", value: key },
                        value: { status: "valid", value: ctx.data[key] },
                    });
                }
            }
            else if (unknownKeys === "strict") {
                if (extraKeys.length > 0) {
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        code: ZodError_1.ZodIssueCode.unrecognized_keys,
                        keys: extraKeys,
                    });
                    status.dirty();
                }
            }
            else if (unknownKeys === "strip") {
            }
            else {
                throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
            }
        }
        else {
            // run catchall validation
            const catchall = this._def.catchall;
            for (const key of extraKeys) {
                const value = ctx.data[key];
                pairs.push({
                    key: { status: "valid", value: key },
                    value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key) //, ctx.child(key), value, getParsedType(value)
                    ),
                    alwaysSet: key in ctx.data,
                });
            }
        }
        if (ctx.common.async) {
            return Promise.resolve()
                .then(async () => {
                const syncPairs = [];
                for (const pair of pairs) {
                    const key = await pair.key;
                    syncPairs.push({
                        key,
                        value: await pair.value,
                        alwaysSet: pair.alwaysSet,
                    });
                }
                return syncPairs;
            })
                .then((syncPairs) => {
                return parseUtil_1.ParseStatus.mergeObjectSync(status, syncPairs);
            });
        }
        else {
            return parseUtil_1.ParseStatus.mergeObjectSync(status, pairs);
        }
    }
    get shape() {
        return this._def.shape();
    }
    strict(message) {
        errorUtil_1.errorUtil.errToObj;
        return new ZodObject({
            ...this._def,
            unknownKeys: "strict",
            ...(message !== undefined
                ? {
                    errorMap: (issue, ctx) => {
                        var _a, _b, _c, _d;
                        const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
                        if (issue.code === "unrecognized_keys")
                            return {
                                message: (_d = errorUtil_1.errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError,
                            };
                        return {
                            message: defaultError,
                        };
                    },
                }
                : {}),
        });
    }
    strip() {
        return new ZodObject({
            ...this._def,
            unknownKeys: "strip",
        });
    }
    passthrough() {
        return new ZodObject({
            ...this._def,
            unknownKeys: "passthrough",
        });
    }
    // const AugmentFactory =
    //   <Def extends ZodObjectDef>(def: Def) =>
    //   <Augmentation extends ZodRawShape>(
    //     augmentation: Augmentation
    //   ): ZodObject<
    //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
    //     Def["unknownKeys"],
    //     Def["catchall"]
    //   > => {
    //     return new ZodObject({
    //       ...def,
    //       shape: () => ({
    //         ...def.shape(),
    //         ...augmentation,
    //       }),
    //     }) as any;
    //   };
    extend(augmentation) {
        return new ZodObject({
            ...this._def,
            shape: () => ({
                ...this._def.shape(),
                ...augmentation,
            }),
        });
    }
    /**
     * Prior to zod@1.0.12 there was a bug in the
     * inferred type of merged objects. Please
     * upgrade if you are experiencing issues.
     */
    merge(merging) {
        const merged = new ZodObject({
            unknownKeys: merging._def.unknownKeys,
            catchall: merging._def.catchall,
            shape: () => ({
                ...this._def.shape(),
                ...merging._def.shape(),
            }),
            typeName: ZodFirstPartyTypeKind.ZodObject,
        });
        return merged;
    }
    // merge<
    //   Incoming extends AnyZodObject,
    //   Augmentation extends Incoming["shape"],
    //   NewOutput extends {
    //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
    //       ? Augmentation[k]["_output"]
    //       : k extends keyof Output
    //       ? Output[k]
    //       : never;
    //   },
    //   NewInput extends {
    //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
    //       ? Augmentation[k]["_input"]
    //       : k extends keyof Input
    //       ? Input[k]
    //       : never;
    //   }
    // >(
    //   merging: Incoming
    // ): ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"],
    //   NewOutput,
    //   NewInput
    // > {
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    setKey(key, schema) {
        return this.augment({ [key]: schema });
    }
    // merge<Incoming extends AnyZodObject>(
    //   merging: Incoming
    // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
    // ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"]
    // > {
    //   // const mergedShape = objectUtil.mergeShapes(
    //   //   this._def.shape(),
    //   //   merging._def.shape()
    //   // );
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    catchall(index) {
        return new ZodObject({
            ...this._def,
            catchall: index,
        });
    }
    pick(mask) {
        const shape = {};
        util_1.util.objectKeys(mask).forEach((key) => {
            if (mask[key] && this.shape[key]) {
                shape[key] = this.shape[key];
            }
        });
        return new ZodObject({
            ...this._def,
            shape: () => shape,
        });
    }
    omit(mask) {
        const shape = {};
        util_1.util.objectKeys(this.shape).forEach((key) => {
            if (!mask[key]) {
                shape[key] = this.shape[key];
            }
        });
        return new ZodObject({
            ...this._def,
            shape: () => shape,
        });
    }
    /**
     * @deprecated
     */
    deepPartial() {
        return deepPartialify(this);
    }
    partial(mask) {
        const newShape = {};
        util_1.util.objectKeys(this.shape).forEach((key) => {
            const fieldSchema = this.shape[key];
            if (mask && !mask[key]) {
                newShape[key] = fieldSchema;
            }
            else {
                newShape[key] = fieldSchema.optional();
            }
        });
        return new ZodObject({
            ...this._def,
            shape: () => newShape,
        });
    }
    required(mask) {
        const newShape = {};
        util_1.util.objectKeys(this.shape).forEach((key) => {
            if (mask && !mask[key]) {
                newShape[key] = this.shape[key];
            }
            else {
                const fieldSchema = this.shape[key];
                let newField = fieldSchema;
                while (newField instanceof ZodOptional) {
                    newField = newField._def.innerType;
                }
                newShape[key] = newField;
            }
        });
        return new ZodObject({
            ...this._def,
            shape: () => newShape,
        });
    }
    keyof() {
        return createZodEnum(util_1.util.objectKeys(this.shape));
    }
}
exports.ZodObject = ZodObject;
ZodObject.create = (shape, params) => {
    return new ZodObject({
        shape: () => shape,
        unknownKeys: "strip",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params),
    });
};
ZodObject.strictCreate = (shape, params) => {
    return new ZodObject({
        shape: () => shape,
        unknownKeys: "strict",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params),
    });
};
ZodObject.lazycreate = (shape, params) => {
    return new ZodObject({
        shape,
        unknownKeys: "strip",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params),
    });
};
class ZodUnion extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        const options = this._def.options;
        function handleResults(results) {
            // return first issue-free validation if it exists
            for (const result of results) {
                if (result.result.status === "valid") {
                    return result.result;
                }
            }
            for (const result of results) {
                if (result.result.status === "dirty") {
                    // add issues from dirty option
                    ctx.common.issues.push(...result.ctx.common.issues);
                    return result.result;
                }
            }
            // return invalid
            const unionErrors = results.map((result) => new ZodError_1.ZodError(result.ctx.common.issues));
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_union,
                unionErrors,
            });
            return parseUtil_1.INVALID;
        }
        if (ctx.common.async) {
            return Promise.all(options.map(async (option) => {
                const childCtx = {
                    ...ctx,
                    common: {
                        ...ctx.common,
                        issues: [],
                    },
                    parent: null,
                };
                return {
                    result: await option._parseAsync({
                        data: ctx.data,
                        path: ctx.path,
                        parent: childCtx,
                    }),
                    ctx: childCtx,
                };
            })).then(handleResults);
        }
        else {
            let dirty = undefined;
            const issues = [];
            for (const option of options) {
                const childCtx = {
                    ...ctx,
                    common: {
                        ...ctx.common,
                        issues: [],
                    },
                    parent: null,
                };
                const result = option._parseSync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: childCtx,
                });
                if (result.status === "valid") {
                    return result;
                }
                else if (result.status === "dirty" && !dirty) {
                    dirty = { result, ctx: childCtx };
                }
                if (childCtx.common.issues.length) {
                    issues.push(childCtx.common.issues);
                }
            }
            if (dirty) {
                ctx.common.issues.push(...dirty.ctx.common.issues);
                return dirty.result;
            }
            const unionErrors = issues.map((issues) => new ZodError_1.ZodError(issues));
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_union,
                unionErrors,
            });
            return parseUtil_1.INVALID;
        }
    }
    get options() {
        return this._def.options;
    }
}
exports.ZodUnion = ZodUnion;
ZodUnion.create = (types, params) => {
    return new ZodUnion({
        options: types,
        typeName: ZodFirstPartyTypeKind.ZodUnion,
        ...processCreateParams(params),
    });
};
/////////////////////////////////////////////////////
/////////////////////////////////////////////////////
//////////                                 //////////
//////////      ZodDiscriminatedUnion      //////////
//////////                                 //////////
/////////////////////////////////////////////////////
/////////////////////////////////////////////////////
const getDiscriminator = (type) => {
    if (type instanceof ZodLazy) {
        return getDiscriminator(type.schema);
    }
    else if (type instanceof ZodEffects) {
        return getDiscriminator(type.innerType());
    }
    else if (type instanceof ZodLiteral) {
        return [type.value];
    }
    else if (type instanceof ZodEnum) {
        return type.options;
    }
    else if (type instanceof ZodNativeEnum) {
        // eslint-disable-next-line ban/ban
        return Object.keys(type.enum);
    }
    else if (type instanceof ZodDefault) {
        return getDiscriminator(type._def.innerType);
    }
    else if (type instanceof ZodUndefined) {
        return [undefined];
    }
    else if (type instanceof ZodNull) {
        return [null];
    }
    else {
        return null;
    }
};
class ZodDiscriminatedUnion extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_1.ZodParsedType.object) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1.ZodParsedType.object,
                received: ctx.parsedType,
            });
            return parseUtil_1.INVALID;
        }
        const discriminator = this.discriminator;
        const discriminatorValue = ctx.data[discriminator];
        const option = this.optionsMap.get(discriminatorValue);
        if (!option) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_union_discriminator,
                options: Array.from(this.optionsMap.keys()),
                path: [discriminator],
            });
            return parseUtil_1.INVALID;
        }
        if (ctx.common.async) {
            return option._parseAsync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx,
            });
        }
        else {
            return option._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx,
            });
        }
    }
    get discriminator() {
        return this._def.discriminator;
    }
    get options() {
        return this._def.options;
    }
    get optionsMap() {
        return this._def.optionsMap;
    }
    /**
     * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
     * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
     * have a different value for each object in the union.
     * @param discriminator the name of the discriminator property
     * @param types an array of object schemas
     * @param params
     */
    static create(discriminator, options, params) {
        // Get all the valid discriminator values
        const optionsMap = new Map();
        // try {
        for (const type of options) {
            const discriminatorValues = getDiscriminator(type.shape[discriminator]);
            if (!discriminatorValues) {
                throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
            }
            for (const value of discriminatorValues) {
                if (optionsMap.has(value)) {
                    throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
                }
                optionsMap.set(value, type);
            }
        }
        return new ZodDiscriminatedUnion({
            typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
            discriminator,
            options,
            optionsMap,
            ...processCreateParams(params),
        });
    }
}
exports.ZodDiscriminatedUnion = ZodDiscriminatedUnion;
function mergeValues(a, b) {
    const aType = (0, util_1.getParsedType)(a);
    const bType = (0, util_1.getParsedType)(b);
    if (a === b) {
        return { valid: true, data: a };
    }
    else if (aType === util_1.ZodParsedType.object && bType === util_1.ZodParsedType.object) {
        const bKeys = util_1.util.objectKeys(b);
        const sharedKeys = util_1.util
            .objectKeys(a)
            .filter((key) => bKeys.indexOf(key) !== -1);
        const newObj = { ...a, ...b };
        for (const key of sharedKeys) {
            const sharedValue = mergeValues(a[key], b[key]);
            if (!sharedValue.valid) {
                return { valid: false };
            }
            newObj[key] = sharedValue.data;
        }
        return { valid: true, data: newObj };
    }
    else if (aType === util_1.ZodParsedType.array && bType === util_1.ZodParsedType.array) {
        if (a.length !== b.length) {
            return { valid: false };
        }
        const newArray = [];
        for (let index = 0; index < a.length; index++) {
            const itemA = a[index];
            const itemB = b[index];
            const sharedValue = mergeValues(itemA, itemB);
            if (!sharedValue.valid) {
                return { valid: false };
            }
            newArray.push(sharedValue.data);
        }
        return { valid: true, data: newArray };
    }
    else if (aType === util_1.ZodParsedType.date &&
        bType === util_1.ZodParsedType.date &&
        +a === +b) {
        return { valid: true, data: a };
    }
    else {
        return { valid: false };
    }
}
class ZodIntersection extends ZodType {
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const handleParsed = (parsedLeft, parsedRight) => {
            if ((0, parseUtil_1.isAborted)(parsedLeft) || (0, parseUtil_1.isAborted)(parsedRight)) {
                return parseUtil_1.INVALID;
            }
            const merged = mergeValues(parsedLeft.value, parsedRight.value);
            if (!merged.valid) {
                (0, parseUtil_1.addIssueToContext)(ctx, {
                    code: ZodError_1.ZodIssueCode.invalid_intersection_types,
                });
                return parseUtil_1.INVALID;
            }
            if ((0, parseUtil_1.isDirty)(parsedLeft) || (0, parseUtil_1.isDirty)(parsedRight)) {
                status.dirty();
            }
            return { status: status.value, value: merged.data };
        };
        if (ctx.common.async) {
            return Promise.all([
                this._def.left._parseAsync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx,
                }),
                this._def.right._parseAsync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx,
                }),
            ]).then(([left, right]) => handleParsed(left, right));
        }
        else {
            return handleParsed(this._def.left._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx,
            }), this._def.right._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx,
            }));
        }
    }
}
exports.ZodIntersection = ZodIntersection;
ZodIntersection.create = (left, right, params) => {
    return new ZodIntersection({
        left: left,
        right: right,
        typeName: ZodFirstPartyTypeKind.ZodIntersection,
        ...processCreateParams(params),
    });
};
class ZodTuple extends ZodType {
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_1.ZodParsedType.array) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1.ZodParsedType.array,
                received: ctx.parsedType,
            });
            return parseUtil_1.INVALID;
        }
        if (ctx.data.length < this._def.items.length) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.too_small,
                minimum: this._def.items.length,
                inclusive: true,
                exact: false,
                type: "array",
            });
            return parseUtil_1.INVALID;
        }
        const rest = this._def.rest;
        if (!rest && ctx.data.length > this._def.items.length) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.too_big,
                maximum: this._def.items.length,
                inclusive: true,
                exact: false,
                type: "array",
            });
            status.dirty();
        }
        const items = [...ctx.data]
            .map((item, itemIndex) => {
            const schema = this._def.items[itemIndex] || this._def.rest;
            if (!schema)
                return null;
            return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
        })
            .filter((x) => !!x); // filter nulls
        if (ctx.common.async) {
            return Promise.all(items).then((results) => {
                return parseUtil_1.ParseStatus.mergeArray(status, results);
            });
        }
        else {
            return parseUtil_1.ParseStatus.mergeArray(status, items);
        }
    }
    get items() {
        return this._def.items;
    }
    rest(rest) {
        return new ZodTuple({
            ...this._def,
            rest,
        });
    }
}
exports.ZodTuple = ZodTuple;
ZodTuple.create = (schemas, params) => {
    if (!Array.isArray(schemas)) {
        throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
    }
    return new ZodTuple({
        items: schemas,
        typeName: ZodFirstPartyTypeKind.ZodTuple,
        rest: null,
        ...processCreateParams(params),
    });
};
class ZodRecord extends ZodType {
    get keySchema() {
        return this._def.keyType;
    }
    get valueSchema() {
        return this._def.valueType;
    }
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_1.ZodParsedType.object) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1.ZodParsedType.object,
                received: ctx.parsedType,
            });
            return parseUtil_1.INVALID;
        }
        const pairs = [];
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        for (const key in ctx.data) {
            pairs.push({
                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
                value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
            });
        }
        if (ctx.common.async) {
            return parseUtil_1.ParseStatus.mergeObjectAsync(status, pairs);
        }
        else {
            return parseUtil_1.ParseStatus.mergeObjectSync(status, pairs);
        }
    }
    get element() {
        return this._def.valueType;
    }
    static create(first, second, third) {
        if (second instanceof ZodType) {
            return new ZodRecord({
                keyType: first,
                valueType: second,
                typeName: ZodFirstPartyTypeKind.ZodRecord,
                ...processCreateParams(third),
            });
        }
        return new ZodRecord({
            keyType: ZodString.create(),
            valueType: first,
            typeName: ZodFirstPartyTypeKind.ZodRecord,
            ...processCreateParams(second),
        });
    }
}
exports.ZodRecord = ZodRecord;
class ZodMap extends ZodType {
    get keySchema() {
        return this._def.keyType;
    }
    get valueSchema() {
        return this._def.valueType;
    }
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_1.ZodParsedType.map) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1.ZodParsedType.map,
                received: ctx.parsedType,
            });
            return parseUtil_1.INVALID;
        }
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        const pairs = [...ctx.data.entries()].map(([key, value], index) => {
            return {
                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
                value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"])),
            };
        });
        if (ctx.common.async) {
            const finalMap = new Map();
            return Promise.resolve().then(async () => {
                for (const pair of pairs) {
                    const key = await pair.key;
                    const value = await pair.value;
                    if (key.status === "aborted" || value.status === "aborted") {
                        return parseUtil_1.INVALID;
                    }
                    if (key.status === "dirty" || value.status === "dirty") {
                        status.dirty();
                    }
                    finalMap.set(key.value, value.value);
                }
                return { status: status.value, value: finalMap };
            });
        }
        else {
            const finalMap = new Map();
            for (const pair of pairs) {
                const key = pair.key;
                const value = pair.value;
                if (key.status === "aborted" || value.status === "aborted") {
                    return parseUtil_1.INVALID;
                }
                if (key.status === "dirty" || value.status === "dirty") {
                    status.dirty();
                }
                finalMap.set(key.value, value.value);
            }
            return { status: status.value, value: finalMap };
        }
    }
}
exports.ZodMap = ZodMap;
ZodMap.create = (keyType, valueType, params) => {
    return new ZodMap({
        valueType,
        keyType,
        typeName: ZodFirstPartyTypeKind.ZodMap,
        ...processCreateParams(params),
    });
};
class ZodSet extends ZodType {
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_1.ZodParsedType.set) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1.ZodParsedType.set,
                received: ctx.parsedType,
            });
            return parseUtil_1.INVALID;
        }
        const def = this._def;
        if (def.minSize !== null) {
            if (ctx.data.size < def.minSize.value) {
                (0, parseUtil_1.addIssueToContext)(ctx, {
                    code: ZodError_1.ZodIssueCode.too_small,
                    minimum: def.minSize.value,
                    type: "set",
                    inclusive: true,
                    exact: false,
                    message: def.minSize.message,
                });
                status.dirty();
            }
        }
        if (def.maxSize !== null) {
            if (ctx.data.size > def.maxSize.value) {
                (0, parseUtil_1.addIssueToContext)(ctx, {
                    code: ZodError_1.ZodIssueCode.too_big,
                    maximum: def.maxSize.value,
                    type: "set",
                    inclusive: true,
                    exact: false,
                    message: def.maxSize.message,
                });
                status.dirty();
            }
        }
        const valueType = this._def.valueType;
        function finalizeSet(elements) {
            const parsedSet = new Set();
            for (const element of elements) {
                if (element.status === "aborted")
                    return parseUtil_1.INVALID;
                if (element.status === "dirty")
                    status.dirty();
                parsedSet.add(element.value);
            }
            return { status: status.value, value: parsedSet };
        }
        const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
        if (ctx.common.async) {
            return Promise.all(elements).then((elements) => finalizeSet(elements));
        }
        else {
            return finalizeSet(elements);
        }
    }
    min(minSize, message) {
        return new ZodSet({
            ...this._def,
            minSize: { value: minSize, message: errorUtil_1.errorUtil.toString(message) },
        });
    }
    max(maxSize, message) {
        return new ZodSet({
            ...this._def,
            maxSize: { value: maxSize, message: errorUtil_1.errorUtil.toString(message) },
        });
    }
    size(size, message) {
        return this.min(size, message).max(size, message);
    }
    nonempty(message) {
        return this.min(1, message);
    }
}
exports.ZodSet = ZodSet;
ZodSet.create = (valueType, params) => {
    return new ZodSet({
        valueType,
        minSize: null,
        maxSize: null,
        typeName: ZodFirstPartyTypeKind.ZodSet,
        ...processCreateParams(params),
    });
};
class ZodFunction extends ZodType {
    constructor() {
        super(...arguments);
        this.validate = this.implement;
    }
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_1.ZodParsedType.function) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1.ZodParsedType.function,
                received: ctx.parsedType,
            });
            return parseUtil_1.INVALID;
        }
        function makeArgsIssue(args, error) {
            return (0, parseUtil_1.makeIssue)({
                data: args,
                path: ctx.path,
                errorMaps: [
                    ctx.common.contextualErrorMap,
                    ctx.schemaErrorMap,
                    (0, errors_1.getErrorMap)(),
                    errors_1.defaultErrorMap,
                ].filter((x) => !!x),
                issueData: {
                    code: ZodError_1.ZodIssueCode.invalid_arguments,
                    argumentsError: error,
                },
            });
        }
        function makeReturnsIssue(returns, error) {
            return (0, parseUtil_1.makeIssue)({
                data: returns,
                path: ctx.path,
                errorMaps: [
                    ctx.common.contextualErrorMap,
                    ctx.schemaErrorMap,
                    (0, errors_1.getErrorMap)(),
                    errors_1.defaultErrorMap,
                ].filter((x) => !!x),
                issueData: {
                    code: ZodError_1.ZodIssueCode.invalid_return_type,
                    returnTypeError: error,
                },
            });
        }
        const params = { errorMap: ctx.common.contextualErrorMap };
        const fn = ctx.data;
        if (this._def.returns instanceof ZodPromise) {
            // Would love a way to avoid disabling this rule, but we need
            // an alias (using an arrow function was what caused 2651).
            // eslint-disable-next-line @typescript-eslint/no-this-alias
            const me = this;
            return (0, parseUtil_1.OK)(async function (...args) {
                const error = new ZodError_1.ZodError([]);
                const parsedArgs = await me._def.args
                    .parseAsync(args, params)
                    .catch((e) => {
                    error.addIssue(makeArgsIssue(args, e));
                    throw error;
                });
                const result = await Reflect.apply(fn, this, parsedArgs);
                const parsedReturns = await me._def.returns._def.type
                    .parseAsync(result, params)
                    .catch((e) => {
                    error.addIssue(makeReturnsIssue(result, e));
                    throw error;
                });
                return parsedReturns;
            });
        }
        else {
            // Would love a way to avoid disabling this rule, but we need
            // an alias (using an arrow function was what caused 2651).
            // eslint-disable-next-line @typescript-eslint/no-this-alias
            const me = this;
            return (0, parseUtil_1.OK)(function (...args) {
                const parsedArgs = me._def.args.safeParse(args, params);
                if (!parsedArgs.success) {
                    throw new ZodError_1.ZodError([makeArgsIssue(args, parsedArgs.error)]);
                }
                const result = Reflect.apply(fn, this, parsedArgs.data);
                const parsedReturns = me._def.returns.safeParse(result, params);
                if (!parsedReturns.success) {
                    throw new ZodError_1.ZodError([makeReturnsIssue(result, parsedReturns.error)]);
                }
                return parsedReturns.data;
            });
        }
    }
    parameters() {
        return this._def.args;
    }
    returnType() {
        return this._def.returns;
    }
    args(...items) {
        return new ZodFunction({
            ...this._def,
            args: ZodTuple.create(items).rest(ZodUnknown.create()),
        });
    }
    returns(returnType) {
        return new ZodFunction({
            ...this._def,
            returns: returnType,
        });
    }
    implement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
    }
    strictImplement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
    }
    static create(args, returns, params) {
        return new ZodFunction({
            args: (args
                ? args
                : ZodTuple.create([]).rest(ZodUnknown.create())),
            returns: returns || ZodUnknown.create(),
            typeName: ZodFirstPartyTypeKind.ZodFunction,
            ...processCreateParams(params),
        });
    }
}
exports.ZodFunction = ZodFunction;
class ZodLazy extends ZodType {
    get schema() {
        return this._def.getter();
    }
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        const lazySchema = this._def.getter();
        return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
    }
}
exports.ZodLazy = ZodLazy;
ZodLazy.create = (getter, params) => {
    return new ZodLazy({
        getter: getter,
        typeName: ZodFirstPartyTypeKind.ZodLazy,
        ...processCreateParams(params),
    });
};
class ZodLiteral extends ZodType {
    _parse(input) {
        if (input.data !== this._def.value) {
            const ctx = this._getOrReturnCtx(input);
            (0, parseUtil_1.addIssueToContext)(ctx, {
                received: ctx.data,
                code: ZodError_1.ZodIssueCode.invalid_literal,
                expected: this._def.value,
            });
            return parseUtil_1.INVALID;
        }
        return { status: "valid", value: input.data };
    }
    get value() {
        return this._def.value;
    }
}
exports.ZodLiteral = ZodLiteral;
ZodLiteral.create = (value, params) => {
    return new ZodLiteral({
        value: value,
        typeName: ZodFirstPartyTypeKind.ZodLiteral,
        ...processCreateParams(params),
    });
};
function createZodEnum(values, params) {
    return new ZodEnum({
        values,
        typeName: ZodFirstPartyTypeKind.ZodEnum,
        ...processCreateParams(params),
    });
}
class ZodEnum extends ZodType {
    _parse(input) {
        if (typeof input.data !== "string") {
            const ctx = this._getOrReturnCtx(input);
            const expectedValues = this._def.values;
            (0, parseUtil_1.addIssueToContext)(ctx, {
                expected: util_1.util.joinValues(expectedValues),
                received: ctx.parsedType,
                code: ZodError_1.ZodIssueCode.invalid_type,
            });
            return parseUtil_1.INVALID;
        }
        if (this._def.values.indexOf(input.data) === -1) {
            const ctx = this._getOrReturnCtx(input);
            const expectedValues = this._def.values;
            (0, parseUtil_1.addIssueToContext)(ctx, {
                received: ctx.data,
                code: ZodError_1.ZodIssueCode.invalid_enum_value,
                options: expectedValues,
            });
            return parseUtil_1.INVALID;
        }
        return (0, parseUtil_1.OK)(input.data);
    }
    get options() {
        return this._def.values;
    }
    get enum() {
        const enumValues = {};
        for (const val of this._def.values) {
            enumValues[val] = val;
        }
        return enumValues;
    }
    get Values() {
        const enumValues = {};
        for (const val of this._def.values) {
            enumValues[val] = val;
        }
        return enumValues;
    }
    get Enum() {
        const enumValues = {};
        for (const val of this._def.values) {
            enumValues[val] = val;
        }
        return enumValues;
    }
    extract(values) {
        return ZodEnum.create(values);
    }
    exclude(values) {
        return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)));
    }
}
exports.ZodEnum = ZodEnum;
ZodEnum.create = createZodEnum;
class ZodNativeEnum extends ZodType {
    _parse(input) {
        const nativeEnumValues = util_1.util.getValidEnumValues(this._def.values);
        const ctx = this._getOrReturnCtx(input);
        if (ctx.parsedType !== util_1.ZodParsedType.string &&
            ctx.parsedType !== util_1.ZodParsedType.number) {
            const expectedValues = util_1.util.objectValues(nativeEnumValues);
            (0, parseUtil_1.addIssueToContext)(ctx, {
                expected: util_1.util.joinValues(expectedValues),
                received: ctx.parsedType,
                code: ZodError_1.ZodIssueCode.invalid_type,
            });
            return parseUtil_1.INVALID;
        }
        if (nativeEnumValues.indexOf(input.data) === -1) {
            const expectedValues = util_1.util.objectValues(nativeEnumValues);
            (0, parseUtil_1.addIssueToContext)(ctx, {
                received: ctx.data,
                code: ZodError_1.ZodIssueCode.invalid_enum_value,
                options: expectedValues,
            });
            return parseUtil_1.INVALID;
        }
        return (0, parseUtil_1.OK)(input.data);
    }
    get enum() {
        return this._def.values;
    }
}
exports.ZodNativeEnum = ZodNativeEnum;
ZodNativeEnum.create = (values, params) => {
    return new ZodNativeEnum({
        values: values,
        typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
        ...processCreateParams(params),
    });
};
class ZodPromise extends ZodType {
    unwrap() {
        return this._def.type;
    }
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_1.ZodParsedType.promise &&
            ctx.common.async === false) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1.ZodParsedType.promise,
                received: ctx.parsedType,
            });
            return parseUtil_1.INVALID;
        }
        const promisified = ctx.parsedType === util_1.ZodParsedType.promise
            ? ctx.data
            : Promise.resolve(ctx.data);
        return (0, parseUtil_1.OK)(promisified.then((data) => {
            return this._def.type.parseAsync(data, {
                path: ctx.path,
                errorMap: ctx.common.contextualErrorMap,
            });
        }));
    }
}
exports.ZodPromise = ZodPromise;
ZodPromise.create = (schema, params) => {
    return new ZodPromise({
        type: schema,
        typeName: ZodFirstPartyTypeKind.ZodPromise,
        ...processCreateParams(params),
    });
};
class ZodEffects extends ZodType {
    innerType() {
        return this._def.schema;
    }
    sourceType() {
        return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects
            ? this._def.schema.sourceType()
            : this._def.schema;
    }
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const effect = this._def.effect || null;
        const checkCtx = {
            addIssue: (arg) => {
                (0, parseUtil_1.addIssueToContext)(ctx, arg);
                if (arg.fatal) {
                    status.abort();
                }
                else {
                    status.dirty();
                }
            },
            get path() {
                return ctx.path;
            },
        };
        checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
        if (effect.type === "preprocess") {
            const processed = effect.transform(ctx.data, checkCtx);
            if (ctx.common.issues.length) {
                return {
                    status: "dirty",
                    value: ctx.data,
                };
            }
            if (ctx.common.async) {
                return Promise.resolve(processed).then((processed) => {
                    return this._def.schema._parseAsync({
                        data: processed,
                        path: ctx.path,
                        parent: ctx,
                    });
                });
            }
            else {
                return this._def.schema._parseSync({
                    data: processed,
                    path: ctx.path,
                    parent: ctx,
                });
            }
        }
        if (effect.type === "refinement") {
            const executeRefinement = (acc
            // effect: RefinementEffect<any>
            ) => {
                const result = effect.refinement(acc, checkCtx);
                if (ctx.common.async) {
                    return Promise.resolve(result);
                }
                if (result instanceof Promise) {
                    throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
                }
                return acc;
            };
            if (ctx.common.async === false) {
                const inner = this._def.schema._parseSync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx,
                });
                if (inner.status === "aborted")
                    return parseUtil_1.INVALID;
                if (inner.status === "dirty")
                    status.dirty();
                // return value is ignored
                executeRefinement(inner.value);
                return { status: status.value, value: inner.value };
            }
            else {
                return this._def.schema
                    ._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx })
                    .then((inner) => {
                    if (inner.status === "aborted")
                        return parseUtil_1.INVALID;
                    if (inner.status === "dirty")
                        status.dirty();
                    return executeRefinement(inner.value).then(() => {
                        return { status: status.value, value: inner.value };
                    });
                });
            }
        }
        if (effect.type === "transform") {
            if (ctx.common.async === false) {
                const base = this._def.schema._parseSync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx,
                });
                if (!(0, parseUtil_1.isValid)(base))
                    return base;
                const result = effect.transform(base.value, checkCtx);
                if (result instanceof Promise) {
                    throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
                }
                return { status: status.value, value: result };
            }
            else {
                return this._def.schema
                    ._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx })
                    .then((base) => {
                    if (!(0, parseUtil_1.isValid)(base))
                        return base;
                    return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
                });
            }
        }
        util_1.util.assertNever(effect);
    }
}
exports.ZodEffects = ZodEffects;
exports.ZodTransformer = ZodEffects;
ZodEffects.create = (schema, effect, params) => {
    return new ZodEffects({
        schema,
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        effect,
        ...processCreateParams(params),
    });
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
    return new ZodEffects({
        schema,
        effect: { type: "preprocess", transform: preprocess },
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        ...processCreateParams(params),
    });
};
class ZodOptional extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === util_1.ZodParsedType.undefined) {
            return (0, parseUtil_1.OK)(undefined);
        }
        return this._def.innerType._parse(input);
    }
    unwrap() {
        return this._def.innerType;
    }
}
exports.ZodOptional = ZodOptional;
ZodOptional.create = (type, params) => {
    return new ZodOptional({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodOptional,
        ...processCreateParams(params),
    });
};
class ZodNullable extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === util_1.ZodParsedType.null) {
            return (0, parseUtil_1.OK)(null);
        }
        return this._def.innerType._parse(input);
    }
    unwrap() {
        return this._def.innerType;
    }
}
exports.ZodNullable = ZodNullable;
ZodNullable.create = (type, params) => {
    return new ZodNullable({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodNullable,
        ...processCreateParams(params),
    });
};
class ZodDefault extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        let data = ctx.data;
        if (ctx.parsedType === util_1.ZodParsedType.undefined) {
            data = this._def.defaultValue();
        }
        return this._def.innerType._parse({
            data,
            path: ctx.path,
            parent: ctx,
        });
    }
    removeDefault() {
        return this._def.innerType;
    }
}
exports.ZodDefault = ZodDefault;
ZodDefault.create = (type, params) => {
    return new ZodDefault({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodDefault,
        defaultValue: typeof params.default === "function"
            ? params.default
            : () => params.default,
        ...processCreateParams(params),
    });
};
class ZodCatch extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        // newCtx is used to not collect issues from inner types in ctx
        const newCtx = {
            ...ctx,
            common: {
                ...ctx.common,
                issues: [],
            },
        };
        const result = this._def.innerType._parse({
            data: newCtx.data,
            path: newCtx.path,
            parent: {
                ...newCtx,
            },
        });
        if ((0, parseUtil_1.isAsync)(result)) {
            return result.then((result) => {
                return {
                    status: "valid",
                    value: result.status === "valid"
                        ? result.value
                        : this._def.catchValue({
                            get error() {
                                return new ZodError_1.ZodError(newCtx.common.issues);
                            },
                            input: newCtx.data,
                        }),
                };
            });
        }
        else {
            return {
                status: "valid",
                value: result.status === "valid"
                    ? result.value
                    : this._def.catchValue({
                        get error() {
                            return new ZodError_1.ZodError(newCtx.common.issues);
                        },
                        input: newCtx.data,
                    }),
            };
        }
    }
    removeCatch() {
        return this._def.innerType;
    }
}
exports.ZodCatch = ZodCatch;
ZodCatch.create = (type, params) => {
    return new ZodCatch({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodCatch,
        catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
        ...processCreateParams(params),
    });
};
class ZodNaN extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.nan) {
            const ctx = this._getOrReturnCtx(input);
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1.ZodParsedType.nan,
                received: ctx.parsedType,
            });
            return parseUtil_1.INVALID;
        }
        return { status: "valid", value: input.data };
    }
}
exports.ZodNaN = ZodNaN;
ZodNaN.create = (params) => {
    return new ZodNaN({
        typeName: ZodFirstPartyTypeKind.ZodNaN,
        ...processCreateParams(params),
    });
};
exports.BRAND = Symbol("zod_brand");
class ZodBranded extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        const data = ctx.data;
        return this._def.type._parse({
            data,
            path: ctx.path,
            parent: ctx,
        });
    }
    unwrap() {
        return this._def.type;
    }
}
exports.ZodBranded = ZodBranded;
class ZodPipeline extends ZodType {
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.common.async) {
            const handleAsync = async () => {
                const inResult = await this._def.in._parseAsync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx,
                });
                if (inResult.status === "aborted")
                    return parseUtil_1.INVALID;
                if (inResult.status === "dirty") {
                    status.dirty();
                    return (0, parseUtil_1.DIRTY)(inResult.value);
                }
                else {
                    return this._def.out._parseAsync({
                        data: inResult.value,
                        path: ctx.path,
                        parent: ctx,
                    });
                }
            };
            return handleAsync();
        }
        else {
            const inResult = this._def.in._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx,
            });
            if (inResult.status === "aborted")
                return parseUtil_1.INVALID;
            if (inResult.status === "dirty") {
                status.dirty();
                return {
                    status: "dirty",
                    value: inResult.value,
                };
            }
            else {
                return this._def.out._parseSync({
                    data: inResult.value,
                    path: ctx.path,
                    parent: ctx,
                });
            }
        }
    }
    static create(a, b) {
        return new ZodPipeline({
            in: a,
            out: b,
            typeName: ZodFirstPartyTypeKind.ZodPipeline,
        });
    }
}
exports.ZodPipeline = ZodPipeline;
class ZodReadonly extends ZodType {
    _parse(input) {
        const result = this._def.innerType._parse(input);
        if ((0, parseUtil_1.isValid)(result)) {
            result.value = Object.freeze(result.value);
        }
        return result;
    }
}
exports.ZodReadonly = ZodReadonly;
ZodReadonly.create = (type, params) => {
    return new ZodReadonly({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodReadonly,
        ...processCreateParams(params),
    });
};
const custom = (check, params = {}, 
/**
 * @deprecated
 *
 * Pass `fatal` into the params object instead:
 *
 * ```ts
 * z.string().custom((val) => val.length > 5, { fatal: false })
 * ```
 *
 */
fatal) => {
    if (check)
        return ZodAny.create().superRefine((data, ctx) => {
            var _a, _b;
            if (!check(data)) {
                const p = typeof params === "function"
                    ? params(data)
                    : typeof params === "string"
                        ? { message: params }
                        : params;
                const _fatal = (_b = (_a = p.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;
                const p2 = typeof p === "string" ? { message: p } : p;
                ctx.addIssue({ code: "custom", ...p2, fatal: _fatal });
            }
        });
    return ZodAny.create();
};
exports.custom = custom;
exports.late = {
    object: ZodObject.lazycreate,
};
var ZodFirstPartyTypeKind;
(function (ZodFirstPartyTypeKind) {
    ZodFirstPartyTypeKind["ZodString"] = "ZodString";
    ZodFirstPartyTypeKind["ZodNumber"] = "ZodNumber";
    ZodFirstPartyTypeKind["ZodNaN"] = "ZodNaN";
    ZodFirstPartyTypeKind["ZodBigInt"] = "ZodBigInt";
    ZodFirstPartyTypeKind["ZodBoolean"] = "ZodBoolean";
    ZodFirstPartyTypeKind["ZodDate"] = "ZodDate";
    ZodFirstPartyTypeKind["ZodSymbol"] = "ZodSymbol";
    ZodFirstPartyTypeKind["ZodUndefined"] = "ZodUndefined";
    ZodFirstPartyTypeKind["ZodNull"] = "ZodNull";
    ZodFirstPartyTypeKind["ZodAny"] = "ZodAny";
    ZodFirstPartyTypeKind["ZodUnknown"] = "ZodUnknown";
    ZodFirstPartyTypeKind["ZodNever"] = "ZodNever";
    ZodFirstPartyTypeKind["ZodVoid"] = "ZodVoid";
    ZodFirstPartyTypeKind["ZodArray"] = "ZodArray";
    ZodFirstPartyTypeKind["ZodObject"] = "ZodObject";
    ZodFirstPartyTypeKind["ZodUnion"] = "ZodUnion";
    ZodFirstPartyTypeKind["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
    ZodFirstPartyTypeKind["ZodIntersection"] = "ZodIntersection";
    ZodFirstPartyTypeKind["ZodTuple"] = "ZodTuple";
    ZodFirstPartyTypeKind["ZodRecord"] = "ZodRecord";
    ZodFirstPartyTypeKind["ZodMap"] = "ZodMap";
    ZodFirstPartyTypeKind["ZodSet"] = "ZodSet";
    ZodFirstPartyTypeKind["ZodFunction"] = "ZodFunction";
    ZodFirstPartyTypeKind["ZodLazy"] = "ZodLazy";
    ZodFirstPartyTypeKind["ZodLiteral"] = "ZodLiteral";
    ZodFirstPartyTypeKind["ZodEnum"] = "ZodEnum";
    ZodFirstPartyTypeKind["ZodEffects"] = "ZodEffects";
    ZodFirstPartyTypeKind["ZodNativeEnum"] = "ZodNativeEnum";
    ZodFirstPartyTypeKind["ZodOptional"] = "ZodOptional";
    ZodFirstPartyTypeKind["ZodNullable"] = "ZodNullable";
    ZodFirstPartyTypeKind["ZodDefault"] = "ZodDefault";
    ZodFirstPartyTypeKind["ZodCatch"] = "ZodCatch";
    ZodFirstPartyTypeKind["ZodPromise"] = "ZodPromise";
    ZodFirstPartyTypeKind["ZodBranded"] = "ZodBranded";
    ZodFirstPartyTypeKind["ZodPipeline"] = "ZodPipeline";
    ZodFirstPartyTypeKind["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind = exports.ZodFirstPartyTypeKind || (exports.ZodFirstPartyTypeKind = {}));
// requires TS 4.4+
class Class {
    constructor(..._) { }
}
const instanceOfType = (
// const instanceOfType = <T extends new (...args: any[]) => any>(
cls, params = {
    message: `Input not instance of ${cls.name}`,
}) => (0, exports.custom)((data) => data instanceof cls, params);
exports["instanceof"] = instanceOfType;
const stringType = ZodString.create;
exports.string = stringType;
const numberType = ZodNumber.create;
exports.number = numberType;
const nanType = ZodNaN.create;
exports.nan = nanType;
const bigIntType = ZodBigInt.create;
exports.bigint = bigIntType;
const booleanType = ZodBoolean.create;
exports.boolean = booleanType;
const dateType = ZodDate.create;
exports.date = dateType;
const symbolType = ZodSymbol.create;
exports.symbol = symbolType;
const undefinedType = ZodUndefined.create;
exports.undefined = undefinedType;
const nullType = ZodNull.create;
exports["null"] = nullType;
const anyType = ZodAny.create;
exports.any = anyType;
const unknownType = ZodUnknown.create;
exports.unknown = unknownType;
const neverType = ZodNever.create;
exports.never = neverType;
const voidType = ZodVoid.create;
exports["void"] = voidType;
const arrayType = ZodArray.create;
exports.array = arrayType;
const objectType = ZodObject.create;
exports.object = objectType;
const strictObjectType = ZodObject.strictCreate;
exports.strictObject = strictObjectType;
const unionType = ZodUnion.create;
exports.union = unionType;
const discriminatedUnionType = ZodDiscriminatedUnion.create;
exports.discriminatedUnion = discriminatedUnionType;
const intersectionType = ZodIntersection.create;
exports.intersection = intersectionType;
const tupleType = ZodTuple.create;
exports.tuple = tupleType;
const recordType = ZodRecord.create;
exports.record = recordType;
const mapType = ZodMap.create;
exports.map = mapType;
const setType = ZodSet.create;
exports.set = setType;
const functionType = ZodFunction.create;
exports["function"] = functionType;
const lazyType = ZodLazy.create;
exports.lazy = lazyType;
const literalType = ZodLiteral.create;
exports.literal = literalType;
const enumType = ZodEnum.create;
exports["enum"] = enumType;
const nativeEnumType = ZodNativeEnum.create;
exports.nativeEnum = nativeEnumType;
const promiseType = ZodPromise.create;
exports.promise = promiseType;
const effectsType = ZodEffects.create;
exports.effect = effectsType;
exports.transformer = effectsType;
const optionalType = ZodOptional.create;
exports.optional = optionalType;
const nullableType = ZodNullable.create;
exports.nullable = nullableType;
const preprocessType = ZodEffects.createWithPreprocess;
exports.preprocess = preprocessType;
const pipelineType = ZodPipeline.create;
exports.pipeline = pipelineType;
const ostring = () => stringType().optional();
exports.ostring = ostring;
const onumber = () => numberType().optional();
exports.onumber = onumber;
const oboolean = () => booleanType().optional();
exports.oboolean = oboolean;
exports.coerce = {
    string: ((arg) => ZodString.create({ ...arg, coerce: true })),
    number: ((arg) => ZodNumber.create({ ...arg, coerce: true })),
    boolean: ((arg) => ZodBoolean.create({
        ...arg,
        coerce: true,
    })),
    bigint: ((arg) => ZodBigInt.create({ ...arg, coerce: true })),
    date: ((arg) => ZodDate.create({ ...arg, coerce: true })),
};
exports.NEVER = parseUtil_1.INVALID;


/***/ }),

/***/ 7326:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _assertThisInitialized)
/* harmony export */ });
function _assertThisInitialized(e) {
  if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}


/***/ }),

/***/ 3144:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _createClass)
/* harmony export */ });
/* harmony import */ var _toPropertyKey_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7343);

function _defineProperties(e, r) {
  for (var t = 0; t < r.length; t++) {
    var o = r[t];
    o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, (0,_toPropertyKey_js__WEBPACK_IMPORTED_MODULE_0__["default"])(o.key), o);
  }
}
function _createClass(e, r, t) {
  return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
    writable: !1
  }), e;
}


/***/ }),

/***/ 7462:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _extends)
/* harmony export */ });
function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function (n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends.apply(null, arguments);
}


/***/ }),

/***/ 4578:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _inheritsLoose)
/* harmony export */ });
/* harmony import */ var _setPrototypeOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9611);

function _inheritsLoose(t, o) {
  t.prototype = Object.create(o.prototype), t.prototype.constructor = t, (0,_setPrototypeOf_js__WEBPACK_IMPORTED_MODULE_0__["default"])(t, o);
}


/***/ }),

/***/ 3366:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _objectWithoutPropertiesLoose)
/* harmony export */ });
function _objectWithoutPropertiesLoose(r, e) {
  if (null == r) return {};
  var t = {};
  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (-1 !== e.indexOf(n)) continue;
    t[n] = r[n];
  }
  return t;
}


/***/ }),

/***/ 9611:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _setPrototypeOf)
/* harmony export */ });
function _setPrototypeOf(t, e) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {
    return t.__proto__ = e, t;
  }, _setPrototypeOf(t, e);
}


/***/ }),

/***/ 5512:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ toPrimitive)
/* harmony export */ });
/* harmony import */ var _typeof_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1002);

function toPrimitive(t, r) {
  if ("object" != (0,_typeof_js__WEBPACK_IMPORTED_MODULE_0__["default"])(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != (0,_typeof_js__WEBPACK_IMPORTED_MODULE_0__["default"])(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}


/***/ }),

/***/ 7343:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ toPropertyKey)
/* harmony export */ });
/* harmony import */ var _typeof_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1002);
/* harmony import */ var _toPrimitive_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5512);


function toPropertyKey(t) {
  var i = (0,_toPrimitive_js__WEBPACK_IMPORTED_MODULE_0__["default"])(t, "string");
  return "symbol" == (0,_typeof_js__WEBPACK_IMPORTED_MODULE_1__["default"])(i) ? i : i + "";
}


/***/ }),

/***/ 1002:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _typeof)
/* harmony export */ });
function _typeof(o) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof(o);
}


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__(9980);
/******/ 	var __webpack_export_target__ = exports;
/******/ 	for(var i in __webpack_exports__) __webpack_export_target__[i] = __webpack_exports__[i];
/******/ 	if(__webpack_exports__.__esModule) Object.defineProperty(__webpack_export_target__, "__esModule", { value: true });
/******/ 	
/******/ })()
;