"use strict";
// Copyright Epic Games, Inc. All Rights Reserved.
Object.defineProperty(exports, "__esModule", { value: true });
exports.GamepadController = exports.GamepadLayout = void 0;
const GamepadTypes_1 = require("./GamepadTypes");
/**
 * Gamepad layout codes enum
 */
var GamepadLayout;
(function (GamepadLayout) {
    GamepadLayout[GamepadLayout["RightClusterBottomButton"] = 0] = "RightClusterBottomButton";
    GamepadLayout[GamepadLayout["RightClusterRightButton"] = 1] = "RightClusterRightButton";
    GamepadLayout[GamepadLayout["RightClusterLeftButton"] = 2] = "RightClusterLeftButton";
    GamepadLayout[GamepadLayout["RightClusterTopButton"] = 3] = "RightClusterTopButton";
    GamepadLayout[GamepadLayout["LeftShoulder"] = 4] = "LeftShoulder";
    GamepadLayout[GamepadLayout["RightShoulder"] = 5] = "RightShoulder";
    GamepadLayout[GamepadLayout["LeftTrigger"] = 6] = "LeftTrigger";
    GamepadLayout[GamepadLayout["RightTrigger"] = 7] = "RightTrigger";
    GamepadLayout[GamepadLayout["SelectOrBack"] = 8] = "SelectOrBack";
    GamepadLayout[GamepadLayout["StartOrForward"] = 9] = "StartOrForward";
    GamepadLayout[GamepadLayout["LeftAnalogPress"] = 10] = "LeftAnalogPress";
    GamepadLayout[GamepadLayout["RightAnalogPress"] = 11] = "RightAnalogPress";
    GamepadLayout[GamepadLayout["LeftClusterTopButton"] = 12] = "LeftClusterTopButton";
    GamepadLayout[GamepadLayout["LeftClusterBottomButton"] = 13] = "LeftClusterBottomButton";
    GamepadLayout[GamepadLayout["LeftClusterLeftButton"] = 14] = "LeftClusterLeftButton";
    GamepadLayout[GamepadLayout["LeftClusterRightButton"] = 15] = "LeftClusterRightButton";
    GamepadLayout[GamepadLayout["CentreButton"] = 16] = "CentreButton";
    // Axes
    GamepadLayout[GamepadLayout["LeftStickHorizontal"] = 0] = "LeftStickHorizontal";
    GamepadLayout[GamepadLayout["LeftStickVertical"] = 1] = "LeftStickVertical";
    GamepadLayout[GamepadLayout["RightStickHorizontal"] = 2] = "RightStickHorizontal";
    GamepadLayout[GamepadLayout["RightStickVertical"] = 3] = "RightStickVertical";
})(GamepadLayout || (exports.GamepadLayout = GamepadLayout = {}));
/**
 * Handles gamepad events from the document to send to the streamer.
 */
class GamepadController {
    constructor(streamMessageController) {
        this.streamMessageController = streamMessageController;
        this.onGamepadConnectedListener = this.onGamepadConnected.bind(this);
        this.onGamepadDisconnectedListener = this.onGamepadDisconnected.bind(this);
        this.beforeUnloadListener = this.onBeforeUnload.bind(this);
        this.requestAnimationFrame = (window.mozRequestAnimationFrame ||
            window.webkitRequestAnimationFrame ||
            window.requestAnimationFrame).bind(window);
    }
    register() {
        window.addEventListener('beforeunload', this.beforeUnloadListener);
        const browserWindow = window;
        if ('GamepadEvent' in browserWindow) {
            window.addEventListener('gamepadconnected', this.onGamepadConnectedListener);
            window.addEventListener('gamepaddisconnected', this.onGamepadDisconnectedListener);
        }
        else if ('WebKitGamepadEvent' in browserWindow) {
            window.addEventListener('webkitgamepadconnected', this.onGamepadConnectedListener);
            window.addEventListener('webkitgamepaddisconnected', this.onGamepadDisconnectedListener);
        }
        this.controllers = [];
        if (navigator.getGamepads) {
            for (const gamepad of navigator.getGamepads()) {
                if (gamepad) {
                    this.onGamepadConnected(new GamepadEvent('gamepadconnected', { gamepad }));
                }
            }
        }
    }
    unregister() {
        window.removeEventListener('gamepadconnected', this.onGamepadConnectedListener);
        window.removeEventListener('gamepaddisconnected', this.onGamepadDisconnectedListener);
        window.removeEventListener('webkitgamepadconnected', this.onGamepadConnectedListener);
        window.removeEventListener('webkitgamepaddisconnected', this.onGamepadDisconnectedListener);
        for (const controller of this.controllers) {
            if (controller && controller.id !== undefined) {
                this.streamMessageController.toStreamerHandlers.get('GamepadDisconnected')([controller.id]);
            }
        }
        this.controllers = [];
    }
    onGamepadResponseReceived(gamepadId) {
        for (const controller of this.controllers) {
            if (controller && controller.id === undefined) {
                controller.id = gamepadId;
                break;
            }
        }
    }
    onGamepadConnected(event) {
        const gamepad = event.gamepad;
        const newController = {
            currentState: (0, GamepadTypes_1.deepCopyGamepad)(gamepad),
            prevState: (0, GamepadTypes_1.deepCopyGamepad)(gamepad),
            id: undefined
        };
        this.controllers[gamepad.index] = newController;
        window.requestAnimationFrame(() => this.updateStatus());
        this.streamMessageController.toStreamerHandlers.get('GamepadConnected')();
    }
    onGamepadDisconnected(event) {
        const gamepad = event.gamepad;
        const deletedController = this.controllers[gamepad.index];
        delete this.controllers[gamepad.index];
        this.controllers = this.controllers.filter((controller) => controller !== undefined);
        if (deletedController.id !== undefined) {
            this.streamMessageController.toStreamerHandlers.get('GamepadDisconnected')([
                deletedController.id
            ]);
        }
    }
    scanGamepads() {
        const gamepads = navigator.getGamepads
            ? navigator.getGamepads()
            : navigator.webkitGetGamepads
                ? navigator.webkitGetGamepads()
                : [];
        for (let i = 0; i < gamepads.length; i++) {
            if (gamepads[i] && this.controllers[gamepads[i].index] !== undefined) {
                this.controllers[gamepads[i].index].currentState = gamepads[i];
            }
        }
    }
    updateStatus() {
        this.scanGamepads();
        const toStreamerHandlers = this.streamMessageController.toStreamerHandlers;
        // Iterate over multiple controllers in the case the multiple gamepads are connected
        for (const controller of this.controllers) {
            if (!controller) {
                continue;
            }
            // If we haven't received an id (possible if using an older version of UE), return to original functionality
            const controllerId = controller.id === undefined ? this.controllers.indexOf(controller) : controller.id;
            const currentState = controller.currentState;
            for (let i = 0; i < controller.currentState.buttons.length; i++) {
                const currentButton = controller.currentState.buttons[i];
                const previousButton = controller.prevState.buttons[i];
                if (currentButton.pressed) {
                    // press
                    if (i == GamepadLayout.LeftTrigger) {
                        // UEs left analog has a button index of 5
                        toStreamerHandlers.get('GamepadAnalog')([controllerId, 5, currentButton.value]);
                    }
                    else if (i == GamepadLayout.RightTrigger) {
                        // UEs right analog has a button index of 6
                        toStreamerHandlers.get('GamepadAnalog')([controllerId, 6, currentButton.value]);
                    }
                    else {
                        toStreamerHandlers.get('GamepadButtonPressed')([
                            controllerId,
                            i,
                            previousButton.pressed ? 1 : 0
                        ]);
                    }
                }
                else if (!currentButton.pressed && previousButton.pressed) {
                    // release
                    if (i == GamepadLayout.LeftTrigger) {
                        // UEs left analog has a button index of 5
                        toStreamerHandlers.get('GamepadAnalog')([controllerId, 5, 0]);
                    }
                    else if (i == GamepadLayout.RightTrigger) {
                        // UEs right analog has a button index of 6
                        toStreamerHandlers.get('GamepadAnalog')([controllerId, 6, 0]);
                    }
                    else {
                        toStreamerHandlers.get('GamepadButtonReleased')([controllerId, i, 0]);
                    }
                }
            }
            // Iterate over gamepad axes (we will increment in lots of 2 as there is 2 axes per stick)
            for (let i = 0; i < currentState.axes.length; i += 2) {
                // Horizontal axes are even numbered
                const x = parseFloat(currentState.axes[i].toFixed(4));
                // Vertical axes are odd numbered
                // https://w3c.github.io/gamepad/#remapping Gamepad browser side standard mapping has positive down, negative up. This is downright disgusting. So we fix it.
                const y = -parseFloat(currentState.axes[i + 1].toFixed(4));
                // UE's analog axes follow the same order as the browsers, but start at index 1 so we will offset as such
                toStreamerHandlers.get('GamepadAnalog')([controllerId, i + 1, x]); // Horizontal axes, only offset by 1
                toStreamerHandlers.get('GamepadAnalog')([controllerId, i + 2, y]); // Vertical axes, offset by two (1 to match UEs axes convention and then another 1 for the vertical axes)
            }
            const controllerIndex = this.controllers.indexOf(controller);
            this.controllers[controllerIndex].prevState = (0, GamepadTypes_1.deepCopyGamepad)(currentState);
        }
        if (this.controllers.length > 0) {
            this.requestAnimationFrame(() => this.updateStatus());
        }
    }
    onBeforeUnload(_) {
        // When a user navigates away from the page, we need to inform UE of all the disconnecting
        // controllers
        for (const controller of this.controllers) {
            if (!controller || controller.id === undefined) {
                continue;
            }
            this.streamMessageController.toStreamerHandlers.get('GamepadDisconnected')([controller.id]);
        }
    }
}
exports.GamepadController = GamepadController;
//# sourceMappingURL=GamepadController.js.map