"use strict";
// Copyright Epic Games, Inc. All Rights Reserved.
Object.defineProperty(exports, "__esModule", { value: true });
exports.AFKController = void 0;
const Config_1 = require("../Config/Config");
const lib_pixelstreamingcommon_ue5_5_1 = require("@epicgames-ps/lib-pixelstreamingcommon-ue5.5");
const EventEmitter_1 = require("../Util/EventEmitter");
class AFKController {
    constructor(config, pixelStreaming, onDismissAfk) {
        // time out logic details
        this.active = false;
        this.countdownActive = false;
        this.warnTimer = undefined;
        this.countDown = 0;
        this.countDownTimer = undefined;
        this.config = config;
        this.pixelStreaming = pixelStreaming;
        this.onDismissAfk = onDismissAfk;
        this.onAFKTimedOutCallback = () => {
            console.log('AFK timed out, did you want to override this callback?');
        };
    }
    /**
     * The methods that occur when an afk event listener is clicked
     */
    onAfkClick() {
        clearInterval(this.countDownTimer);
        if (this.active || this.countdownActive) {
            this.startAfkWarningTimer();
            this.pixelStreaming.dispatchEvent(new EventEmitter_1.AfkWarningDeactivateEvent());
        }
    }
    /**
     * Start the warning timer if a timeout is set greater that 0 seconds
     */
    startAfkWarningTimer() {
        if (this.config.getNumericSettingValue(Config_1.NumericParameters.AFKTimeoutSecs) > 0 &&
            this.config.isFlagEnabled(Config_1.Flags.AFKDetection)) {
            this.active = true;
        }
        else {
            this.active = false;
        }
        this.resetAfkWarningTimer();
    }
    /**
     * Stop the afk warning timer
     */
    stopAfkWarningTimer() {
        this.active = false;
        this.countdownActive = false;
        clearTimeout(this.warnTimer);
        clearInterval(this.countDownTimer);
    }
    /**
     * Pause the timer which when elapsed will warn the user they are inactive.
     */
    pauseAfkWarningTimer() {
        this.active = false;
    }
    /**
     * If the user interacts then reset the warning timer.
     */
    resetAfkWarningTimer() {
        if (this.active && this.config.isFlagEnabled(Config_1.Flags.AFKDetection)) {
            clearTimeout(this.warnTimer);
            this.warnTimer = setTimeout(() => this.activateAfkEvent(), this.config.getNumericSettingValue(Config_1.NumericParameters.AFKTimeoutSecs) * 1000);
        }
    }
    /**
     * Show the AFK overlay and begin the countDown
     */
    activateAfkEvent() {
        // Pause the timer while the user is looking at the inactivity warning overlay
        this.pauseAfkWarningTimer();
        // instantiate a new overlay
        this.pixelStreaming.dispatchEvent(new EventEmitter_1.AfkWarningActivateEvent({
            countDown: this.countDown,
            dismissAfk: this.onDismissAfk
        }));
        // update our countDown timer and overlay contents
        this.countDown = this.config.getNumericSettingValue(Config_1.NumericParameters.AFKCountdownSecs);
        this.countdownActive = true;
        this.pixelStreaming.dispatchEvent(new EventEmitter_1.AfkWarningUpdateEvent({ countDown: this.countDown }));
        // if we are in locked mouse exit pointerlock
        if (!this.config.isFlagEnabled(Config_1.Flags.HoveringMouseMode)) {
            // minor hack to alleviate ios not supporting pointerlock
            if (document.exitPointerLock) {
                document.exitPointerLock();
            }
        }
        // reset our countDown interval accordingly
        this.countDownTimer = setInterval(() => {
            this.countDown--;
            if (this.countDown == 0) {
                // The user failed to click so hide the overlay and disconnect them.
                this.pixelStreaming.dispatchEvent(new EventEmitter_1.AfkTimedOutEvent());
                this.onAFKTimedOutCallback();
                lib_pixelstreamingcommon_ue5_5_1.Logger.Info('You have been disconnected due to inactivity');
                // switch off the afk feature as stream has closed
                this.stopAfkWarningTimer();
            }
            else {
                this.pixelStreaming.dispatchEvent(new EventEmitter_1.AfkWarningUpdateEvent({ countDown: this.countDown }));
            }
        }, 1000);
    }
}
exports.AFKController = AFKController;
//# sourceMappingURL=AFKController.js.map