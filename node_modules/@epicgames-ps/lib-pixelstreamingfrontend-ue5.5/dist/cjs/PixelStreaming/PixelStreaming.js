"use strict";
// Copyright Epic Games, Inc. All Rights Reserved.
Object.defineProperty(exports, "__esModule", { value: true });
exports.PixelStreaming = void 0;
const Config_1 = require("../Config/Config");
const WebRtcPlayerController_1 = require("../WebRtcPlayer/WebRtcPlayerController");
const Config_2 = require("../Config/Config");
const lib_pixelstreamingcommon_ue5_5_1 = require("@epicgames-ps/lib-pixelstreamingcommon-ue5.5");
const EventEmitter_1 = require("../Util/EventEmitter");
const WebXRController_1 = require("../WebXR/WebXRController");
const StreamMessageController_1 = require("../UeInstanceMessage/StreamMessageController");
const DataChannelLatencyTestController_1 = require("../DataChannel/DataChannelLatencyTestController");
const RTCUtils_1 = require("../Util/RTCUtils");
const IURLSearchParams_1 = require("../Util/IURLSearchParams");
/**
 * The key class for the browser side of a Pixel Streaming application, it includes:
 * WebRTC handling, XR support, input handling, and emitters for lifetime and state change events.
 * Users are encouraged to use this class as is, through composition, or extend it. In any case,
 * this will likely be the core of your Pixel Streaming experience in terms of functionality.
 */
class PixelStreaming {
    /**
     * @param config - A newly instantiated config object
     * @param overrides - Parameters to override default behaviour
     * returns the base Pixel streaming object
     */
    constructor(config, overrides) {
        this.allowConsoleCommands = false;
        this.config = config;
        if (overrides === null || overrides === void 0 ? void 0 : overrides.videoElementParent) {
            this._videoElementParent = overrides.videoElementParent;
        }
        this._eventEmitter = new EventEmitter_1.PixelStreamingEventEmitter();
        this.configureSettings();
        // setup WebRTC
        this.setWebRtcPlayerController(new WebRtcPlayerController_1.WebRtcPlayerController(this.config, this));
        this._webXrController = new WebXRController_1.WebXRController(this._webRtcController);
        this._setupWebRtcTCPRelayDetection = this._setupWebRtcTCPRelayDetection.bind(this);
        // Add event listener for the webRtcConnected event
        this._eventEmitter.addEventListener('webRtcConnected', (_) => {
            // Bind to the stats received event
            this._eventEmitter.addEventListener('statsReceived', this._setupWebRtcTCPRelayDetection);
        });
    }
    /**
     * Gets the element that contains the video stream element.
     */
    get videoElementParent() {
        if (!this._videoElementParent) {
            this._videoElementParent = document.createElement('div');
            this._videoElementParent.id = 'videoElementParent';
        }
        return this._videoElementParent;
    }
    /**
     * Configure the settings with on change listeners and any additional per experience settings.
     */
    configureSettings() {
        this.config._addOnSettingChangedListener(Config_2.Flags.IsQualityController, (wantsQualityController) => {
            // If the setting has been set to true (either programmatically or the user has flicked the toggle)
            // and we aren't currently quality controller, send the request
            if (wantsQualityController === true && !this._webRtcController.isQualityController) {
                this._webRtcController.sendRequestQualityControlOwnership();
            }
        });
        this.config._addOnSettingChangedListener(Config_2.Flags.AFKDetection, (isAFKEnabled) => {
            this._webRtcController.setAfkEnabled(isAFKEnabled);
        });
        this.config._addOnSettingChangedListener(Config_2.Flags.MatchViewportResolution, () => {
            this._webRtcController.videoPlayer.updateVideoStreamSize();
        });
        this.config._addOnSettingChangedListener(Config_2.Flags.HoveringMouseMode, (isHoveringMouse) => {
            this.config.setFlagLabel(Config_2.Flags.HoveringMouseMode, `Control Scheme: ${isHoveringMouse ? 'Hovering' : 'Locked'} Mouse`);
            this._webRtcController.setMouseInputEnabled(this.config.isFlagEnabled(Config_2.Flags.MouseInput));
        });
        // user input
        this.config._addOnSettingChangedListener(Config_2.Flags.KeyboardInput, (isEnabled) => {
            this._webRtcController.setKeyboardInputEnabled(isEnabled);
        });
        this.config._addOnSettingChangedListener(Config_2.Flags.MouseInput, (isEnabled) => {
            this._webRtcController.setMouseInputEnabled(isEnabled);
        });
        this.config._addOnSettingChangedListener(Config_2.Flags.FakeMouseWithTouches, (_isFakeMouseEnabled) => {
            this._webRtcController.setTouchInputEnabled(this.config.isFlagEnabled(Config_2.Flags.TouchInput));
        });
        this.config._addOnSettingChangedListener(Config_2.Flags.TouchInput, (isEnabled) => {
            this._webRtcController.setTouchInputEnabled(isEnabled);
        });
        this.config._addOnSettingChangedListener(Config_2.Flags.GamepadInput, (isEnabled) => {
            this._webRtcController.setGamePadInputEnabled(isEnabled);
        });
        // direct qp settings
        this.config._addOnNumericSettingChangedListener(Config_2.NumericParameters.MinQP, (newValue) => {
            lib_pixelstreamingcommon_ue5_5_1.Logger.Info('--------  Sending MinQP  --------');
            this._webRtcController.sendEncoderMinQP(newValue);
            lib_pixelstreamingcommon_ue5_5_1.Logger.Info('-------------------------------------------');
            const quality = Math.trunc(100 * (1 - newValue / 51));
            this.config.setNumericSetting(Config_2.NumericParameters.CompatQualityMax, quality);
        });
        this.config._addOnNumericSettingChangedListener(Config_2.NumericParameters.MaxQP, (newValue) => {
            lib_pixelstreamingcommon_ue5_5_1.Logger.Info('--------  Sending MaxQP  --------');
            this._webRtcController.sendEncoderMaxQP(newValue);
            lib_pixelstreamingcommon_ue5_5_1.Logger.Info('-------------------------------------------');
            const quality = Math.trunc(100 * (1 - newValue / 51));
            this.config.setNumericSetting(Config_2.NumericParameters.CompatQualityMin, quality);
        });
        // direct quality factor settings
        this.config._addOnNumericSettingChangedListener(Config_2.NumericParameters.MinQuality, (newValue) => {
            lib_pixelstreamingcommon_ue5_5_1.Logger.Info('--------  Sending MinQuality  --------');
            this._webRtcController.sendEncoderMinQuality(newValue);
            lib_pixelstreamingcommon_ue5_5_1.Logger.Info('-------------------------------------------');
            this.config.setNumericSetting(Config_2.NumericParameters.CompatQualityMin, newValue);
        });
        this.config._addOnNumericSettingChangedListener(Config_2.NumericParameters.MaxQuality, (newValue) => {
            lib_pixelstreamingcommon_ue5_5_1.Logger.Info('--------  Sending MaxQuality  --------');
            this._webRtcController.sendEncoderMaxQuality(newValue);
            lib_pixelstreamingcommon_ue5_5_1.Logger.Info('-------------------------------------------');
            this.config.setNumericSetting(Config_2.NumericParameters.CompatQualityMax, newValue);
        });
        // new quality value that gets scaled to qp for legacy reasons
        this.config._addOnNumericSettingChangedListener(Config_2.NumericParameters.CompatQualityMin, (newValue) => {
            newValue = 51 - (newValue / 100) * 51;
            lib_pixelstreamingcommon_ue5_5_1.Logger.Info('--------  Sending MinQP from quality value  --------');
            this._webRtcController.sendEncoderMaxQP(newValue);
            lib_pixelstreamingcommon_ue5_5_1.Logger.Info('-------------------------------------------');
        });
        this.config._addOnNumericSettingChangedListener(Config_2.NumericParameters.CompatQualityMax, (newValue) => {
            newValue = 51 - (newValue / 100) * 51;
            lib_pixelstreamingcommon_ue5_5_1.Logger.Info('--------  Sending MaxQP from quality value  --------');
            this._webRtcController.sendEncoderMinQP(newValue);
            lib_pixelstreamingcommon_ue5_5_1.Logger.Info('-------------------------------------------');
        });
        // WebRTC settings
        this.config._addOnNumericSettingChangedListener(Config_2.NumericParameters.WebRTCMinBitrate, (newValue) => {
            lib_pixelstreamingcommon_ue5_5_1.Logger.Info('--------  Sending web rtc settings  --------');
            this._webRtcController.sendWebRTCMinBitrate(newValue * 1000 /* kbps to bps */);
            lib_pixelstreamingcommon_ue5_5_1.Logger.Info('-------------------------------------------');
        });
        this.config._addOnNumericSettingChangedListener(Config_2.NumericParameters.WebRTCMaxBitrate, (newValue) => {
            lib_pixelstreamingcommon_ue5_5_1.Logger.Info('--------  Sending web rtc settings  --------');
            this._webRtcController.sendWebRTCMaxBitrate(newValue * 1000 /* kbps to bps */);
            lib_pixelstreamingcommon_ue5_5_1.Logger.Info('-------------------------------------------');
        });
        this.config._addOnNumericSettingChangedListener(Config_2.NumericParameters.WebRTCFPS, (newValue) => {
            lib_pixelstreamingcommon_ue5_5_1.Logger.Info('--------  Sending web rtc settings  --------');
            this._webRtcController.sendWebRTCFps(newValue);
            lib_pixelstreamingcommon_ue5_5_1.Logger.Info('-------------------------------------------');
        });
        this.config._addOnOptionSettingChangedListener(Config_1.OptionParameters.PreferredCodec, (newValue) => {
            if (this._webRtcController) {
                this._webRtcController.setPreferredCodec(newValue);
            }
        });
        this.config._registerOnChangeEvents(this._eventEmitter);
    }
    /**
     * Set the input control ownership
     * @param inputControlOwnership - does the user have input control ownership
     */
    _onInputControlOwnership(inputControlOwnership) {
        this._inputController = inputControlOwnership;
    }
    /**
     * Instantiate the WebRTCPlayerController interface to provide WebRTCPlayerController functionality within this class and set up anything that requires it
     * @param webRtcPlayerController - a WebRtcPlayerController controller instance
     */
    setWebRtcPlayerController(webRtcPlayerController) {
        this._webRtcController = webRtcPlayerController;
        this._webRtcController.setPreferredCodec(this.config.getSettingOption(Config_1.OptionParameters.PreferredCodec).selected);
        this._webRtcController.resizePlayerStyle();
        // connect if auto connect flag is enabled
        this.checkForAutoConnect();
    }
    /**
     * Connect to signaling server.
     */
    connect() {
        this._eventEmitter.dispatchEvent(new EventEmitter_1.StreamPreConnectEvent());
        this._webRtcController.connectToSignallingServer();
    }
    /**
     * Reconnects to the signaling server. If connection is up, disconnects first
     * before establishing a new connection
     */
    reconnect() {
        this._eventEmitter.dispatchEvent(new EventEmitter_1.StreamReconnectEvent());
        this._webRtcController.tryReconnect('Reconnecting...');
    }
    /**
     * Disconnect from the signaling server and close open peer connections.
     */
    disconnect() {
        this._eventEmitter.dispatchEvent(new EventEmitter_1.StreamPreDisconnectEvent());
        this._webRtcController.close();
    }
    /**
     * Play the stream. Can be called only after a peer connection has been established.
     */
    play() {
        this._onStreamLoading();
        this._webRtcController.playStream();
    }
    /**
     * Auto connect if AutoConnect flag is enabled
     */
    checkForAutoConnect() {
        // set up if the auto play will be used or regular click to start
        if (this.config.isFlagEnabled(Config_2.Flags.AutoConnect)) {
            // if autoplaying show an info overlay while while waiting for the connection to begin
            this._onWebRtcAutoConnect();
            this._webRtcController.connectToSignallingServer();
        }
    }
    /**
     * Will unmute the microphone track which is sent to Unreal Engine.
     * By default, will only unmute an existing mic track.
     *
     * @param forceEnable Can be used for cases when this object wasn't initialized with a mic track.
     * If this parameter is true, the connection will be restarted with a microphone.
     * Warning: this takes some time, as a full renegotiation and reconnection will happen.
     */
    unmuteMicrophone(forceEnable = false) {
        // If there's an existing mic track, we just set muted state
        if (this.config.isFlagEnabled('UseMic')) {
            this.setMicrophoneMuted(false);
            return;
        }
        // If there's no pre-existing mic track, and caller is ok with full reset, we enable and reset
        if (forceEnable) {
            this.config.setFlagEnabled('UseMic', true);
            this.reconnect();
            return;
        }
        // If we prefer not to force a reconnection, just warn the user that this operation didn't happen
        lib_pixelstreamingcommon_ue5_5_1.Logger.Warning('Trying to unmute mic, but PixelStreaming was initialized with no microphone track. Call with forceEnable == true to re-connect with a mic track.');
    }
    muteMicrophone() {
        if (this.config.isFlagEnabled('UseMic')) {
            this.setMicrophoneMuted(true);
            return;
        }
        // If there wasn't a mic track, just let user know there's nothing to mute
        lib_pixelstreamingcommon_ue5_5_1.Logger.Info('Trying to mute mic, but PixelStreaming has no microphone track, so sending sound is already disabled.');
    }
    setMicrophoneMuted(mute) {
        var _a, _b, _c, _d;
        for (const transceiver of (_d = (_c = (_b = (_a = this._webRtcController) === null || _a === void 0 ? void 0 : _a.peerConnectionController) === null || _b === void 0 ? void 0 : _b.peerConnection) === null || _c === void 0 ? void 0 : _c.getTransceivers()) !== null && _d !== void 0 ? _d : []) {
            if (RTCUtils_1.RTCUtils.canTransceiverSendAudio(transceiver)) {
                transceiver.sender.track.enabled = !mute;
            }
        }
    }
    /**
     * Will unmute the video track which is sent to Unreal Engine.
     * By default, will only unmute an existing video track.
     *
     * @param forceEnable Can be used for cases when this object wasn't initialized with a video track.
     * If this parameter is true, the connection will be restarted with a camera.
     * Warning: this takes some time, as a full renegotiation and reconnection will happen.
     */
    unmuteCamera(forceEnable = false) {
        // If there's an existing video track, we just set muted state
        if (this.config.isFlagEnabled('UseCamera')) {
            this.setCameraMuted(false);
            return;
        }
        // If there's no pre-existing video track, and caller is ok with full reset, we enable and reset
        if (forceEnable) {
            this.config.setFlagEnabled('UseCamera', true);
            this.reconnect();
            return;
        }
        // If we prefer not to force a reconnection, just warn the user that this operation didn't happen
        lib_pixelstreamingcommon_ue5_5_1.Logger.Warning('Trying to unmute video, but PixelStreaming was initialized with no video track. Call with forceEnable == true to re-connect with a video track.');
    }
    muteCamera() {
        if (this.config.isFlagEnabled('UseCamera')) {
            this.setCameraMuted(true);
            return;
        }
        // If there wasn't a mic track, just let user know there's nothing to mute
        lib_pixelstreamingcommon_ue5_5_1.Logger.Info('Trying to mute camera, but PixelStreaming has no video track, so sending video is already disabled.');
    }
    setCameraMuted(mute) {
        var _a, _b, _c, _d;
        for (const transceiver of (_d = (_c = (_b = (_a = this._webRtcController) === null || _a === void 0 ? void 0 : _a.peerConnectionController) === null || _b === void 0 ? void 0 : _b.peerConnection) === null || _c === void 0 ? void 0 : _c.getTransceivers()) !== null && _d !== void 0 ? _d : []) {
            if (RTCUtils_1.RTCUtils.canTransceiverSendVideo(transceiver)) {
                transceiver.sender.track.enabled = !mute;
            }
        }
    }
    /**
     * Internal function to emit an event when auto connecting occurs
     */
    _onWebRtcAutoConnect() {
        this._eventEmitter.dispatchEvent(new EventEmitter_1.WebRtcAutoConnectEvent());
    }
    /**
     * Internal function to emit an event for when SDP negotiation is fully finished.
     */
    _onWebRtcSdp() {
        this._eventEmitter.dispatchEvent(new EventEmitter_1.WebRtcSdpEvent());
    }
    /**
     * Internal function to emit an SDP offer after it has been set.
     */
    _onWebRtcSdpOffer(offer) {
        this._eventEmitter.dispatchEvent(new EventEmitter_1.WebRtcSdpOfferEvent({ sdp: offer }));
    }
    /**
     * Internal function to emit an SDP answer after it has been set.
     */
    _onWebRtcSdpAnswer(answer) {
        this._eventEmitter.dispatchEvent(new EventEmitter_1.WebRtcSdpAnswerEvent({ sdp: answer }));
    }
    /**
     * Internal function call to emit a `latencyCalculated` event.
     */
    _onLatencyCalculated(latencyInfo) {
        this._eventEmitter.dispatchEvent(new EventEmitter_1.LatencyCalculatedEvent({ latencyInfo }));
    }
    /**
     * Internal function to emits a StreamLoading event
     */
    _onStreamLoading() {
        this._eventEmitter.dispatchEvent(new EventEmitter_1.StreamLoadingEvent());
    }
    /**
     * Event fired when the video is disconnected - emits given eventString or an override
     * message from webRtcController if one has been set
     * @param eventString - a string describing why the connection closed
     * @param allowClickToReconnect - true if we want to allow the user to retry the connection with a click
     */
    _onDisconnect(eventString, allowClickToReconnect) {
        this._eventEmitter.dispatchEvent(new EventEmitter_1.WebRtcDisconnectedEvent({
            eventString: eventString,
            allowClickToReconnect: allowClickToReconnect
        }));
    }
    /**
     * Handles when Web Rtc is connecting
     */
    _onWebRtcConnecting() {
        this._eventEmitter.dispatchEvent(new EventEmitter_1.WebRtcConnectingEvent());
    }
    /**
     * Handles when Web Rtc has connected
     */
    _onWebRtcConnected() {
        this._eventEmitter.dispatchEvent(new EventEmitter_1.WebRtcConnectedEvent());
    }
    /**
     * Handles when Web Rtc fails to connect
     */
    _onWebRtcFailed() {
        this._eventEmitter.dispatchEvent(new EventEmitter_1.WebRtcFailedEvent());
    }
    /**
     * Handle when the Video has been Initialized
     */
    _onVideoInitialized() {
        this._eventEmitter.dispatchEvent(new EventEmitter_1.VideoInitializedEvent());
        this._videoStartTime = Date.now();
    }
    /**
     * Set up functionality to happen when receiving latency test results
     * @param latency - latency test results object
     */
    _onLatencyTestResult(latencyTimings) {
        this._eventEmitter.dispatchEvent(new EventEmitter_1.LatencyTestResultEvent({ latencyTimings }));
    }
    _onDataChannelLatencyTestResponse(response) {
        this._eventEmitter.dispatchEvent(new EventEmitter_1.DataChannelLatencyTestResponseEvent({ response }));
    }
    /**
     * Set up functionality to happen when receiving video statistics
     * @param videoStats - video statistics as a aggregate stats object
     */
    _onVideoStats(videoStats) {
        // Duration
        if (!this._videoStartTime || this._videoStartTime === undefined) {
            this._videoStartTime = Date.now();
        }
        videoStats.handleSessionStatistics(this._videoStartTime, this._inputController, this._webRtcController.videoAvgQp);
        this._eventEmitter.dispatchEvent(new EventEmitter_1.StatsReceivedEvent({ aggregatedStats: videoStats }));
    }
    /**
     * Set up functionality to happen when calculating the average video encoder qp
     * @param QP - the quality number of the stream
     */
    _onVideoEncoderAvgQP(QP) {
        this._eventEmitter.dispatchEvent(new EventEmitter_1.VideoEncoderAvgQPEvent({ avgQP: QP }));
    }
    /**
     * Set up functionality to happen when receiving and handling initial settings for the UE app
     * @param settings - initial UE app settings
     */
    _onInitialSettings(settings) {
        var _a;
        this._eventEmitter.dispatchEvent(new EventEmitter_1.InitialSettingsEvent({ settings }));
        if (settings.PixelStreamingSettings) {
            this.allowConsoleCommands = (_a = settings.PixelStreamingSettings.AllowPixelStreamingCommands) !== null && _a !== void 0 ? _a : false;
            if (this.allowConsoleCommands === false) {
                lib_pixelstreamingcommon_ue5_5_1.Logger.Info('-AllowPixelStreamingCommands=false, sending arbitrary console commands from browser to UE is disabled.');
            }
        }
        const useUrlParams = this.config.useUrlParams;
        const urlParams = new IURLSearchParams_1.IURLSearchParams(window.location.search);
        lib_pixelstreamingcommon_ue5_5_1.Logger.Info(`using URL parameters ${useUrlParams}`);
        if (settings.EncoderSettings) {
            // here we should either get Min/MaxQP from PS1
            // or Min/MaxQuality from PS2
            // we only want to set one set or the other as they converge in CompatQualityMin/Max and
            // we dont want to have them conflict with default values.
            if (settings.EncoderSettings.MinQP) {
                this.config.setNumericSetting(Config_2.NumericParameters.MinQP, 
                // If a setting is set in the URL, make sure we respect that value as opposed to what the application sends us
                useUrlParams && urlParams.has(Config_2.NumericParameters.MinQP)
                    ? Number.parseFloat(urlParams.get(Config_2.NumericParameters.MinQP))
                    : settings.EncoderSettings.MinQP || 0);
                this.config.setNumericSetting(Config_2.NumericParameters.MaxQP, useUrlParams && urlParams.has(Config_2.NumericParameters.MaxQP)
                    ? Number.parseFloat(urlParams.get(Config_2.NumericParameters.MaxQP))
                    : settings.EncoderSettings.MaxQP || 51);
            }
            if (settings.EncoderSettings.MinQuality) {
                this.config.setNumericSetting(Config_2.NumericParameters.MinQuality, 
                // If a setting is set in the URL, make sure we respect that value as opposed to what the application sends us
                useUrlParams && urlParams.has(Config_2.NumericParameters.MinQuality)
                    ? Number.parseFloat(urlParams.get(Config_2.NumericParameters.MinQuality))
                    : settings.EncoderSettings.MinQuality || 0);
                this.config.setNumericSetting(Config_2.NumericParameters.MaxQuality, useUrlParams && urlParams.has(Config_2.NumericParameters.MaxQuality)
                    ? Number.parseFloat(urlParams.get(Config_2.NumericParameters.MaxQuality))
                    : settings.EncoderSettings.MaxQuality || 100);
            }
            // these two are just used to converge quality and qp and behave slightly differently since they
            // shouldnt exist in EncoderSettings
            if (useUrlParams) {
                if (urlParams.has(Config_2.NumericParameters.CompatQualityMin)) {
                    this.config.setNumericSetting(Config_2.NumericParameters.CompatQualityMin, Number.parseFloat(urlParams.get(Config_2.NumericParameters.CompatQualityMin)));
                }
                if (urlParams.has(Config_2.NumericParameters.CompatQualityMax)) {
                    this.config.setNumericSetting(Config_2.NumericParameters.CompatQualityMax, Number.parseFloat(urlParams.get(Config_2.NumericParameters.CompatQualityMax)));
                }
            }
        }
        if (settings.WebRTCSettings) {
            this.config.setNumericSetting(Config_2.NumericParameters.WebRTCMinBitrate, useUrlParams && urlParams.has(Config_2.NumericParameters.WebRTCMinBitrate)
                ? Number.parseFloat(urlParams.get(Config_2.NumericParameters.WebRTCMinBitrate))
                : settings.WebRTCSettings.MinBitrate / 1000 /* bps to kbps */);
            this.config.setNumericSetting(Config_2.NumericParameters.WebRTCMaxBitrate, useUrlParams && urlParams.has(Config_2.NumericParameters.WebRTCMaxBitrate)
                ? Number.parseFloat(urlParams.get(Config_2.NumericParameters.WebRTCMaxBitrate))
                : settings.WebRTCSettings.MaxBitrate / 1000 /* bps to kbps */);
            this.config.setNumericSetting(Config_2.NumericParameters.WebRTCFPS, useUrlParams && urlParams.has(Config_2.NumericParameters.WebRTCFPS)
                ? Number.parseFloat(urlParams.get(Config_2.NumericParameters.WebRTCFPS))
                : settings.WebRTCSettings.FPS);
        }
    }
    /**
     * Set up functionality to happen when setting quality control ownership of a stream
     * @param hasQualityOwnership - does this user have quality ownership of the stream true / false
     */
    _onQualityControlOwnership(hasQualityOwnership) {
        this.config.setFlagEnabled(Config_2.Flags.IsQualityController, hasQualityOwnership);
    }
    _onPlayerCount(playerCount) {
        this._eventEmitter.dispatchEvent(new EventEmitter_1.PlayerCountEvent({ count: playerCount }));
    }
    _onSubscribeFailed(message) {
        this._eventEmitter.dispatchEvent(new EventEmitter_1.SubscribeFailedEvent({ message: message }));
    }
    // Sets up to emit the webrtc tcp relay detect event
    _setupWebRtcTCPRelayDetection(statsReceivedEvent) {
        // Get the active candidate pair
        const activeCandidatePair = statsReceivedEvent.data.aggregatedStats.getActiveCandidatePair();
        // Check if the active candidate pair is not null
        if (activeCandidatePair != null) {
            // Get the local candidate assigned to the active candidate pair
            const localCandidate = statsReceivedEvent.data.aggregatedStats.localCandidates.find((candidate) => candidate.id == activeCandidatePair.localCandidateId, null);
            // Check if the local candidate is not null, candidate type is relay and the relay protocol is tcp
            if (localCandidate != null &&
                localCandidate.candidateType == 'relay' &&
                localCandidate.relayProtocol == 'tcp') {
                // Send the web rtc tcp relay detected event
                this._eventEmitter.dispatchEvent(new EventEmitter_1.WebRtcTCPRelayDetectedEvent());
            }
            // The check is completed and the stats listen event can be removed
            this._eventEmitter.removeEventListener('statsReceived', this._setupWebRtcTCPRelayDetection);
        }
    }
    /**
     * Request a connection latency test.
     * NOTE: There are plans to refactor all request* functions. Expect changes if you use this!
     * @returns
     */
    requestLatencyTest() {
        if (!this._webRtcController.videoPlayer.isVideoReady()) {
            return false;
        }
        this._webRtcController.sendLatencyTest();
        return true;
    }
    /**
     * Request a data channel latency test.
     * NOTE: There are plans to refactor all request* functions. Expect changes if you use this!
     */
    requestDataChannelLatencyTest(config) {
        if (!this._webRtcController.videoPlayer.isVideoReady()) {
            return false;
        }
        if (!this._dataChannelLatencyTestController) {
            this._dataChannelLatencyTestController = new DataChannelLatencyTestController_1.DataChannelLatencyTestController(this._webRtcController.sendDataChannelLatencyTest.bind(this._webRtcController), (result) => {
                this._eventEmitter.dispatchEvent(new EventEmitter_1.DataChannelLatencyTestResultEvent({ result }));
            });
            this.addEventListener('dataChannelLatencyTestResponse', ({ data: { response } }) => {
                this._dataChannelLatencyTestController.receive(response);
            });
        }
        return this._dataChannelLatencyTestController.start(config);
    }
    /**
     * Request for the UE application to show FPS counter.
     * NOTE: There are plans to refactor all request* functions. Expect changes if you use this!
     * @returns
     */
    requestShowFps() {
        if (!this._webRtcController.videoPlayer.isVideoReady()) {
            return false;
        }
        this._webRtcController.sendShowFps();
        return true;
    }
    /**
     * Request for a new IFrame from the UE application.
     * NOTE: There are plans to refactor all request* functions. Expect changes if you use this!
     * @returns
     */
    requestIframe() {
        if (!this._webRtcController.videoPlayer.isVideoReady()) {
            return false;
        }
        this._webRtcController.sendIframeRequest();
        return true;
    }
    /**
     * Send data to UE application. The data will be run through JSON.stringify() so e.g. strings
     * and any serializable plain JSON objects with no recurrence can be sent.
     * @returns true if succeeded, false if rejected
     */
    emitUIInteraction(descriptor) {
        if (!this._webRtcController.videoPlayer.isVideoReady()) {
            return false;
        }
        this._webRtcController.emitUIInteraction(descriptor);
        return true;
    }
    /**
     * Send a command to UE application. Blocks ConsoleCommand descriptors unless UE
     * has signaled that it allows console commands.
     * @returns true if succeeded, false if rejected
     */
    emitCommand(descriptor) {
        if (!this._webRtcController.videoPlayer.isVideoReady()) {
            return false;
        }
        if (!this.allowConsoleCommands && 'ConsoleCommand' in descriptor) {
            return false;
        }
        this._webRtcController.emitCommand(descriptor);
        return true;
    }
    /**
     * Send a console command to UE application. Only allowed if UE has signaled that it allows
     * console commands.
     * @returns true if succeeded, false if rejected
     */
    emitConsoleCommand(command) {
        if (!this.allowConsoleCommands || !this._webRtcController.videoPlayer.isVideoReady()) {
            return false;
        }
        this._webRtcController.emitConsoleCommand(command);
        return true;
    }
    /**
     * Sets the text contents of the currently focused UE text box widget.
     * @param contents The new contents of the UE text box.
     * @returns True if the message could be sent.
     */
    sendTextboxEntry(contents) {
        if (!this._webRtcController.videoPlayer.isVideoReady()) {
            return false;
        }
        this._webRtcController.sendTextboxEntry(contents);
        return true;
    }
    /**
     * Add a UE -> browser response event listener
     * @param name - The name of the response handler
     * @param listener - The method to be activated when a message is received
     */
    addResponseEventListener(name, listener) {
        this._webRtcController.responseController.addResponseEventListener(name, listener);
    }
    /**
     * Remove a UE -> browser response event listener
     * @param name - The name of the response handler
     */
    removeResponseEventListener(name) {
        this._webRtcController.responseController.removeResponseEventListener(name);
    }
    /**
     * Dispatch a new event.
     * @param e event
     * @returns
     */
    dispatchEvent(e) {
        return this._eventEmitter.dispatchEvent(e);
    }
    /**
     * Register an event handler.
     * @param type event name
     * @param listener event handler function
     */
    addEventListener(type, listener) {
        this._eventEmitter.addEventListener(type, listener);
    }
    /**
     * Remove an event handler.
     * @param type event name
     * @param listener event handler function
     */
    removeEventListener(type, listener) {
        this._eventEmitter.removeEventListener(type, listener);
    }
    /**
     * Enable/disable XR mode.
     */
    toggleXR() {
        this.webXrController.xrClicked();
    }
    /**
     * Pass in a function to generate a signalling server URL.
     * This function is useful if you need to programmatically construct your signalling server URL.
     * @param signallingUrlBuilderFunc A function that generates a signalling server url.
     */
    setSignallingUrlBuilder(signallingUrlBuilderFunc) {
        this._webRtcController.signallingUrlBuilder = signallingUrlBuilderFunc;
    }
    get webRtcController() {
        return this._webRtcController;
    }
    /**
     * Public getter for the websocket controller. Access to this property allows you to send
     * custom websocket messages.
     */
    get signallingProtocol() {
        return this._webRtcController.protocol;
    }
    /**
     * Public getter for the webXrController controller. Used for all XR features.
     */
    get webXrController() {
        return this._webXrController;
    }
    registerMessageHandler(name, direction, handler) {
        if (direction === StreamMessageController_1.MessageDirection.FromStreamer && typeof handler === 'undefined') {
            lib_pixelstreamingcommon_ue5_5_1.Logger.Warning(`Unable to register an undefined handler for ${name}`);
            return;
        }
        if (direction === StreamMessageController_1.MessageDirection.ToStreamer && typeof handler === 'undefined') {
            this._webRtcController.streamMessageController.registerMessageHandler(direction, name, (data) => this._webRtcController.sendMessageController.sendMessageToStreamer(name, data));
        }
        else {
            this._webRtcController.streamMessageController.registerMessageHandler(direction, name, (data) => handler(data));
        }
    }
    get toStreamerHandlers() {
        return this._webRtcController.streamMessageController.toStreamerHandlers;
    }
    isReconnecting() {
        return this._webRtcController.isReconnecting;
    }
}
exports.PixelStreaming = PixelStreaming;
//# sourceMappingURL=PixelStreaming.js.map