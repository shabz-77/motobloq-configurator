"use strict";
// Copyright Epic Games, Inc. All Rights Reserved.
Object.defineProperty(exports, "__esModule", { value: true });
exports.AggregatedStats = void 0;
const InboundRTPStats_1 = require("./InboundRTPStats");
const DataChannelStats_1 = require("./DataChannelStats");
const CandidateStat_1 = require("./CandidateStat");
const OutBoundRTPStats_1 = require("./OutBoundRTPStats");
const SessionStats_1 = require("./SessionStats");
const StreamStats_1 = require("./StreamStats");
const lib_pixelstreamingcommon_ue5_5_1 = require("@epicgames-ps/lib-pixelstreamingcommon-ue5.5");
/**
 * The Aggregated Stats that is generated from the RTC Stats Report
 */
class AggregatedStats {
    constructor() {
        this.inboundVideoStats = new InboundRTPStats_1.InboundVideoStats();
        this.inboundAudioStats = new InboundRTPStats_1.InboundAudioStats();
        this.datachannelStats = new DataChannelStats_1.DataChannelStats();
        this.outboundVideoStats = new OutBoundRTPStats_1.OutboundRTPStats();
        this.outboundAudioStats = new OutBoundRTPStats_1.OutboundRTPStats();
        this.remoteOutboundAudioStats = new OutBoundRTPStats_1.RemoteOutboundRTPStats();
        this.remoteOutboundVideoStats = new OutBoundRTPStats_1.RemoteOutboundRTPStats();
        this.sessionStats = new SessionStats_1.SessionStats();
        this.streamStats = new StreamStats_1.StreamStats();
        this.codecs = new Map();
    }
    /**
     * Gather all the information from the RTC Peer Connection Report
     * @param rtcStatsReport - RTC Stats Report
     */
    processStats(rtcStatsReport) {
        this.localCandidates = new Array();
        this.remoteCandidates = new Array();
        this.candidatePairs = new Array();
        rtcStatsReport.forEach((stat) => {
            const type = stat.type;
            switch (type) {
                case 'candidate-pair':
                    this.handleCandidatePair(stat);
                    break;
                case 'certificate':
                    break;
                case 'codec':
                    this.handleCodec(stat);
                    break;
                case 'data-channel':
                    this.handleDataChannel(stat);
                    break;
                case 'inbound-rtp':
                    this.handleInboundRTP(stat);
                    break;
                case 'local-candidate':
                    this.handleLocalCandidate(stat);
                    break;
                case 'media-source':
                    break;
                case 'media-playout':
                    break;
                case 'outbound-rtp':
                    this.handleLocalOutbound(stat);
                    break;
                case 'peer-connection':
                    break;
                case 'remote-candidate':
                    this.handleRemoteCandidate(stat);
                    break;
                case 'remote-inbound-rtp':
                    break;
                case 'remote-outbound-rtp':
                    this.handleRemoteOutbound(stat);
                    break;
                case 'track':
                    this.handleTrack(stat);
                    break;
                case 'transport':
                    this.handleTransport(stat);
                    break;
                case 'stream':
                    this.handleStream(stat);
                    break;
                default:
                    lib_pixelstreamingcommon_ue5_5_1.Logger.Error('unhandled Stat Type');
                    lib_pixelstreamingcommon_ue5_5_1.Logger.Info(stat);
                    break;
            }
        });
    }
    /**
     * Process stream stats data from webrtc
     *
     * @param stat - the stats coming in from webrtc
     */
    handleStream(stat) {
        this.streamStats = stat;
    }
    /**
     * Process the Ice Candidate Pair Data
     * @param stat - the stats coming in from ice candidates
     */
    handleCandidatePair(stat) {
        // Add the candidate pair to the candidate pair array
        this.candidatePairs.push(stat);
    }
    /**
     * Process the Data Channel Data
     * @param stat - the stats coming in from the data channel
     */
    handleDataChannel(stat) {
        this.datachannelStats.bytesReceived = stat.bytesReceived;
        this.datachannelStats.bytesSent = stat.bytesSent;
        this.datachannelStats.dataChannelIdentifier = stat.dataChannelIdentifier;
        this.datachannelStats.id = stat.id;
        this.datachannelStats.label = stat.label;
        this.datachannelStats.messagesReceived = stat.messagesReceived;
        this.datachannelStats.messagesSent = stat.messagesSent;
        this.datachannelStats.protocol = stat.protocol;
        this.datachannelStats.state = stat.state;
        this.datachannelStats.timestamp = stat.timestamp;
    }
    /**
     * Process the Local Ice Candidate Data
     * @param stat - local stats
     */
    handleLocalCandidate(stat) {
        const localCandidate = new CandidateStat_1.CandidateStat();
        localCandidate.label = 'local-candidate';
        localCandidate.address = stat.address;
        localCandidate.port = stat.port;
        localCandidate.protocol = stat.protocol;
        localCandidate.candidateType = stat.candidateType;
        localCandidate.id = stat.id;
        localCandidate.relayProtocol = stat.relayProtocol;
        localCandidate.transportId = stat.transportId;
        this.localCandidates.push(localCandidate);
    }
    /**
     * Process the Remote Ice Candidate Data
     * @param stat - ice candidate stats
     */
    handleRemoteCandidate(stat) {
        const remoteCandidate = new CandidateStat_1.CandidateStat();
        remoteCandidate.label = 'remote-candidate';
        remoteCandidate.address = stat.address;
        remoteCandidate.port = stat.port;
        remoteCandidate.protocol = stat.protocol;
        remoteCandidate.id = stat.id;
        remoteCandidate.candidateType = stat.candidateType;
        remoteCandidate.relayProtocol = stat.relayProtocol;
        remoteCandidate.transportId = stat.transportId;
        this.remoteCandidates.push(remoteCandidate);
    }
    /**
     * Process the Inbound RTP Audio and Video Data
     * @param stat - inbound rtp stats
     */
    handleInboundRTP(stat) {
        switch (stat.kind) {
            case 'video':
                // Calculate bitrate between stat updates
                if (stat.bytesReceived > this.inboundVideoStats.bytesReceived &&
                    stat.timestamp > this.inboundVideoStats.timestamp) {
                    this.inboundVideoStats.bitrate =
                        (8 * (stat.bytesReceived - this.inboundVideoStats.bytesReceived)) /
                            (stat.timestamp - this.inboundVideoStats.timestamp);
                    this.inboundVideoStats.bitrate = Math.floor(this.inboundVideoStats.bitrate);
                }
                // Copy members from stat into `this.inboundVideoStats`
                for (const key in stat) {
                    this.inboundVideoStats[key] = stat[key];
                }
                break;
            case 'audio':
                if (stat.bytesReceived > this.inboundAudioStats.bytesReceived &&
                    stat.timestamp > this.inboundAudioStats.timestamp) {
                    this.inboundAudioStats.bitrate =
                        (8 * (stat.bytesReceived - this.inboundAudioStats.bytesReceived)) /
                            (stat.timestamp - this.inboundAudioStats.timestamp);
                    this.inboundAudioStats.bitrate = Math.floor(this.inboundAudioStats.bitrate);
                }
                // Copy members from stat into `this.inboundAudioStats`
                for (const key in stat) {
                    this.inboundAudioStats[key] = stat[key];
                }
                break;
            default:
                lib_pixelstreamingcommon_ue5_5_1.Logger.Error(`Kind should be audio or video, we got ${stat.kind} - that's unsupported.`);
                break;
        }
    }
    /**
     * Process the "local" outbound RTP Audio and Video stats.
     * @param stat - local outbound rtp stats
     */
    handleLocalOutbound(stat) {
        const localOutboundStats = stat.kind === 'audio' ? this.outboundAudioStats : this.outboundVideoStats;
        localOutboundStats.active = stat.active;
        localOutboundStats.codecId = stat.codecId;
        localOutboundStats.bytesSent = stat.bytesSent;
        localOutboundStats.frameHeight = stat.frameHeight;
        localOutboundStats.frameWidth = stat.frameWidth;
        localOutboundStats.framesEncoded = stat.framesEncoded;
        localOutboundStats.framesPerSecond = stat.framesPerSecond;
        localOutboundStats.headerBytesSent = stat.headerBytesSent;
        localOutboundStats.id = stat.id;
        localOutboundStats.keyFramesEncoded = stat.keyFramesEncoded;
        localOutboundStats.kind = stat.kind;
        localOutboundStats.mediaSourceId = stat.mediaSourceId;
        localOutboundStats.mid = stat.mid;
        localOutboundStats.nackCount = stat.nackCount;
        localOutboundStats.packetsSent = stat.packetsSent;
        localOutboundStats.qpSum = stat.qpSum;
        localOutboundStats.qualityLimitationDurations = stat.qualityLimitationDurations;
        localOutboundStats.qualityLimitationReason = stat.qualityLimitationReason;
        localOutboundStats.remoteId = stat.remoteId;
        localOutboundStats.retransmittedBytesSent = stat.retransmittedBytesSent;
        localOutboundStats.rid = stat.rid;
        localOutboundStats.scalabilityMode = stat.scalabilityMode;
        localOutboundStats.ssrc = stat.ssrc;
        localOutboundStats.targetBitrate = stat.targetBitrate;
        localOutboundStats.timestamp = stat.timestamp;
        localOutboundStats.totalEncodeTime = stat.totalEncodeTime;
        localOutboundStats.totalEncodeBytesTarget = stat.totalEncodeBytesTarget;
        localOutboundStats.totalPacketSendDelay = stat.totalPacketSendDelay;
        localOutboundStats.transportId = stat.transportId;
    }
    /**
     * Process the "remote" outbound RTP Audio and Video stats.
     * @param stat - remote outbound rtp stats
     */
    handleRemoteOutbound(stat) {
        const remoteOutboundStats = stat.kind === 'audio' ? this.remoteOutboundAudioStats : this.remoteOutboundVideoStats;
        remoteOutboundStats.bytesSent = stat.bytesSent;
        remoteOutboundStats.codecId = stat.codecId;
        remoteOutboundStats.id = stat.id;
        remoteOutboundStats.kind = stat.kind;
        remoteOutboundStats.localId = stat.localId;
        remoteOutboundStats.packetsSent = stat.packetsSent;
        remoteOutboundStats.remoteTimestamp = stat.remoteTimestamp;
        remoteOutboundStats.reportsSent = stat.reportsSent;
        remoteOutboundStats.roundTripTimeMeasurements = stat.roundTripTimeMeasurements;
        remoteOutboundStats.ssrc = stat.ssrc;
        remoteOutboundStats.timestamp = stat.timestamp;
        remoteOutboundStats.totalRoundTripTime = stat.totalRoundTripTime;
        remoteOutboundStats.transportId = stat.transportId;
    }
    /**
     * Process the Inbound Video Track Data
     * @param stat - video track stats
     */
    handleTrack(stat) {
        // we only want to extract stats from the video track
        if (stat.type === 'track' && (stat.trackIdentifier === 'video_label' || stat.kind === 'video')) {
            this.inboundVideoStats.framesDropped = stat.framesDropped;
            this.inboundVideoStats.framesReceived = stat.framesReceived;
            this.inboundVideoStats.frameHeight = stat.frameHeight;
            this.inboundVideoStats.frameWidth = stat.frameWidth;
        }
    }
    handleTransport(stat) {
        this.transportStats = stat;
    }
    handleCodec(stat) {
        const codecId = stat.id;
        this.codecs.set(codecId, stat);
    }
    handleSessionStatistics(videoStartTime, inputController, videoEncoderAvgQP) {
        const deltaTime = Date.now() - videoStartTime;
        this.sessionStats.runTime = new Date(deltaTime).toISOString().substr(11, 8).toString();
        const controlsStreamInput = inputController === null ? 'Not sent yet' : inputController ? 'true' : 'false';
        this.sessionStats.controlsStreamInput = controlsStreamInput;
        this.sessionStats.videoEncoderAvgQP = videoEncoderAvgQP;
    }
    /**
     * Check if a value coming in from our stats is actually a number
     * @param value - the number to be checked
     */
    isNumber(value) {
        return typeof value === 'number' && isFinite(value);
    }
    /**
     * Helper function to return the active candidate pair
     * @returns The candidate pair that is currently receiving data
     */
    getActiveCandidatePair() {
        if (this.candidatePairs === undefined) {
            return null;
        }
        // Check if the RTCTransport stat is not undefined
        if (this.transportStats) {
            // Return the candidate pair that matches the transport candidate pair id
            const selectedPair = this.candidatePairs.find((candidatePair) => candidatePair.id === this.transportStats.selectedCandidatePairId);
            if (selectedPair === undefined) {
                return null;
            }
            else {
                return selectedPair;
            }
        }
        // Fall back to the `.selected` member of the candidate pair
        const selectedPair = this.candidatePairs.find((candidatePair) => candidatePair.selected);
        if (selectedPair === undefined) {
            return null;
        }
        else {
            return selectedPair;
        }
    }
}
exports.AggregatedStats = AggregatedStats;
//# sourceMappingURL=AggregatedStats.js.map