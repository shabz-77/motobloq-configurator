"use strict";
// Copyright Epic Games, Inc. All Rights Reserved.
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebRtcPlayerController = void 0;
const lib_pixelstreamingcommon_ue5_5_1 = require("@epicgames-ps/lib-pixelstreamingcommon-ue5.5");
const StreamController_1 = require("../VideoPlayer/StreamController");
const FreezeFrameController_1 = require("../FreezeFrame/FreezeFrameController");
const AFKController_1 = require("../AFK/AFKController");
const DataChannelController_1 = require("../DataChannel/DataChannelController");
const PeerConnectionController_1 = require("../PeerConnectionController/PeerConnectionController");
const Config_1 = require("../Config/Config");
const InitialSettings_1 = require("../DataChannel/InitialSettings");
const LatencyTestResults_1 = require("../DataChannel/LatencyTestResults");
const FileUtil_1 = require("../Util/FileUtil");
const InputClassesFactory_1 = require("../Inputs/InputClassesFactory");
const VideoPlayer_1 = require("../VideoPlayer/VideoPlayer");
const StreamMessageController_1 = require("../UeInstanceMessage/StreamMessageController");
const ResponseController_1 = require("../UeInstanceMessage/ResponseController");
const SendMessageController_1 = require("../UeInstanceMessage/SendMessageController");
const ToStreamerMessagesController_1 = require("../UeInstanceMessage/ToStreamerMessagesController");
const DataChannelSender_1 = require("../DataChannel/DataChannelSender");
const InputCoordTranslator_1 = require("../Util/InputCoordTranslator");
const EventEmitter_1 = require("../Util/EventEmitter");
const IURLSearchParams_1 = require("../Util/IURLSearchParams");
const BrowserUtils_1 = require("../Util/BrowserUtils");
/**
 * Entry point for the WebRTC Player
 */
class WebRtcPlayerController {
    /**
     *
     * @param config - the frontend config object
     * @param pixelStreaming - the PixelStreaming object
     */
    constructor(config, pixelStreaming) {
        this.shouldShowPlayOverlay = true;
        this.autoJoinTimer = undefined;
        this.config = config;
        this.pixelStreaming = pixelStreaming;
        this.responseController = new ResponseController_1.ResponseController();
        this.file = new FileUtil_1.FileTemplate();
        this.sdpConstraints = {
            offerToReceiveAudio: true,
            offerToReceiveVideo: true
        };
        // set up the afk logic class and connect up its method for closing the signaling server
        this.afkController = new AFKController_1.AFKController(this.config, this.pixelStreaming, this.onAfkTriggered.bind(this));
        this.afkController.onAFKTimedOutCallback = () => {
            this.closeSignalingServer('You have been disconnected due to inactivity.', false);
        };
        this.freezeFrameController = new FreezeFrameController_1.FreezeFrameController(this.pixelStreaming.videoElementParent);
        this.videoPlayer = new VideoPlayer_1.VideoPlayer(this.pixelStreaming.videoElementParent, this.config);
        this.videoPlayer.onVideoInitialized = () => this.handleVideoInitialized();
        // When in match viewport resolution mode, when the browser viewport is resized we send a resize command back to UE.
        this.videoPlayer.onMatchViewportResolutionCallback = (width, height) => {
            const descriptor = {
                'Resolution.Width': width,
                'Resolution.Height': height
            };
            this.streamMessageController.toStreamerHandlers.get('Command')([JSON.stringify(descriptor)]);
        };
        // Every time video player is resized in browser we need to reinitialize the mouse coordinate conversion and freeze frame sizing logic.
        this.videoPlayer.onResizePlayerCallback = () => {
            this.setUpMouseAndFreezeFrame();
        };
        this.streamController = new StreamController_1.StreamController(this.videoPlayer);
        this.coordinateConverter = new InputCoordTranslator_1.InputCoordTranslator();
        this.sendrecvDataChannelController = new DataChannelController_1.DataChannelController();
        this.recvDataChannelController = new DataChannelController_1.DataChannelController();
        this.registerDataChannelEventEmitters(this.sendrecvDataChannelController);
        this.registerDataChannelEventEmitters(this.recvDataChannelController);
        this.dataChannelSender = new DataChannelSender_1.DataChannelSender(this.sendrecvDataChannelController);
        this.dataChannelSender.resetAfkWarningTimerOnDataSend = () => this.afkController.resetAfkWarningTimer();
        this.streamMessageController = new StreamMessageController_1.StreamMessageController();
        // set up websocket methods
        this.transport = new lib_pixelstreamingcommon_ue5_5_1.WebSocketTransport(config.webSocketProtocols);
        this.protocol = new lib_pixelstreamingcommon_ue5_5_1.SignallingProtocol(this.transport);
        this.protocol.addListener(lib_pixelstreamingcommon_ue5_5_1.Messages.config.typeName, (msg) => this.handleOnConfigMessage(msg));
        this.protocol.addListener(lib_pixelstreamingcommon_ue5_5_1.Messages.ping.typeName, (msg) => this.handlePingMessage(msg));
        this.protocol.addListener(lib_pixelstreamingcommon_ue5_5_1.Messages.streamerList.typeName, (msg) => this.handleStreamerListMessage(msg));
        this.protocol.addListener(lib_pixelstreamingcommon_ue5_5_1.Messages.subscribeFailed.typeName, (msg) => this.handleSubscribeFailedMessage(msg));
        this.protocol.addListener(lib_pixelstreamingcommon_ue5_5_1.Messages.streamerIdChanged.typeName, (msg) => this.handleStreamerIDChangedMessage(msg));
        this.protocol.addListener(lib_pixelstreamingcommon_ue5_5_1.Messages.playerCount.typeName, (msg) => {
            const playerCountMessage = msg;
            this.pixelStreaming._onPlayerCount(playerCountMessage.count);
        });
        this.protocol.addListener(lib_pixelstreamingcommon_ue5_5_1.Messages.answer.typeName, (msg) => this.handleWebRtcAnswer(msg));
        this.protocol.addListener(lib_pixelstreamingcommon_ue5_5_1.Messages.offer.typeName, (msg) => this.handleWebRtcOffer(msg));
        this.protocol.addListener(lib_pixelstreamingcommon_ue5_5_1.Messages.peerDataChannels.typeName, (msg) => this.handleWebRtcSFUPeerDatachannels(msg));
        this.protocol.addListener(lib_pixelstreamingcommon_ue5_5_1.Messages.iceCandidate.typeName, (msg) => {
            const iceCandidateMessage = msg;
            this.handleIceCandidate(iceCandidateMessage.candidate);
        });
        this.protocol.transport.addListener('open', () => {
            const message = lib_pixelstreamingcommon_ue5_5_1.MessageHelpers.createMessage(lib_pixelstreamingcommon_ue5_5_1.Messages.listStreamers);
            this.protocol.sendMessage(message);
            this.reconnectAttempt = 0;
            this.isReconnecting = false;
        });
        this.protocol.transport.addListener('error', () => {
            // dont really need to do anything here since the close event should follow.
            lib_pixelstreamingcommon_ue5_5_1.Logger.Error(`Got a transport error.`);
        });
        this.protocol.transport.addListener('close', (event) => {
            // when we refresh the page during a stream we get the going away code.
            // in that case we don't want to reconnect since we're navigating away.
            // https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent/code
            // lists all the codes.
            const CODE_GOING_AWAY = 1001;
            const maxReconnectAttempts = this.config.getNumericSettingValue(Config_1.NumericParameters.MaxReconnectAttempts);
            const attemptsLeft = this.reconnectAttempt < maxReconnectAttempts;
            const reconnectEnabled = this.forceReconnect || (this.enableAutoReconnect && maxReconnectAttempts > 0 && attemptsLeft);
            const willTryReconnect = reconnectEnabled && event.code != CODE_GOING_AWAY;
            const allowClickToReconnect = !willTryReconnect;
            const disconnectMessage = this.disconnectMessage ? this.disconnectMessage : event.reason;
            this.forceReconnect = false;
            // Reset the list of all possible codecs on disconnect so that if the next connection has "NegotiateCodecs" on
            // then all codecs can be negotiated
            this.config.getSettingOption(Config_1.OptionParameters.PreferredCodec).options =
                BrowserUtils_1.BrowserUtils.getSupportedVideoCodecs();
            this.pixelStreaming._onDisconnect(disconnectMessage, allowClickToReconnect);
            this.afkController.stopAfkWarningTimer();
            // stop sending stats on interval if we have closed our connection
            if (this.statsTimerHandle && this.statsTimerHandle !== undefined) {
                window.clearInterval(this.statsTimerHandle);
            }
            // reset the stream quality icon.
            this.setVideoEncoderAvgQP(0);
            // unregister all input device event handlers on disconnect
            this.setTouchInputEnabled(false);
            this.setMouseInputEnabled(false);
            this.setKeyboardInputEnabled(false);
            this.setGamePadInputEnabled(false);
            if (willTryReconnect) {
                // need a small delay here to prevent reconnect spamming
                setTimeout(() => {
                    this.reconnectAttempt++;
                    this.doReconnect(event.reason);
                }, 2000);
            }
        });
        // set up the final webRtc player controller methods from within our application so a connection can be activated
        this.sendMessageController = new SendMessageController_1.SendMessageController(this.dataChannelSender, this.streamMessageController);
        this.toStreamerMessagesController = new ToStreamerMessagesController_1.ToStreamerMessagesController(this.sendMessageController);
        this.registerMessageHandlers();
        this.streamMessageController.populateDefaultProtocol();
        this.inputClassesFactory = new InputClassesFactory_1.InputClassesFactory(this.streamMessageController, this.videoPlayer, this.coordinateConverter);
        this.isUsingSFU = false;
        this.isUsingSVC = false;
        this.isQualityController = false;
        this.preferredCodec = '';
        this.enableAutoReconnect = true;
        this.forceReconnect = false;
        this.reconnectAttempt = 0;
        this.isReconnecting = false;
        this.config._addOnOptionSettingChangedListener(Config_1.OptionParameters.StreamerId, (streamerid) => {
            if (streamerid === undefined || streamerid === '') {
                return;
            }
            // close the current peer connection and create a new one
            this.peerConnectionController.peerConnection.close();
            this.peerConnectionController.createPeerConnection(this.peerConfig, this.preferredCodec);
            this.subscribedStream = streamerid;
            const message = lib_pixelstreamingcommon_ue5_5_1.MessageHelpers.createMessage(lib_pixelstreamingcommon_ue5_5_1.Messages.subscribe, { streamerId: streamerid });
            this.protocol.sendMessage(message);
        });
        this.config._addOnOptionSettingChangedListener(Config_1.OptionParameters.PreferredQuality, (preferredQuality) => {
            if (preferredQuality === undefined || preferredQuality === '') {
                return;
            }
            let message;
            if (this.isUsingSVC) {
                // User is using SVC so selected quality will be of the form SxTy(h). Just extract the x and y numbers
                message = lib_pixelstreamingcommon_ue5_5_1.MessageHelpers.createMessage(lib_pixelstreamingcommon_ue5_5_1.Messages.layerPreference, {
                    spatialLayer: +preferredQuality[1] - 1,
                    temporalLayer: +preferredQuality[3] - 1
                });
            }
            else {
                // User is not using SVC so the selected quality will be either Low, Medium or High so we extract the appropriate spatial layer index
                const allQualities = this.config.getSettingOption(Config_1.OptionParameters.PreferredQuality).options;
                const qualityIndex = allQualities.indexOf(preferredQuality);
                message = lib_pixelstreamingcommon_ue5_5_1.MessageHelpers.createMessage(lib_pixelstreamingcommon_ue5_5_1.Messages.layerPreference, {
                    spatialLayer: qualityIndex,
                    temporalLayer: 0
                });
            }
            this.protocol.sendMessage(message);
        });
        this.setVideoEncoderAvgQP(-1);
        this.signallingUrlBuilder = () => {
            const signallingServerUrl = this.config.getTextSettingValue(Config_1.TextParameters.SignallingServerUrl);
            return signallingServerUrl;
        };
    }
    /**
     * Destroys the video player and makes sure resources are freed. This helps to prevent the issue in chrome
     * where it refuses to make new video players.
     */
    destroyVideoPlayer() {
        this.videoPlayer.destroy();
    }
    /**
     * Handles when a message is received
     * @param event - Message Event
     */
    handleOnMessage(event) {
        const message = new Uint8Array(event.data);
        lib_pixelstreamingcommon_ue5_5_1.Logger.Info('Message incoming:' + message);
        //try {
        const messageType = this.streamMessageController.fromStreamerMessages.get(message[0]);
        this.streamMessageController.fromStreamerHandlers.get(messageType)(event.data);
        //} catch (e) {
        //Logger.Error(Logger.GetStackTrace(), `Custom data channel message with message type that is unknown to the Pixel Streaming protocol. Does your PixelStreamingProtocol need updating? The message type was: ${message[0]}`);
        //}
    }
    /**
     * Register message all handlers
     */
    registerMessageHandlers() {
        // From Streamer
        // Message events from the streamer have a data type of ArrayBuffer as we force this type in the DatachannelController
        this.streamMessageController.registerMessageHandler(StreamMessageController_1.MessageDirection.FromStreamer, 'QualityControlOwnership', (data) => this.onQualityControlOwnership(data));
        this.streamMessageController.registerMessageHandler(StreamMessageController_1.MessageDirection.FromStreamer, 'Response', (data) => this.responseController.onResponse(data));
        this.streamMessageController.registerMessageHandler(StreamMessageController_1.MessageDirection.FromStreamer, 'Command', (data) => {
            this.onCommand(data);
        });
        this.streamMessageController.registerMessageHandler(StreamMessageController_1.MessageDirection.FromStreamer, 'FreezeFrame', (data) => this.onFreezeFrameMessage(data));
        this.streamMessageController.registerMessageHandler(StreamMessageController_1.MessageDirection.FromStreamer, 'UnfreezeFrame', () => this.invalidateFreezeFrameAndEnableVideo());
        this.streamMessageController.registerMessageHandler(StreamMessageController_1.MessageDirection.FromStreamer, 'VideoEncoderAvgQP', (data) => this.handleVideoEncoderAvgQP(data));
        this.streamMessageController.registerMessageHandler(StreamMessageController_1.MessageDirection.FromStreamer, 'LatencyTest', (data) => this.handleLatencyTestResult(data));
        this.streamMessageController.registerMessageHandler(StreamMessageController_1.MessageDirection.FromStreamer, 'DataChannelLatencyTest', (data) => this.handleDataChannelLatencyTestResponse(data));
        this.streamMessageController.registerMessageHandler(StreamMessageController_1.MessageDirection.FromStreamer, 'InitialSettings', (data) => this.handleInitialSettings(data));
        this.streamMessageController.registerMessageHandler(StreamMessageController_1.MessageDirection.FromStreamer, 'FileExtension', (data) => this.onFileExtension(data));
        this.streamMessageController.registerMessageHandler(StreamMessageController_1.MessageDirection.FromStreamer, 'FileMimeType', (data) => this.onFileMimeType(data));
        this.streamMessageController.registerMessageHandler(StreamMessageController_1.MessageDirection.FromStreamer, 'FileContents', (data) => this.onFileContents(data));
        this.streamMessageController.registerMessageHandler(StreamMessageController_1.MessageDirection.FromStreamer, 'TestEcho', () => {
            /* Do nothing */
        });
        this.streamMessageController.registerMessageHandler(StreamMessageController_1.MessageDirection.FromStreamer, 'InputControlOwnership', (data) => this.onInputControlOwnership(data));
        this.streamMessageController.registerMessageHandler(StreamMessageController_1.MessageDirection.FromStreamer, 'GamepadResponse', (data) => this.onGamepadResponse(data));
        this.streamMessageController.registerMessageHandler(StreamMessageController_1.MessageDirection.FromStreamer, 'Multiplexed', () => {
            /* Do nothing as this message type is used only by the SFU */
        });
        this.streamMessageController.registerMessageHandler(StreamMessageController_1.MessageDirection.FromStreamer, 'Protocol', (data) => this.onProtocolMessage(data));
        // To Streamer
        this.streamMessageController.registerMessageHandler(StreamMessageController_1.MessageDirection.ToStreamer, 'IFrameRequest', () => this.sendMessageController.sendMessageToStreamer('IFrameRequest'));
        this.streamMessageController.registerMessageHandler(StreamMessageController_1.MessageDirection.ToStreamer, 'RequestQualityControl', () => this.sendMessageController.sendMessageToStreamer('RequestQualityControl'));
        this.streamMessageController.registerMessageHandler(StreamMessageController_1.MessageDirection.ToStreamer, 'FpsRequest', () => this.sendMessageController.sendMessageToStreamer('FpsRequest'));
        this.streamMessageController.registerMessageHandler(StreamMessageController_1.MessageDirection.ToStreamer, 'AverageBitrateRequest', () => this.sendMessageController.sendMessageToStreamer('AverageBitrateRequest'));
        this.streamMessageController.registerMessageHandler(StreamMessageController_1.MessageDirection.ToStreamer, 'StartStreaming', () => this.sendMessageController.sendMessageToStreamer('StartStreaming'));
        this.streamMessageController.registerMessageHandler(StreamMessageController_1.MessageDirection.ToStreamer, 'StopStreaming', () => this.sendMessageController.sendMessageToStreamer('StopStreaming'));
        this.streamMessageController.registerMessageHandler(StreamMessageController_1.MessageDirection.ToStreamer, 'LatencyTest', (data) => this.sendMessageController.sendMessageToStreamer('LatencyTest', data));
        this.streamMessageController.registerMessageHandler(StreamMessageController_1.MessageDirection.ToStreamer, 'RequestInitialSettings', () => this.sendMessageController.sendMessageToStreamer('RequestInitialSettings'));
        this.streamMessageController.registerMessageHandler(StreamMessageController_1.MessageDirection.ToStreamer, 'TestEcho', () => {
            /* Do nothing */
        });
        this.streamMessageController.registerMessageHandler(StreamMessageController_1.MessageDirection.ToStreamer, 'UIInteraction', (data) => this.sendMessageController.sendMessageToStreamer('UIInteraction', data));
        this.streamMessageController.registerMessageHandler(StreamMessageController_1.MessageDirection.ToStreamer, 'Command', (data) => this.sendMessageController.sendMessageToStreamer('Command', data));
        this.streamMessageController.registerMessageHandler(StreamMessageController_1.MessageDirection.ToStreamer, 'TextboxEntry', (data) => this.sendMessageController.sendMessageToStreamer('TextboxEntry', data));
        this.streamMessageController.registerMessageHandler(StreamMessageController_1.MessageDirection.ToStreamer, 'KeyDown', (data) => this.sendMessageController.sendMessageToStreamer('KeyDown', data));
        this.streamMessageController.registerMessageHandler(StreamMessageController_1.MessageDirection.ToStreamer, 'KeyUp', (data) => this.sendMessageController.sendMessageToStreamer('KeyUp', data));
        this.streamMessageController.registerMessageHandler(StreamMessageController_1.MessageDirection.ToStreamer, 'KeyPress', (data) => this.sendMessageController.sendMessageToStreamer('KeyPress', data));
        this.streamMessageController.registerMessageHandler(StreamMessageController_1.MessageDirection.ToStreamer, 'MouseEnter', (data) => this.sendMessageController.sendMessageToStreamer('MouseEnter', data));
        this.streamMessageController.registerMessageHandler(StreamMessageController_1.MessageDirection.ToStreamer, 'MouseLeave', (data) => this.sendMessageController.sendMessageToStreamer('MouseLeave', data));
        this.streamMessageController.registerMessageHandler(StreamMessageController_1.MessageDirection.ToStreamer, 'MouseDown', (data) => this.sendMessageController.sendMessageToStreamer('MouseDown', data));
        this.streamMessageController.registerMessageHandler(StreamMessageController_1.MessageDirection.ToStreamer, 'MouseUp', (data) => this.sendMessageController.sendMessageToStreamer('MouseUp', data));
        this.streamMessageController.registerMessageHandler(StreamMessageController_1.MessageDirection.ToStreamer, 'MouseMove', (data) => this.sendMessageController.sendMessageToStreamer('MouseMove', data));
        this.streamMessageController.registerMessageHandler(StreamMessageController_1.MessageDirection.ToStreamer, 'MouseWheel', (data) => this.sendMessageController.sendMessageToStreamer('MouseWheel', data));
        this.streamMessageController.registerMessageHandler(StreamMessageController_1.MessageDirection.ToStreamer, 'MouseDouble', (data) => this.sendMessageController.sendMessageToStreamer('MouseDouble', data));
        this.streamMessageController.registerMessageHandler(StreamMessageController_1.MessageDirection.ToStreamer, 'TouchStart', (data) => this.sendMessageController.sendMessageToStreamer('TouchStart', data));
        this.streamMessageController.registerMessageHandler(StreamMessageController_1.MessageDirection.ToStreamer, 'TouchEnd', (data) => this.sendMessageController.sendMessageToStreamer('TouchEnd', data));
        this.streamMessageController.registerMessageHandler(StreamMessageController_1.MessageDirection.ToStreamer, 'TouchMove', (data) => this.sendMessageController.sendMessageToStreamer('TouchMove', data));
        this.streamMessageController.registerMessageHandler(StreamMessageController_1.MessageDirection.ToStreamer, 'GamepadConnected', () => this.sendMessageController.sendMessageToStreamer('GamepadConnected'));
        this.streamMessageController.registerMessageHandler(StreamMessageController_1.MessageDirection.ToStreamer, 'GamepadButtonPressed', (data) => this.sendMessageController.sendMessageToStreamer('GamepadButtonPressed', data));
        this.streamMessageController.registerMessageHandler(StreamMessageController_1.MessageDirection.ToStreamer, 'GamepadButtonReleased', (data) => this.sendMessageController.sendMessageToStreamer('GamepadButtonReleased', data));
        this.streamMessageController.registerMessageHandler(StreamMessageController_1.MessageDirection.ToStreamer, 'GamepadAnalog', (data) => this.sendMessageController.sendMessageToStreamer('GamepadAnalog', data));
        this.streamMessageController.registerMessageHandler(StreamMessageController_1.MessageDirection.ToStreamer, 'GamepadDisconnected', (data) => this.sendMessageController.sendMessageToStreamer('GamepadDisconnected', data));
        this.streamMessageController.registerMessageHandler(StreamMessageController_1.MessageDirection.ToStreamer, 'XREyeViews', (data) => this.sendMessageController.sendMessageToStreamer('XREyeViews', data));
        this.streamMessageController.registerMessageHandler(StreamMessageController_1.MessageDirection.ToStreamer, 'XRHMDTransform', (data) => this.sendMessageController.sendMessageToStreamer('XRHMDTransform', data));
        this.streamMessageController.registerMessageHandler(StreamMessageController_1.MessageDirection.ToStreamer, 'XRControllerTransform', (data) => this.sendMessageController.sendMessageToStreamer('XRControllerTransform', data));
        this.streamMessageController.registerMessageHandler(StreamMessageController_1.MessageDirection.ToStreamer, 'XRSystem', (data) => this.sendMessageController.sendMessageToStreamer('XRSystem', data));
        this.streamMessageController.registerMessageHandler(StreamMessageController_1.MessageDirection.ToStreamer, 'XRButtonTouched', (data) => this.sendMessageController.sendMessageToStreamer('XRButtonTouched', data));
        this.streamMessageController.registerMessageHandler(StreamMessageController_1.MessageDirection.ToStreamer, 'XRButtonTouchReleased', (data) => this.sendMessageController.sendMessageToStreamer('XRButtonTouchReleased', data));
        this.streamMessageController.registerMessageHandler(StreamMessageController_1.MessageDirection.ToStreamer, 'XRButtonPressed', (data) => this.sendMessageController.sendMessageToStreamer('XRButtonPressed', data));
        this.streamMessageController.registerMessageHandler(StreamMessageController_1.MessageDirection.ToStreamer, 'XRButtonReleased', (data) => this.sendMessageController.sendMessageToStreamer('XRButtonReleased', data));
        this.streamMessageController.registerMessageHandler(StreamMessageController_1.MessageDirection.ToStreamer, 'XRAnalog', (data) => this.sendMessageController.sendMessageToStreamer('XRAnalog', data));
        this.streamMessageController.registerMessageHandler(StreamMessageController_1.MessageDirection.ToStreamer, 'ChannelRelayStatus', () => {
            /* Do nothing as this message type is used only by the SFU */
        });
        this.streamMessageController.registerMessageHandler(StreamMessageController_1.MessageDirection.ToStreamer, 'Multiplexed', () => {
            /* Do nothing as this message type is used only by the SFU */
        });
    }
    /**
     * Activate the logic associated with a command from UE
     * @param message
     */
    onCommand(message) {
        lib_pixelstreamingcommon_ue5_5_1.Logger.Info('DataChannelReceiveMessageType.Command');
        const commandAsString = new TextDecoder('utf-16').decode(message.slice(1));
        lib_pixelstreamingcommon_ue5_5_1.Logger.Info('Data Channel Command: ' + commandAsString);
        const command = JSON.parse(commandAsString);
        // Handle "onScreenKeyboard" event
        if (command.command === 'onScreenKeyboard') {
            this.handleOnScreenKeyboardCommand(command);
        }
    }
    handleOnScreenKeyboardCommand(command) {
        var _a, _b, _c, _d;
        const data = {
            showOnScreenKeyboard: (_a = command.showOnScreenKeyboard) !== null && _a !== void 0 ? _a : true,
            x: (_b = command.x) !== null && _b !== void 0 ? _b : 0,
            y: (_c = command.y) !== null && _c !== void 0 ? _c : 0,
            contents: (_d = command.contents) !== null && _d !== void 0 ? _d : ''
        };
        this.pixelStreaming.dispatchEvent(new EventEmitter_1.ShowOnScreenKeyboardEvent(data));
    }
    /**
     * Handles a protocol message received from the streamer
     * @param message the message data from the streamer
     */
    onProtocolMessage(message) {
        try {
            const protocolString = new TextDecoder('utf-16').decode(message.slice(1));
            const protocolJSON = JSON.parse(protocolString);
            if (!Object.prototype.hasOwnProperty.call(protocolJSON, 'Direction')) {
                lib_pixelstreamingcommon_ue5_5_1.Logger.Error('Malformed protocol received. Ensure the protocol message contains a direction');
            }
            const direction = protocolJSON.Direction;
            delete protocolJSON.Direction;
            lib_pixelstreamingcommon_ue5_5_1.Logger.Info(`Received new ${direction == StreamMessageController_1.MessageDirection.FromStreamer ? 'FromStreamer' : 'ToStreamer'} protocol. Updating existing protocol...`);
            Object.keys(protocolJSON).forEach((messageType) => {
                const message = protocolJSON[messageType];
                switch (direction) {
                    case StreamMessageController_1.MessageDirection.ToStreamer:
                        // Check that the message contains all the relevant params
                        if (!Object.prototype.hasOwnProperty.call(message, 'id')) {
                            lib_pixelstreamingcommon_ue5_5_1.Logger.Error(`ToStreamer->${messageType} protocol definition was malformed as it didn't contain at least an id\n
                                           Definition was: ${JSON.stringify(message, null, 2)}`);
                            // return in a forEach is equivalent to a continue in a normal for loop
                            return;
                        }
                        // UE5.1 and UE5.2 don't send a structure for these message types, but they actually do have a structure so ignore updating them
                        if (messageType === 'UIInteraction' ||
                            messageType === 'Command' ||
                            messageType === 'LatencyTest') {
                            return;
                        }
                        if (this.streamMessageController.toStreamerHandlers.get(messageType)) {
                            // If we've registered a handler for this message type we can add it to our supported messages. ie registerMessageHandler(...)
                            this.streamMessageController.toStreamerMessages.set(messageType, message);
                        }
                        else {
                            lib_pixelstreamingcommon_ue5_5_1.Logger.Error(`There was no registered handler for "${messageType}" - try adding one using registerMessageHandler(MessageDirection.ToStreamer, "${messageType}", myHandler)`);
                        }
                        break;
                    case StreamMessageController_1.MessageDirection.FromStreamer:
                        // Check that the message contains all the relevant params
                        if (!Object.prototype.hasOwnProperty.call(message, 'id')) {
                            lib_pixelstreamingcommon_ue5_5_1.Logger.Error(`FromStreamer->${messageType} protocol definition was malformed as it didn't contain at least an id\n
                            Definition was: ${JSON.stringify(message, null, 2)}`);
                            // return in a forEach is equivalent to a continue in a normal for loop
                            return;
                        }
                        if (this.streamMessageController.fromStreamerHandlers.get(messageType)) {
                            // If we've registered a handler for this message type. ie registerMessageHandler(...)
                            this.streamMessageController.fromStreamerMessages.set(message.id, messageType);
                        }
                        else {
                            lib_pixelstreamingcommon_ue5_5_1.Logger.Error(`There was no registered handler for "${message}" - try adding one using registerMessageHandler(MessageDirection.FromStreamer, "${messageType}", myHandler)`);
                        }
                        break;
                    default:
                        lib_pixelstreamingcommon_ue5_5_1.Logger.Error(`Unknown direction: ${direction}`);
                }
            });
            // Once the protocol has been received, we can send our control messages
            this.toStreamerMessagesController.SendRequestInitialSettings();
            this.toStreamerMessagesController.SendRequestQualityControl();
        }
        catch (e) {
            lib_pixelstreamingcommon_ue5_5_1.Logger.Info(e);
        }
    }
    /**
     * Handles an input control message when it is received from the streamer
     * @param message The input control message
     */
    onInputControlOwnership(message) {
        const view = new Uint8Array(message);
        lib_pixelstreamingcommon_ue5_5_1.Logger.Info('DataChannelReceiveMessageType.InputControlOwnership');
        const inputControlOwnership = new Boolean(view[1]).valueOf();
        lib_pixelstreamingcommon_ue5_5_1.Logger.Info(`Received input controller message - will your input control the stream: ${inputControlOwnership}`);
        this.pixelStreaming._onInputControlOwnership(inputControlOwnership);
    }
    /**
     *
     * @param message
     */
    onGamepadResponse(message) {
        const responseString = new TextDecoder('utf-16').decode(message.slice(1));
        const responseJSON = JSON.parse(responseString);
        this.gamePadController.onGamepadResponseReceived(responseJSON.controllerId);
    }
    onAfkTriggered() {
        this.afkController.onAfkClick();
        // if the stream is paused play it, if we can
        if (this.videoPlayer.isPaused() && this.videoPlayer.hasVideoSource()) {
            this.playStream();
        }
    }
    /**
     * Set whether we should timeout when afk.
     * @param afkEnabled If true we timeout when idle for some given amount of time.
     */
    setAfkEnabled(afkEnabled) {
        if (afkEnabled) {
            this.onAfkTriggered();
        }
        else {
            this.afkController.stopAfkWarningTimer();
        }
    }
    /**
     * Attempt a reconnection to the signalling server. Manual trigger
     */
    tryReconnect(message) {
        this.forceReconnect = true;
        this.doReconnect(message);
    }
    /**
     * Does the actual reconnect work. Used by the auto reconnect feature to skip the manual flag.
     */
    doReconnect(message) {
        // if there is no webSocketController return immediately or this will not work
        if (!this.protocol) {
            lib_pixelstreamingcommon_ue5_5_1.Logger.Info('This player has no protocol connection.');
            return;
        }
        this.isReconnecting = true;
        // if the connection is open, first close it and force a reconnect.
        if (this.protocol.isConnected()) {
            if (!this.forceReconnect) {
                this.disconnectMessage = `${message} Reconnecting.`;
            }
            this.closeSignalingServer(message, true);
        }
        else {
            this.pixelStreaming._onWebRtcAutoConnect();
            this.connectToSignallingServer();
        }
    }
    /**
     * Loads a freeze frame if it is required otherwise shows the play overlay
     */
    loadFreezeFrameOrShowPlayOverlay() {
        this.pixelStreaming.dispatchEvent(new EventEmitter_1.LoadFreezeFrameEvent({
            shouldShowPlayOverlay: this.shouldShowPlayOverlay,
            isValid: this.freezeFrameController.valid,
            jpegData: this.freezeFrameController.jpeg
        }));
        if (this.shouldShowPlayOverlay === true) {
            lib_pixelstreamingcommon_ue5_5_1.Logger.Info('showing play overlay');
            this.resizePlayerStyle();
        }
        else {
            lib_pixelstreamingcommon_ue5_5_1.Logger.Info('showing freeze frame');
            this.freezeFrameController.showFreezeFrame();
        }
        setTimeout(() => {
            this.videoPlayer.setVideoEnabled(false);
        }, this.freezeFrameController.freezeFrameDelay);
    }
    /**
     * Process the freeze frame and load it
     * @param message The freeze frame data in bytes
     */
    onFreezeFrameMessage(message) {
        lib_pixelstreamingcommon_ue5_5_1.Logger.Info('DataChannelReceiveMessageType.FreezeFrame');
        const view = new Uint8Array(message);
        this.freezeFrameController.processFreezeFrameMessage(view, () => this.loadFreezeFrameOrShowPlayOverlay());
    }
    /**
     * Enable the video after hiding a freeze frame
     */
    invalidateFreezeFrameAndEnableVideo() {
        lib_pixelstreamingcommon_ue5_5_1.Logger.Info('DataChannelReceiveMessageType.FreezeFrame');
        setTimeout(() => {
            this.pixelStreaming.dispatchEvent(new EventEmitter_1.HideFreezeFrameEvent());
            this.freezeFrameController.hideFreezeFrame();
        }, this.freezeFrameController.freezeFrameDelay);
        if (this.videoPlayer.getVideoElement()) {
            this.videoPlayer.setVideoEnabled(true);
        }
    }
    /**
     * Prep datachannel data for processing file extension
     * @param data the file extension data
     */
    onFileExtension(data) {
        const view = new Uint8Array(data);
        FileUtil_1.FileUtil.setExtensionFromBytes(view, this.file);
    }
    /**
     * Prep datachannel data for processing the file mime type
     * @param data the file mime type data
     */
    onFileMimeType(data) {
        const view = new Uint8Array(data);
        FileUtil_1.FileUtil.setMimeTypeFromBytes(view, this.file);
    }
    /**
     * Prep datachannel data for processing the file contents
     * @param data the file contents data
     */
    onFileContents(data) {
        const view = new Uint8Array(data);
        FileUtil_1.FileUtil.setContentsFromBytes(view, this.file);
    }
    /**
     * Plays the stream audio and video source and sets up other pieces while the stream starts
     */
    playStream() {
        if (!this.videoPlayer.getVideoElement()) {
            const message = 'Could not play video stream because the video player was not initialized correctly.';
            this.pixelStreaming.dispatchEvent(new EventEmitter_1.PlayStreamErrorEvent({ message }));
            lib_pixelstreamingcommon_ue5_5_1.Logger.Error(message);
            // close the connection
            this.closeSignalingServer('Stream not initialized correctly', false);
            return;
        }
        if (!this.videoPlayer.hasVideoSource()) {
            lib_pixelstreamingcommon_ue5_5_1.Logger.Warning('Cannot play stream, the video element has no srcObject to play.');
            return;
        }
        this.setTouchInputEnabled(this.config.isFlagEnabled(Config_1.Flags.TouchInput));
        this.pixelStreaming.dispatchEvent(new EventEmitter_1.PlayStreamEvent());
        if (this.streamController.audioElement.srcObject) {
            const startMuted = this.config.isFlagEnabled(Config_1.Flags.StartVideoMuted);
            this.streamController.audioElement.muted = startMuted;
            if (startMuted) {
                this.playVideo();
            }
            else {
                this.streamController.audioElement
                    .play()
                    .then(() => {
                    this.playVideo();
                })
                    .catch((onRejectedReason) => {
                    lib_pixelstreamingcommon_ue5_5_1.Logger.Info(onRejectedReason);
                    lib_pixelstreamingcommon_ue5_5_1.Logger.Info('Browser does not support autoplaying video without interaction - to resolve this we are going to show the play button overlay.');
                    this.pixelStreaming.dispatchEvent(new EventEmitter_1.PlayStreamRejectedEvent({
                        reason: onRejectedReason
                    }));
                });
            }
        }
        else {
            this.playVideo();
        }
        this.shouldShowPlayOverlay = false;
        this.freezeFrameController.showFreezeFrame();
    }
    /**
     * Plays the video stream
     */
    playVideo() {
        // handle play() with promise as it is an asynchronous call
        this.videoPlayer.play().catch((onRejectedReason) => {
            if (this.streamController.audioElement.srcObject) {
                this.streamController.audioElement.pause();
            }
            lib_pixelstreamingcommon_ue5_5_1.Logger.Info(onRejectedReason);
            lib_pixelstreamingcommon_ue5_5_1.Logger.Info('Browser does not support autoplaying video without interaction - to resolve this we are going to show the play button overlay.');
            this.pixelStreaming.dispatchEvent(new EventEmitter_1.PlayStreamRejectedEvent({ reason: onRejectedReason }));
        });
    }
    /**
     * Enable the video to play automatically if enableAutoplay is true
     */
    autoPlayVideoOrSetUpPlayOverlay() {
        if (this.config.isFlagEnabled(Config_1.Flags.AutoPlayVideo)) {
            // attempt to play the video
            this.playStream();
        }
        this.resizePlayerStyle();
    }
    /**
     * Connect to the Signaling server
     */
    connectToSignallingServer() {
        this.locallyClosed = false;
        this.enableAutoReconnect = true;
        this.disconnectMessage = null;
        const signallingUrl = this.signallingUrlBuilder();
        this.protocol.connect(signallingUrl);
        const keepaliveDelay = this.config.getNumericSettingValue(Config_1.NumericParameters.KeepaliveDelay);
        if (keepaliveDelay > 0) {
            this.keepalive = new lib_pixelstreamingcommon_ue5_5_1.KeepaliveMonitor(this.protocol, keepaliveDelay);
            this.keepalive.onTimeout = () => {
                // if the ping fails just disconnect
                lib_pixelstreamingcommon_ue5_5_1.Logger.Error(`Protocol timeout`);
                this.protocol.disconnect();
            };
        }
    }
    /**
     * This will start the handshake to the signalling server
     * @param peerConfig  - RTC Configuration Options from the Signaling server
     * @remark RTC Peer Connection on Ice Candidate event have it handled by handle Send Ice Candidate
     */
    startSession(peerConfig) {
        this.peerConfig = peerConfig;
        // check for forcing turn
        if (this.config.isFlagEnabled(Config_1.Flags.ForceTURN)) {
            // check for a turn server
            const hasTurnServer = this.checkTurnServerAvailability(peerConfig);
            // close and error if turn is forced and there is no turn server
            if (!hasTurnServer) {
                lib_pixelstreamingcommon_ue5_5_1.Logger.Info('No turn server was found in the Peer Connection Options. TURN cannot be forced, closing connection. Please use STUN instead');
                this.closeSignalingServer('TURN cannot be forced, closing connection. Please use STUN instead.', false);
                return;
            }
        }
        // set up the peer connection controller
        this.peerConnectionController = new PeerConnectionController_1.PeerConnectionController(this.peerConfig, this.config, this.preferredCodec);
        // set up peer connection controller video stats
        this.peerConnectionController.onVideoStats = (event) => {
            this.handleVideoStats(event);
        };
        /* Set event handler for latency information is calculated, handle the event by propogating to the PixelStreaming API */
        this.peerConnectionController.onLatencyCalculated = (latencyInfo) => {
            this.pixelStreaming._onLatencyCalculated(latencyInfo);
        };
        /* When the Peer Connection wants to send an offer have it handled */
        this.peerConnectionController.onSendWebRTCOffer = (offer) => {
            this.handleSendWebRTCOffer(offer);
        };
        /* Set event handler for when local answer description is set */
        this.peerConnectionController.onSetLocalDescription = (answer) => {
            this.handleSendWebRTCAnswer(answer);
        };
        /* Set event handler for when remote offer description is set */
        this.peerConnectionController.onSetRemoteDescription = (offer) => {
            this.pixelStreaming._onWebRtcSdpOffer(offer);
        };
        /* When the Peer Connection ice candidate is added have it handled */
        this.peerConnectionController.onPeerIceCandidate = (peerConnectionIceEvent) => this.handleSendIceCandidate(peerConnectionIceEvent);
        /* When the Peer Connection has a data channel created for it by the browser, handle it */
        this.peerConnectionController.onDataChannel = (datachannelEvent) => this.handleDataChannel(datachannelEvent);
        // set up webRtc text overlays
        this.peerConnectionController.showTextOverlayConnecting = () => this.pixelStreaming._onWebRtcConnecting();
        this.peerConnectionController.showTextOverlaySetupFailure = () => this.pixelStreaming._onWebRtcFailed();
        let webRtcConnectedSent = false;
        this.peerConnectionController.onIceConnectionStateChange = () => {
            // Browsers emit "connected" when getting first connection and "completed" when finishing
            // candidate checking. However, sometimes browsers can skip "connected" and only emit "completed".
            // Therefore need to check both cases and emit onWebRtcConnected only once on the first hit.
            if (!webRtcConnectedSent &&
                ['connected', 'completed'].includes(this.peerConnectionController.peerConnection.iceConnectionState)) {
                this.pixelStreaming._onWebRtcConnected();
                webRtcConnectedSent = true;
            }
        };
        /* RTC Peer Connection on Track event -> handle on track */
        this.peerConnectionController.onTrack = (trackEvent) => this.streamController.handleOnTrack(trackEvent);
    }
    /**
     * Checks the peer connection options for a turn server and returns true or false
     */
    checkTurnServerAvailability(options) {
        // if iceServers is empty return false this should not be the general use case but is here incase
        if (!options.iceServers) {
            lib_pixelstreamingcommon_ue5_5_1.Logger.Info('A turn sever was not found');
            return false;
        }
        // loop through the ice servers to check for a turn url
        for (const iceServer of options.iceServers) {
            for (const url of iceServer.urls) {
                if (url.includes('turn')) {
                    lib_pixelstreamingcommon_ue5_5_1.Logger.Info(`A turn sever was found at ${url}`);
                    return true;
                }
            }
        }
        lib_pixelstreamingcommon_ue5_5_1.Logger.Info('A turn sever was not found');
        return false;
    }
    /**
     * Handles when a Config Message is received contains the Peer Connection Options required (STUN and TURN Server Info)
     * @param messageConfig - Config Message received from the signaling server
     */
    handleOnConfigMessage(messageConfig) {
        this.resizePlayerStyle();
        // Tell the WebRtcController to start a session with the peer options sent from the signaling server
        this.startSession(messageConfig.peerConnectionOptions);
    }
    handlePingMessage(pingMessage) {
        this.protocol.sendMessage(lib_pixelstreamingcommon_ue5_5_1.MessageHelpers.createMessage(lib_pixelstreamingcommon_ue5_5_1.Messages.pong, { time: pingMessage.time }));
    }
    /**
     * Handles when the signalling server gives us the list of streamer ids.
     */
    handleStreamerListMessage(messageStreamerList) {
        lib_pixelstreamingcommon_ue5_5_1.Logger.Info(`Got streamer list ${messageStreamerList.ids}`);
        let wantedStreamerId = '';
        // get the current selected streamer id option
        const streamerIDOption = this.config.getSettingOption(Config_1.OptionParameters.StreamerId);
        const existingSelection = streamerIDOption.selected.toString().trim();
        if (existingSelection) {
            // default to selected option if it exists
            wantedStreamerId = streamerIDOption.selected;
        }
        // add the streamers to the UI
        const settingOptions = [...messageStreamerList.ids]; // copy the original messageStreamerList.ids
        settingOptions.unshift(''); // add an empty option at the top
        this.config.setOptionSettingOptions(Config_1.OptionParameters.StreamerId, settingOptions);
        let autoSelectedStreamerId = '';
        const waitForStreamer = this.config.isFlagEnabled(Config_1.Flags.WaitForStreamer);
        const reconnectLimit = this.config.getNumericSettingValue(Config_1.NumericParameters.MaxReconnectAttempts);
        const reconnectDelay = this.config.getNumericSettingValue(Config_1.NumericParameters.StreamerAutoJoinInterval);
        // first we figure out a wanted streamer id through various means
        const useUrlParams = this.config.useUrlParams;
        const urlParams = new IURLSearchParams_1.IURLSearchParams(window.location.search);
        if (useUrlParams && urlParams.has(Config_1.OptionParameters.StreamerId)) {
            // if we've set the streamer id on the url we only want that streamer id
            wantedStreamerId = urlParams.get(Config_1.OptionParameters.StreamerId);
        }
        else if (this.subscribedStream) {
            // we were previously subscribed to a streamer, we want that
            wantedStreamerId = this.subscribedStream;
        }
        // now lets see if we can pick it.
        if (wantedStreamerId && messageStreamerList.ids.includes(wantedStreamerId)) {
            // if the wanted stream is in the list. we pick that
            autoSelectedStreamerId = wantedStreamerId;
        }
        else if ((!wantedStreamerId || !waitForStreamer) && messageStreamerList.ids.length == 1) {
            // otherwise, if we're not waiting for the wanted streamer and there's only one streamer, connect to it
            autoSelectedStreamerId = messageStreamerList.ids[0];
        }
        // if we found a streamer id to auto select, select it
        if (autoSelectedStreamerId) {
            this.reconnectAttempt = 0;
            this.isReconnecting = false;
            this.config.setOptionSettingValue(Config_1.OptionParameters.StreamerId, autoSelectedStreamerId);
        }
        else {
            // no auto selected streamer.
            // if we're waiting for a streamer then try reconnecting
            if (waitForStreamer) {
                if (this.reconnectAttempt < reconnectLimit) {
                    // still reconnects available
                    this.reconnectAttempt++;
                    this.isReconnecting = true;
                    setTimeout(() => {
                        this.protocol.sendMessage(lib_pixelstreamingcommon_ue5_5_1.MessageHelpers.createMessage(lib_pixelstreamingcommon_ue5_5_1.Messages.listStreamers));
                    }, reconnectDelay);
                }
                else {
                    // We've exhausted our reconnect attempts, return to main screen
                    this.reconnectAttempt = 0;
                    this.isReconnecting = false;
                    this.enableAutoReconnect = false;
                }
            }
        }
        // dispatch this event finally
        this.pixelStreaming.dispatchEvent(new EventEmitter_1.StreamerListMessageEvent({
            messageStreamerList,
            autoSelectedStreamerId,
            wantedStreamerId
        }));
    }
    handleSubscribeFailedMessage(subscribeFailedMessage) {
        this.reconnectAttempt = 0;
        this.isReconnecting = false;
        this.enableAutoReconnect = false;
        this.pixelStreaming._onSubscribeFailed(subscribeFailedMessage.message);
    }
    handleStreamerIDChangedMessage(streamerIDChangedMessage) {
        const newID = streamerIDChangedMessage.newID;
        // need to edit the selected streamer in the settings list
        const streamerListOptions = this.config.getSettingOption(Config_1.OptionParameters.StreamerId);
        // temporarily prevent onChange from firing (it would try to subscribe to the streamer again)
        const oldOnChange = streamerListOptions.onChange;
        streamerListOptions.onChange = () => { };
        // change the selected entry.
        const streamerList = streamerListOptions.options;
        for (let i = 0; i < streamerList.length; ++i) {
            if (streamerList[i] == this.subscribedStream) {
                streamerList[i] = newID;
                break;
            }
        }
        // update the list
        streamerListOptions.options = streamerList;
        // update the selected entry
        streamerListOptions.selected = newID;
        // restore the old change notifier.
        streamerListOptions.onChange = oldOnChange;
        // remember which stream we're subscribe to
        this.subscribedStream = streamerIDChangedMessage.newID;
        // notify any listeners
        this.pixelStreaming.dispatchEvent(new EventEmitter_1.StreamerIDChangedMessageEvent({
            newID
        }));
    }
    /**
     * Handle the RTC Answer from the signaling server
     * @param Answer - Answer SDP from the peer.
     */
    handleWebRtcAnswer(Answer) {
        lib_pixelstreamingcommon_ue5_5_1.Logger.Info(`Got answer sdp ${Answer.sdp}`);
        const sdpAnswer = {
            sdp: Answer.sdp,
            type: 'answer'
        };
        this.peerConnectionController.receiveAnswer(sdpAnswer);
        this.handlePostWebrtcNegotiation();
    }
    /**
     * Handle the RTC offer from a WebRTC peer (received through the signalling server).
     * @param Offer - Offer SDP from the peer.
     */
    handleWebRtcOffer(Offer) {
        lib_pixelstreamingcommon_ue5_5_1.Logger.Info(`Got offer sdp ${Offer.sdp}`);
        this.isUsingSFU = Offer.sfu ? Offer.sfu : false;
        this.isUsingSVC = Offer.scalabilityMode ? Offer.scalabilityMode != 'L1T1' : false;
        if (this.isUsingSFU || this.isUsingSVC) {
            // Disable negotiating with the sfu as the sfu only supports one codec at a time
            this.peerConnectionController.preferredCodec = '';
        }
        // NOTE: These two settings configurations are done outside of an if(this.isUsingSFU) so that users
        // can switch between a default and SFU stream and have the settings reconfigure appropriately
        const scalabilityMode = Offer.scalabilityMode ? Offer.scalabilityMode : 'L1T1';
        let availableQualities = ['Default'];
        if (this.isUsingSFU) {
            if (!this.isUsingSVC) {
                // User is using an SFU without any temporal scalability. Just offer easily readable names
                availableQualities = ['Low', 'Medium', 'High'];
            }
            else {
                // User is using SVC. Generate all available options.
                availableQualities = [];
                const maxSpatialLayers = +scalabilityMode[1];
                const maxTemporalLayers = +scalabilityMode[3];
                for (let s = 1; s <= maxSpatialLayers; s++) {
                    for (let t = 1; t <= maxTemporalLayers; t++) {
                        availableQualities.push(`S${s}T${t}`);
                    }
                }
            }
        }
        // Update the possible video quality options
        this.config.setOptionSettingOptions(Config_1.OptionParameters.PreferredQuality, availableQualities);
        // Update the selected video quality with the highest possible resolution
        this.config.setOptionSettingValue(Config_1.OptionParameters.PreferredQuality, availableQualities.slice(-1)[0]);
        const sdpOffer = {
            sdp: Offer.sdp,
            type: 'offer'
        };
        this.peerConnectionController.receiveOffer(sdpOffer, this.config);
        this.handlePostWebrtcNegotiation();
    }
    /**
     * Handle when the SFU provides the peer with its data channels
     * @param DataChannels - The message from the SFU containing the data channels ids
     */
    handleWebRtcSFUPeerDatachannels(DataChannels) {
        const SendOptions = {
            ordered: true,
            negotiated: true,
            id: DataChannels.sendStreamId
        };
        const unidirectional = DataChannels.sendStreamId != DataChannels.recvStreamId;
        this.sendrecvDataChannelController.createDataChannel(this.peerConnectionController.peerConnection, unidirectional ? 'send-datachannel' : 'datachannel', SendOptions);
        if (unidirectional) {
            const RecvOptions = {
                ordered: true,
                negotiated: true,
                id: DataChannels.recvStreamId
            };
            this.recvDataChannelController.createDataChannel(this.peerConnectionController.peerConnection, 'recv-datachannel', RecvOptions);
            this.recvDataChannelController.handleOnOpen = () => this.protocol.sendMessage(lib_pixelstreamingcommon_ue5_5_1.MessageHelpers.createMessage(lib_pixelstreamingcommon_ue5_5_1.Messages.peerDataChannelsReady));
            // If we're uni-directional, only the recv data channel should handle incoming messages
            this.recvDataChannelController.handleOnMessage = (ev) => this.handleOnMessage(ev);
        }
        else {
            // else our primary datachannel is send/recv so it can handle incoming messages
            this.sendrecvDataChannelController.handleOnMessage = (ev) => this.handleOnMessage(ev);
        }
    }
    handlePostWebrtcNegotiation() {
        // start the afk warning timer as PS is now running
        this.afkController.startAfkWarningTimer();
        // show the overlay that we have negotiated a connection
        this.pixelStreaming._onWebRtcSdp();
        if (this.statsTimerHandle && this.statsTimerHandle !== undefined) {
            window.clearInterval(this.statsTimerHandle);
        }
        this.statsTimerHandle = window.setInterval(() => this.getStats(), 1000);
        /*  */
        this.setMouseInputEnabled(this.config.isFlagEnabled(Config_1.Flags.MouseInput));
        this.setKeyboardInputEnabled(this.config.isFlagEnabled(Config_1.Flags.KeyboardInput));
        this.setGamePadInputEnabled(this.config.isFlagEnabled(Config_1.Flags.GamepadInput));
    }
    /**
     * When an ice Candidate is received from the Signaling server add it to the Peer Connection Client
     * @param iceCandidate - Ice Candidate from Server
     */
    handleIceCandidate(iceCandidate) {
        lib_pixelstreamingcommon_ue5_5_1.Logger.Info('Web RTC Controller: onWebRtcIce');
        const candidate = new RTCIceCandidate(iceCandidate);
        this.peerConnectionController.handleOnIce(candidate);
    }
    /**
     * Send the ice Candidate to the signaling server via websocket
     * @param iceEvent - RTC Peer ConnectionIceEvent) {
     */
    handleSendIceCandidate(iceEvent) {
        lib_pixelstreamingcommon_ue5_5_1.Logger.Info('OnIceCandidate');
        if (iceEvent.candidate && iceEvent.candidate.candidate) {
            this.protocol.sendMessage(lib_pixelstreamingcommon_ue5_5_1.MessageHelpers.createMessage(lib_pixelstreamingcommon_ue5_5_1.Messages.iceCandidate, { candidate: iceEvent.candidate }));
        }
    }
    /**
     * Send the ice Candidate to the signaling server via websocket
     * @param iceEvent - RTC Peer ConnectionIceEvent) {
     */
    handleDataChannel(datachannelEvent) {
        lib_pixelstreamingcommon_ue5_5_1.Logger.Info('Data channel created for us by browser as we are a receiving peer.');
        this.sendrecvDataChannelController.dataChannel = datachannelEvent.channel;
        // Data channel was created for us, so we just need to setup its callbacks and array type
        this.sendrecvDataChannelController.setupDataChannel();
        this.sendrecvDataChannelController.handleOnMessage = (ev) => this.handleOnMessage(ev);
    }
    /**
     * Send the RTC Offer Session to the Signaling server via websocket
     * @param offer - RTC Session Description
     */
    handleSendWebRTCOffer(offer) {
        lib_pixelstreamingcommon_ue5_5_1.Logger.Info('Sending the offer to the Server');
        const extraParams = {
            sdp: offer.sdp,
            minBitrateBps: 1000 * this.config.getNumericSettingValue(Config_1.NumericParameters.WebRTCMinBitrate),
            maxBitrateBps: 1000 * this.config.getNumericSettingValue(Config_1.NumericParameters.WebRTCMaxBitrate)
        };
        this.protocol.sendMessage(lib_pixelstreamingcommon_ue5_5_1.MessageHelpers.createMessage(lib_pixelstreamingcommon_ue5_5_1.Messages.offer, extraParams));
    }
    /**
     * Send the RTC Offer Session to the Signaling server via websocket
     * @param answer - RTC Session Description
     */
    handleSendWebRTCAnswer(answer) {
        lib_pixelstreamingcommon_ue5_5_1.Logger.Info('Sending the answer to the Server');
        const extraParams = {
            sdp: answer.sdp,
            minBitrateBps: 1000 * this.config.getNumericSettingValue(Config_1.NumericParameters.WebRTCMinBitrate),
            maxBitrateBps: 1000 * this.config.getNumericSettingValue(Config_1.NumericParameters.WebRTCMaxBitrate)
        };
        this.protocol.sendMessage(lib_pixelstreamingcommon_ue5_5_1.MessageHelpers.createMessage(lib_pixelstreamingcommon_ue5_5_1.Messages.answer, extraParams));
        if (this.isUsingSFU) {
            this.protocol.sendMessage(lib_pixelstreamingcommon_ue5_5_1.MessageHelpers.createMessage(lib_pixelstreamingcommon_ue5_5_1.Messages.dataChannelRequest));
        }
        // Send answer back to Pixel Streaming main class for event dispatch
        this.pixelStreaming._onWebRtcSdpAnswer(answer);
    }
    /**
     * Set the freeze frame overlay to the player div
     */
    setUpMouseAndFreezeFrame() {
        // Calculating and normalizing positions depends on the width and height of the player.
        const playerElement = this.videoPlayer.getVideoParentElement();
        const videoElement = this.videoPlayer.getVideoElement();
        this.coordinateConverter.reconfigure({ width: playerElement.clientWidth, height: playerElement.clientHeight }, { width: videoElement.videoWidth, height: videoElement.videoHeight });
        this.freezeFrameController.freezeFrame.resize();
    }
    /**
     * Close the Connection to the signaling server
     */
    closeSignalingServer(message, allowReconnect) {
        var _a;
        this.locallyClosed = true;
        this.enableAutoReconnect = allowReconnect;
        this.disconnectMessage = message;
        (_a = this.protocol) === null || _a === void 0 ? void 0 : _a.disconnect(1000, message);
    }
    /**
     * Close the peer connection
     */
    closePeerConnection() {
        var _a;
        (_a = this.peerConnectionController) === null || _a === void 0 ? void 0 : _a.close();
    }
    /**
     * Close all connections
     */
    close() {
        this.closeSignalingServer('', false);
        this.closePeerConnection();
    }
    /**
     * Fires a Video Stats Event in the RTC Peer Connection
     */
    getStats() {
        this.peerConnectionController.generateStats();
    }
    /**
     * Send a Latency Test Request to the UE Instance
     */
    sendLatencyTest() {
        this.latencyStartTime = Date.now();
        this.streamMessageController.toStreamerHandlers.get('LatencyTest')([
            JSON.stringify({
                StartTime: this.latencyStartTime
            })
        ]);
    }
    /**
     * Send a Data Channel Latency Test Request to the UE Instance
     */
    sendDataChannelLatencyTest(descriptor) {
        this.streamMessageController.toStreamerHandlers.get('DataChannelLatencyTest')([
            JSON.stringify(descriptor)
        ]);
    }
    /**
     * Send the MinQP encoder setting to the UE Instance.
     * @param minQP - The lower bound for QP when encoding
     * valid values are (1-51) where:
     * 1 = Best quality but highest bitrate.
     * 51 = Worst quality but lowest bitrate.
     * By default the minQP is 1 meaning the encoder is free
     * to aim for the best quality it can on the given network link.
     */
    sendEncoderMinQP(minQP) {
        lib_pixelstreamingcommon_ue5_5_1.Logger.Info(`MinQP=${minQP}\n`);
        if (minQP != null) {
            this.streamMessageController.toStreamerHandlers.get('Command')([
                JSON.stringify({
                    'Encoder.MinQP': minQP
                })
            ]);
        }
    }
    /**
     * Send the MaxQP encoder setting to the UE Instance.
     * @param maxQP - The upper bound for QP when encoding
     * valid values are (1-51) where:
     * 1 = Best quality but highest bitrate.
     * 51 = Worst quality but lowest bitrate.
     * By default the maxQP is 51 meaning the encoder is free
     * to drop quality as low as needed on the given network link.
     */
    sendEncoderMaxQP(maxQP) {
        lib_pixelstreamingcommon_ue5_5_1.Logger.Info(`MaxQP=${maxQP}\n`);
        if (maxQP != null) {
            this.streamMessageController.toStreamerHandlers.get('Command')([
                JSON.stringify({
                    'Encoder.MaxQP': maxQP
                })
            ]);
        }
    }
    /**
     * Send the MinQuality encoder setting to the UE Instance.
     * @param minQuality - The lower bound for quality when encoding
     * valid values are (0-100) where:
     * 0 = Worst quality.
     * 100 = Best quality.
     */
    sendEncoderMinQuality(minQuality) {
        lib_pixelstreamingcommon_ue5_5_1.Logger.Info(`MinQuality=${minQuality}\n`);
        if (minQuality != null) {
            this.streamMessageController.toStreamerHandlers.get('Command')([
                JSON.stringify({
                    'Encoder.MinQuality': minQuality
                })
            ]);
        }
    }
    /**
     * Send the MaxQuality encoder setting to the UE Instance.
     * @param maxQuality - The upper bound for quality when encoding
     * valid values are (0-100) where:
     * 0 = Worst quality.
     * 100 = Best quality.
     */
    sendEncoderMaxQuality(maxQuality) {
        lib_pixelstreamingcommon_ue5_5_1.Logger.Info(`MaxQuality=${maxQuality}\n`);
        if (maxQuality != null) {
            this.streamMessageController.toStreamerHandlers.get('Command')([
                JSON.stringify({
                    'Encoder.MaxQuality': maxQuality
                })
            ]);
        }
    }
    /**
     * Send the { WebRTC.MinBitrate: SomeNumber }} command to UE to set
     * the minimum bitrate that we allow WebRTC to use
     * (note setting this too high in poor networks can be problematic).
     * @param minBitrate - The minimum bitrate we would like WebRTC to not fall below.
     */
    sendWebRTCMinBitrate(minBitrate) {
        lib_pixelstreamingcommon_ue5_5_1.Logger.Info(`WebRTC Min Bitrate=${minBitrate}`);
        if (minBitrate != null) {
            this.streamMessageController.toStreamerHandlers.get('Command')([
                JSON.stringify({
                    'WebRTC.MinBitrate': minBitrate
                })
            ]);
        }
    }
    /**
     * Send the { WebRTC.MaxBitrate: SomeNumber }} command to UE to set
     * the minimum bitrate that we allow WebRTC to use
     * (note setting this too low could result in blocky video).
     * @param minBitrate - The minimum bitrate we would like WebRTC to not fall below.
     */
    sendWebRTCMaxBitrate(maxBitrate) {
        lib_pixelstreamingcommon_ue5_5_1.Logger.Info(`WebRTC Max Bitrate=${maxBitrate}`);
        if (maxBitrate != null) {
            this.streamMessageController.toStreamerHandlers.get('Command')([
                JSON.stringify({
                    'WebRTC.MaxBitrate': maxBitrate
                })
            ]);
        }
    }
    /**
     * Send the { WebRTC.Fps: SomeNumber }} UE 5.0+
     * and { WebRTC.MaxFps } UE 4.27 command to set
     * the maximum fps we would like WebRTC to stream at.
     * @param fps - The maximum stream fps.
     */
    sendWebRTCFps(fps) {
        lib_pixelstreamingcommon_ue5_5_1.Logger.Info(`WebRTC FPS=${fps}`);
        if (fps != null) {
            this.streamMessageController.toStreamerHandlers.get('Command')([
                JSON.stringify({ 'WebRTC.Fps': fps })
            ]);
            /* TODO: Remove when UE 4.27 unsupported. */
            this.streamMessageController.toStreamerHandlers.get('Command')([
                JSON.stringify({ 'WebRTC.MaxFps': fps })
            ]);
        }
    }
    /**
     * Sends the UI Descriptor `stat fps` to the UE Instance
     */
    sendShowFps() {
        lib_pixelstreamingcommon_ue5_5_1.Logger.Info('----   Sending show stat to UE   ----');
        this.streamMessageController.toStreamerHandlers.get('Command')([JSON.stringify({ 'stat.fps': '' })]);
    }
    /**
     * Send an Iframe request to the streamer
     */
    sendIframeRequest() {
        lib_pixelstreamingcommon_ue5_5_1.Logger.Info('----   Sending Request for an IFrame  ----');
        this.streamMessageController.toStreamerHandlers.get('IFrameRequest')();
    }
    /**
     * Send a UIInteraction message
     */
    emitUIInteraction(descriptor) {
        lib_pixelstreamingcommon_ue5_5_1.Logger.Info('----   Sending custom UIInteraction message   ----');
        this.streamMessageController.toStreamerHandlers.get('UIInteraction')([JSON.stringify(descriptor)]);
    }
    /**
     * Send a Command message
     */
    emitCommand(descriptor) {
        lib_pixelstreamingcommon_ue5_5_1.Logger.Info('----   Sending custom Command message   ----');
        this.streamMessageController.toStreamerHandlers.get('Command')([JSON.stringify(descriptor)]);
    }
    /**
     * Send a console command message
     */
    emitConsoleCommand(command) {
        lib_pixelstreamingcommon_ue5_5_1.Logger.Info('----   Sending custom Command:ConsoleCommand message   ----');
        this.streamMessageController.toStreamerHandlers.get('Command')([
            JSON.stringify({
                ConsoleCommand: command
            })
        ]);
    }
    /**
     * Sends a request to the UE Instance to have ownership of Quality
     */
    sendRequestQualityControlOwnership() {
        lib_pixelstreamingcommon_ue5_5_1.Logger.Info('----   Sending Request to Control Quality  ----');
        this.toStreamerMessagesController.SendRequestQualityControl();
    }
    /**
     * Send a `TextBoxEntry` message back to UE.
     * @param contents The new contents of the UE side text box.
     */
    sendTextboxEntry(contents) {
        var _a;
        lib_pixelstreamingcommon_ue5_5_1.Logger.Info('----   Sending TextboxEntry message  ----');
        (_a = this.streamMessageController.toStreamerHandlers.get('TextboxEntry')) === null || _a === void 0 ? void 0 : _a([contents]);
    }
    /**
     * Handles when a Latency Test Result are received from the UE Instance
     * @param message - Latency Test Timings
     */
    handleLatencyTestResult(message) {
        lib_pixelstreamingcommon_ue5_5_1.Logger.Info('DataChannelReceiveMessageType.latencyTest');
        const latencyAsString = new TextDecoder('utf-16').decode(message.slice(1));
        const latencyTestResults = new LatencyTestResults_1.LatencyTestResults();
        Object.assign(latencyTestResults, JSON.parse(latencyAsString));
        latencyTestResults.processFields();
        latencyTestResults.testStartTimeMs = this.latencyStartTime;
        latencyTestResults.browserReceiptTimeMs = Date.now();
        latencyTestResults.latencyExcludingDecode = ~~(latencyTestResults.browserReceiptTimeMs - latencyTestResults.testStartTimeMs);
        latencyTestResults.testDuration = ~~(latencyTestResults.TransmissionTimeMs - latencyTestResults.ReceiptTimeMs);
        latencyTestResults.networkLatency = ~~(latencyTestResults.latencyExcludingDecode - latencyTestResults.testDuration);
        if (latencyTestResults.frameDisplayDeltaTimeMs && latencyTestResults.browserReceiptTimeMs) {
            latencyTestResults.endToEndLatency = ~~(latencyTestResults.frameDisplayDeltaTimeMs +
                latencyTestResults.networkLatency,
                +latencyTestResults.CaptureToSendMs);
        }
        this.pixelStreaming._onLatencyTestResult(latencyTestResults);
    }
    /**
     * Handles when a Data Channel Latency Test Response is received from the UE Instance
     * @param message - Data Channel Latency Test Response
     */
    handleDataChannelLatencyTestResponse(message) {
        lib_pixelstreamingcommon_ue5_5_1.Logger.Info('DataChannelReceiveMessageType.dataChannelLatencyResponse');
        const responseAsString = new TextDecoder('utf-16').decode(message.slice(1));
        const latencyTestResponse = JSON.parse(responseAsString);
        this.pixelStreaming._onDataChannelLatencyTestResponse(latencyTestResponse);
    }
    /**
     * Handles when the Encoder and Web RTC Settings are received from the UE Instance
     * @param message - Initial Encoder and Web RTC Settings
     */
    handleInitialSettings(message) {
        lib_pixelstreamingcommon_ue5_5_1.Logger.Info('DataChannelReceiveMessageType.InitialSettings');
        const payloadAsString = new TextDecoder('utf-16').decode(message.slice(1));
        const parsedInitialSettings = JSON.parse(payloadAsString);
        const initialSettings = new InitialSettings_1.InitialSettings();
        if (parsedInitialSettings.Encoder) {
            initialSettings.EncoderSettings = parsedInitialSettings.Encoder;
        }
        if (parsedInitialSettings.WebRTC) {
            initialSettings.WebRTCSettings = parsedInitialSettings.WebRTC;
        }
        if (parsedInitialSettings.PixelStreaming) {
            initialSettings.PixelStreamingSettings = parsedInitialSettings.PixelStreaming;
        }
        if (parsedInitialSettings.ConfigOptions &&
            parsedInitialSettings.ConfigOptions.DefaultToHover !== undefined) {
            this.config.setFlagEnabled(Config_1.Flags.HoveringMouseMode, !!parsedInitialSettings.ConfigOptions.DefaultToHover);
        }
        initialSettings.ueCompatible();
        lib_pixelstreamingcommon_ue5_5_1.Logger.Info(payloadAsString);
        this.pixelStreaming._onInitialSettings(initialSettings);
    }
    /**
     * Handles when the Quantization Parameter are received from the UE Instance
     * @param message - Encoders Quantization Parameter
     */
    handleVideoEncoderAvgQP(message) {
        lib_pixelstreamingcommon_ue5_5_1.Logger.Info('DataChannelReceiveMessageType.VideoEncoderAvgQP');
        const AvgQP = Number(new TextDecoder('utf-16').decode(message.slice(1)));
        this.setVideoEncoderAvgQP(AvgQP);
    }
    /**
     * Handles when the video element has been loaded with a srcObject
     */
    handleVideoInitialized() {
        this.pixelStreaming._onVideoInitialized();
        // either autoplay the video or set up the play overlay
        this.autoPlayVideoOrSetUpPlayOverlay();
        this.resizePlayerStyle();
        this.videoPlayer.updateVideoStreamSize();
    }
    /**
     * Flag set if the user has Quality Ownership
     * @param message - Does the current client have Quality Ownership
     */
    onQualityControlOwnership(message) {
        const view = new Uint8Array(message);
        lib_pixelstreamingcommon_ue5_5_1.Logger.Info('DataChannelReceiveMessageType.QualityControlOwnership');
        this.isQualityController = new Boolean(view[1]).valueOf();
        lib_pixelstreamingcommon_ue5_5_1.Logger.Info(`Received quality controller message, will control quality: ${this.isQualityController}`);
        this.pixelStreaming._onQualityControlOwnership(this.isQualityController);
    }
    /**
     * Handles when the Aggregated stats are Collected
     * @param stats - Aggregated Stats
     */
    handleVideoStats(stats) {
        this.pixelStreaming._onVideoStats(stats);
    }
    /**
     * To Resize the Video Player element
     */
    resizePlayerStyle() {
        this.videoPlayer.resizePlayerStyle();
    }
    setPreferredCodec(codec) {
        this.preferredCodec = codec;
        if (this.peerConnectionController) {
            this.peerConnectionController.preferredCodec = codec;
            this.peerConnectionController.updateCodecSelection = false;
        }
    }
    setVideoEncoderAvgQP(avgQP) {
        this.videoAvgQp = avgQP;
        this.pixelStreaming._onVideoEncoderAvgQP(this.videoAvgQp);
    }
    /**
     * enables/disables keyboard event listeners
     */
    setKeyboardInputEnabled(isEnabled) {
        var _a;
        (_a = this.keyboardController) === null || _a === void 0 ? void 0 : _a.unregister();
        if (isEnabled) {
            this.keyboardController = this.inputClassesFactory.registerKeyBoard(this.config);
        }
    }
    /**
     * enables/disables mouse event listeners
     */
    setMouseInputEnabled(isEnabled) {
        var _a;
        (_a = this.mouseController) === null || _a === void 0 ? void 0 : _a.unregister();
        if (isEnabled) {
            const mouseMode = this.config.isFlagEnabled(Config_1.Flags.HoveringMouseMode)
                ? Config_1.ControlSchemeType.HoveringMouse
                : Config_1.ControlSchemeType.LockedMouse;
            this.mouseController = this.inputClassesFactory.registerMouse(mouseMode);
        }
    }
    /**
     * enables/disables touch event listeners
     */
    setTouchInputEnabled(isEnabled) {
        var _a;
        (_a = this.touchController) === null || _a === void 0 ? void 0 : _a.unregister();
        if (isEnabled) {
            this.touchController = this.inputClassesFactory.registerTouch(this.config.isFlagEnabled(Config_1.Flags.FakeMouseWithTouches));
        }
    }
    /**
     * enables/disables game pad event listeners
     */
    setGamePadInputEnabled(isEnabled) {
        var _a;
        (_a = this.gamePadController) === null || _a === void 0 ? void 0 : _a.unregister();
        if (isEnabled) {
            this.gamePadController = this.inputClassesFactory.registerGamePad();
        }
    }
    registerDataChannelEventEmitters(dataChannel) {
        dataChannel.onOpen = (label, event) => this.pixelStreaming.dispatchEvent(new EventEmitter_1.DataChannelOpenEvent({ label, event }));
        dataChannel.onClose = (label, event) => this.pixelStreaming.dispatchEvent(new EventEmitter_1.DataChannelCloseEvent({ label, event }));
        dataChannel.onError = (label, event) => this.pixelStreaming.dispatchEvent(new EventEmitter_1.DataChannelErrorEvent({ label, event }));
    }
    registerMessageHandler(name, direction, handler) {
        if (direction === StreamMessageController_1.MessageDirection.FromStreamer && typeof handler === 'undefined') {
            lib_pixelstreamingcommon_ue5_5_1.Logger.Warning(`Unable to register handler for ${name} as no handler was passed`);
        }
        this.streamMessageController.registerMessageHandler(direction, name, (data) => typeof handler === 'undefined' && direction === StreamMessageController_1.MessageDirection.ToStreamer
            ? this.sendMessageController.sendMessageToStreamer(name, data)
            : handler(data));
    }
}
exports.WebRtcPlayerController = WebRtcPlayerController;
//# sourceMappingURL=WebRtcPlayerController.js.map